<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(report.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
    // If there are no events, or the last event does not match
    // the main warning message we print the warning message as a separate
    // error node.
    var lastEvent = null
    if (currentEvents.length > 0)
      lastEvent =currentEvents[currentEvents.length - 1];
    if (!lastEvent ||
          lastEvent.message != this._currentReport.message ||
          lastEvent.line != this._currentReport.line){
        var element = document.createElement('div');
        var left = that._codeMirror.defaultCharWidth() * lastEvent.column + 'px';
        element.setAttribute('style', 'margin-left: ' + left);
        element.setAttribute('class', 'check-msg ' + "error");
        var error_tag = document.createElement('span');
        error_tag.setAttribute('class', 'checker-enum error');
        error_tag.innerHTML = "E";
        element.appendChild(error_tag);
        var msg = document.createElement('span');
        msg.innerHTML = that.escapeHTML(this._currentReport.message)
          .replace(/(?:\r\n|\r|\n)/g, '<br>');
        element.appendChild(msg);
        that._lineWidgets.push(that._codeMirror.addLineWidget(
          this._currentReport.line - 1, element));
      }
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This file implements the AssertionResult type.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251                                   \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\nnamespace testing {\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn&#x27;t successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() &lt;&lt; n &lt;&lt; &quot; is even&quot;;\n//     else\n//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         &lt;&lt; &quot;Expected: &quot; &lt;&lt; expr &lt;&lt; &quot; is even\\n  Actual: it&#x27;s &quot; &lt;&lt; n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it&#x27;s 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult&amp; other);\n\n// C4800 is a level 3 warning in Visual Studio 2015 and earlier.\n// This warning is not emitted in Visual Studio 2017.\n// This warning is off by default starting in Visual Studio 2019 but can be\n// enabled with command-line options.\n#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1910 || _MSC_VER &gt;= 1920)\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n#endif\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult&#x27;s copy constructor to be used.\n  template &lt;typename T&gt;\n  explicit AssertionResult(\n      const T&amp; success,\n      typename std::enable_if&lt;\n          !std::is_convertible&lt;T, AssertionResult&gt;::value&gt;::type*\n      /*enabler*/\n      = nullptr)\n      : success_(success) {}\n\n#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1910 || _MSC_VER &gt;= 1920)\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n  // Assignment operator.\n  AssertionResult&amp; operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true if and only if the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion&#x27;s negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate&#x27;s outcome doesn&#x27;t match the\n  // assertion&#x27;s expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != nullptr ? message_-&gt;c_str() : &quot;&quot;;\n  }\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template &lt;typename T&gt;\n  AssertionResult&amp; operator&lt;&lt;(const T&amp; value) {\n    AppendMessage(Message() &lt;&lt; value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult&amp; operator&lt;&lt;(\n      ::std::ostream&amp; (*basic_manipulator)(::std::ostream&amp; stream)) {\n    AppendMessage(Message() &lt;&lt; basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message&amp; a_message) {\n    if (message_.get() == nullptr) message_.reset(new ::std::string);\n    message_-&gt;append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult&amp; other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate&#x27;s outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  std::unique_ptr&lt; ::std::string&gt; message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() &lt;&lt; msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message&amp; msg);\n\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This file implements just enough of the matcher interface to allow\n// EXPECT_DEATH and friends to accept a matcher argument.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gtest/gtest-printers.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n// MSVC warning C5046 is new as of VS2017 version 15.8.\n#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915\n#define GTEST_MAYBE_5046_ 5046\n#else\n#define GTEST_MAYBE_5046_\n#endif\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(\n    4251 GTEST_MAYBE_5046_ /* class A needs to have dll-interface to be used by\n                              clients of class B */\n    /* Symbol involving type with internal linkage not defined */)\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherMatcher that implements the matcher interface:\n//     using is_gtest_matcher = void;\n//     bool MatchAndExplain(const T&amp;, std::ostream*);\n//       (MatchResultListener* can also be used instead of std::ostream*)\n//     void DescribeTo(std::ostream*);\n//     void DescribeNegationTo(std::ostream*);\n//\n//   2. a factory function that creates a Matcher&lt;T&gt; object from a\n//      FooMatcherMatcher.\n\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template &lt;typename T&gt;\n  MatchResultListener&amp; operator&lt;&lt;(const T&amp; x) {\n    if (stream_ != nullptr) *stream_ &lt;&lt; x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true if and only if the listener is interested in an explanation\n  // of the match result.  A matcher&#x27;s MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != nullptr; }\n\n private:\n  ::std::ostream* const stream_;\n\n  MatchResultListener(const MatchResultListener&amp;) = delete;\n  MatchResultListener&amp; operator=(const MatchResultListener&amp;) = delete;\n};\n\ninline MatchResultListener::~MatchResultListener() {}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass GTEST_API_ MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints &quot;is greater than 7&quot;.\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is &quot;is greater than\n  // 7&quot;, the negated description could be &quot;is not greater than 7&quot;.\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;not (&quot;;\n    DescribeTo(os);\n    *os &lt;&lt; &quot;)&quot;;\n  }\n};\n\n// The implementation of a matcher.\ntemplate &lt;typename T&gt;\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true if and only if the matcher matches x; also explains the\n  // match result to &#x27;listener&#x27; if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (&quot;which ...&quot;,\n  // &quot;whose ...&quot;, etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like &quot;which points to ...&quot;.\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that&#x27;s not already present (or not obvious) in the\n  // print-out of x and the matcher&#x27;s description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a &quot;has at least 10 elements&quot; matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // &quot;is empty&quot; matcher probably only needs to explain what the actual\n  // size is when the match fails, as it&#x27;s redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It&#x27;s the responsibility of the caller (Google Test) to guarantee\n  // that &#x27;listener&#x27; is not NULL.  This helps to simplify a matcher&#x27;s\n  // implementation when it doesn&#x27;t care about the performance, as it\n  // can talk to &#x27;listener&#x27; without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener-&gt;stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a == b;\n  }\n};\nstruct AnyNe {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a != b;\n  }\n};\nstruct AnyLt {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a &lt; b;\n  }\n};\nstruct AnyGt {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a &gt; b;\n  }\n};\nstruct AnyLe {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a &lt;= b;\n  }\n};\nstruct AnyGe {\n  template &lt;typename A, typename B&gt;\n  bool operator()(const A&amp; a, const B&amp; b) const {\n    return a &gt;= b;\n  }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(nullptr) {}\n\n private:\n  DummyMatchResultListener(const DummyMatchResultListener&amp;) = delete;\n  DummyMatchResultListener&amp; operator=(const DummyMatchResultListener&amp;) = delete;\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  StreamMatchResultListener(const StreamMatchResultListener&amp;) = delete;\n  StreamMatchResultListener&amp; operator=(const StreamMatchResultListener&amp;) =\n      delete;\n};\n\nstruct SharedPayloadBase {\n  std::atomic&lt;int&gt; ref{1};\n  void Ref() { ref.fetch_add(1, std::memory_order_relaxed); }\n  bool Unref() { return ref.fetch_sub(1, std::memory_order_acq_rel) == 1; }\n};\n\ntemplate &lt;typename T&gt;\nstruct SharedPayload : SharedPayloadBase {\n  explicit SharedPayload(const T&amp; v) : value(v) {}\n  explicit SharedPayload(T&amp;&amp; v) : value(std::move(v)) {}\n\n  static void Destroy(SharedPayloadBase* shared) {\n    delete static_cast&lt;SharedPayload*&gt;(shared);\n  }\n\n  T value;\n};\n\n// An internal class for implementing Matcher&lt;T&gt;, which will derive\n// from it.  We put functionalities common to all Matcher&lt;T&gt;\n// specializations here to avoid code duplication.\ntemplate &lt;typename T&gt;\nclass MatcherBase : private MatcherDescriberInterface {\n public:\n  // Returns true if and only if the matcher matches x; also explains the\n  // match result to &#x27;listener&#x27;.\n  bool MatchAndExplain(const T&amp; x, MatchResultListener* listener) const {\n    GTEST_CHECK_(vtable_ != nullptr);\n    return vtable_-&gt;match_and_explain(*this, x, listener);\n  }\n\n  // Returns true if and only if this matcher matches x.\n  bool Matches(const T&amp; x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &amp;dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const final {\n    GTEST_CHECK_(vtable_ != nullptr);\n    vtable_-&gt;describe(*this, os, false);\n  }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const final {\n    GTEST_CHECK_(vtable_ != nullptr);\n    vtable_-&gt;describe(*this, os, true);\n  }\n\n  // Explains why x matches, or doesn&#x27;t match, the matcher.\n  void ExplainMatchResultTo(const T&amp; x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &amp;listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    if (vtable_ == nullptr) return nullptr;\n    return vtable_-&gt;get_describer(*this);\n  }\n\n protected:\n  MatcherBase() : vtable_(nullptr), buffer_() {}\n\n  // Constructs a matcher from its implementation.\n  template &lt;typename U&gt;\n  explicit MatcherBase(const MatcherInterface&lt;U&gt;* impl)\n      : vtable_(nullptr), buffer_() {\n    Init(impl);\n  }\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  MatcherBase(M&amp;&amp; m) : vtable_(nullptr), buffer_() {  // NOLINT\n    Init(std::forward&lt;M&gt;(m));\n  }\n\n  MatcherBase(const MatcherBase&amp; other)\n      : vtable_(other.vtable_), buffer_(other.buffer_) {\n    if (IsShared()) buffer_.shared-&gt;Ref();\n  }\n\n  MatcherBase&amp; operator=(const MatcherBase&amp; other) {\n    if (this == &amp;other) return *this;\n    Destroy();\n    vtable_ = other.vtable_;\n    buffer_ = other.buffer_;\n    if (IsShared()) buffer_.shared-&gt;Ref();\n    return *this;\n  }\n\n  MatcherBase(MatcherBase&amp;&amp; other)\n      : vtable_(other.vtable_), buffer_(other.buffer_) {\n    other.vtable_ = nullptr;\n  }\n\n  MatcherBase&amp; operator=(MatcherBase&amp;&amp; other) {\n    if (this == &amp;other) return *this;\n    Destroy();\n    vtable_ = other.vtable_;\n    buffer_ = other.buffer_;\n    other.vtable_ = nullptr;\n    return *this;\n  }\n\n  ~MatcherBase() override { Destroy(); }\n\n private:\n  struct VTable {\n    bool (*match_and_explain)(const MatcherBase&amp;, const T&amp;,\n                              MatchResultListener*);\n    void (*describe)(const MatcherBase&amp;, std::ostream*, bool negation);\n    // Returns the captured object if it implements the interface, otherwise\n    // returns the MatcherBase itself.\n    const MatcherDescriberInterface* (*get_describer)(const MatcherBase&amp;);\n    // Called on shared instances when the reference count reaches 0.\n    void (*shared_destroy)(SharedPayloadBase*);\n  };\n\n  bool IsShared() const {\n    return vtable_ != nullptr &amp;&amp; vtable_-&gt;shared_destroy != nullptr;\n  }\n\n  // If the implementation uses a listener, call that.\n  template &lt;typename P&gt;\n  static auto MatchAndExplainImpl(const MatcherBase&amp; m, const T&amp; value,\n                                  MatchResultListener* listener)\n      -&gt; decltype(P::Get(m).MatchAndExplain(value, listener-&gt;stream())) {\n    return P::Get(m).MatchAndExplain(value, listener-&gt;stream());\n  }\n\n  template &lt;typename P&gt;\n  static auto MatchAndExplainImpl(const MatcherBase&amp; m, const T&amp; value,\n                                  MatchResultListener* listener)\n      -&gt; decltype(P::Get(m).MatchAndExplain(value, listener)) {\n    return P::Get(m).MatchAndExplain(value, listener);\n  }\n\n  template &lt;typename P&gt;\n  static void DescribeImpl(const MatcherBase&amp; m, std::ostream* os,\n                           bool negation) {\n    if (negation) {\n      P::Get(m).DescribeNegationTo(os);\n    } else {\n      P::Get(m).DescribeTo(os);\n    }\n  }\n\n  template &lt;typename P&gt;\n  static const MatcherDescriberInterface* GetDescriberImpl(\n      const MatcherBase&amp; m) {\n    // If the impl is a MatcherDescriberInterface, then return it.\n    // Otherwise use MatcherBase itself.\n    // This allows us to implement the GetDescriber() function without support\n    // from the impl, but some users really want to get their impl back when\n    // they call GetDescriber().\n    // We use std::get on a tuple as a workaround of not having `if constexpr`.\n    return std::get&lt;(\n        std::is_convertible&lt;decltype(&amp;P::Get(m)),\n                            const MatcherDescriberInterface*&gt;::value\n            ? 1\n            : 0)&gt;(std::make_tuple(&amp;m, &amp;P::Get(m)));\n  }\n\n  template &lt;typename P&gt;\n  const VTable* GetVTable() {\n    static constexpr VTable kVTable = {&amp;MatchAndExplainImpl&lt;P&gt;,\n                                       &amp;DescribeImpl&lt;P&gt;, &amp;GetDescriberImpl&lt;P&gt;,\n                                       P::shared_destroy};\n    return &amp;kVTable;\n  }\n\n  union Buffer {\n    // Add some types to give Buffer some common alignment/size use cases.\n    void* ptr;\n    double d;\n    int64_t i;\n    // And add one for the out-of-line cases.\n    SharedPayloadBase* shared;\n  };\n\n  void Destroy() {\n    if (IsShared() &amp;&amp; buffer_.shared-&gt;Unref()) {\n      vtable_-&gt;shared_destroy(buffer_.shared);\n    }\n  }\n\n  template &lt;typename M&gt;\n  static constexpr bool IsInlined() {\n    return sizeof(M) &lt;= sizeof(Buffer) &amp;&amp; alignof(M) &lt;= alignof(Buffer) &amp;&amp;\n           std::is_trivially_copy_constructible&lt;M&gt;::value &amp;&amp;\n           std::is_trivially_destructible&lt;M&gt;::value;\n  }\n\n  template &lt;typename M, bool = MatcherBase::IsInlined&lt;M&gt;()&gt;\n  struct ValuePolicy {\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      // When inlined along with Init, need to be explicit to avoid violating\n      // strict aliasing rules.\n      const M* ptr =\n          static_cast&lt;const M*&gt;(static_cast&lt;const void*&gt;(&amp;m.buffer_));\n      return *ptr;\n    }\n    static void Init(MatcherBase&amp; m, M impl) {\n      ::new (static_cast&lt;void*&gt;(&amp;m.buffer_)) M(impl);\n    }\n    static constexpr auto shared_destroy = nullptr;\n  };\n\n  template &lt;typename M&gt;\n  struct ValuePolicy&lt;M, false&gt; {\n    using Shared = SharedPayload&lt;M&gt;;\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      return static_cast&lt;Shared*&gt;(m.buffer_.shared)-&gt;value;\n    }\n    template &lt;typename Arg&gt;\n    static void Init(MatcherBase&amp; m, Arg&amp;&amp; arg) {\n      m.buffer_.shared = new Shared(std::forward&lt;Arg&gt;(arg));\n    }\n    static constexpr auto shared_destroy = &amp;Shared::Destroy;\n  };\n\n  template &lt;typename U, bool B&gt;\n  struct ValuePolicy&lt;const MatcherInterface&lt;U&gt;*, B&gt; {\n    using M = const MatcherInterface&lt;U&gt;;\n    using Shared = SharedPayload&lt;std::unique_ptr&lt;M&gt;&gt;;\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      return *static_cast&lt;Shared*&gt;(m.buffer_.shared)-&gt;value;\n    }\n    static void Init(MatcherBase&amp; m, M* impl) {\n      m.buffer_.shared = new Shared(std::unique_ptr&lt;M&gt;(impl));\n    }\n\n    static constexpr auto shared_destroy = &amp;Shared::Destroy;\n  };\n\n  template &lt;typename M&gt;\n  void Init(M&amp;&amp; m) {\n    using MM = typename std::decay&lt;M&gt;::type;\n    using Policy = ValuePolicy&lt;MM&gt;;\n    vtable_ = GetVTable&lt;Policy&gt;();\n    Policy::Init(*this, std::forward&lt;M&gt;(m));\n  }\n\n  const VTable* vtable_;\n  Buffer buffer_;\n};\n\n}  // namespace internal\n\n// A Matcher&lt;T&gt; is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher&lt;T&gt; is just a std::shared_ptr to const\n// MatcherInterface&lt;T&gt;.  Don&#x27;t inherit from Matcher!\ntemplate &lt;typename T&gt;\nclass Matcher : public internal::MatcherBase&lt;T&gt; {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface&lt;const T&amp;&gt;* impl)\n      : internal::MatcherBase&lt;T&gt;(impl) {}\n\n  template &lt;typename U&gt;\n  explicit Matcher(\n      const MatcherInterface&lt;U&gt;* impl,\n      typename std::enable_if&lt;!std::is_same&lt;U, const U&amp;&gt;::value&gt;::type* =\n          nullptr)\n      : internal::MatcherBase&lt;T&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m) : internal::MatcherBase&lt;T&gt;(std::forward&lt;M&gt;(m)) {}  // NOLINT\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a std::string\n// matcher is expected.\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;const std::string&amp;&gt;\n    : public internal::MatcherBase&lt;const std::string&amp;&gt; {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)\n      : internal::MatcherBase&lt;const std::string&amp;&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;const std::string&amp;&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;std::string&gt;\n    : public internal::MatcherBase&lt;std::string&gt; {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)\n      : internal::MatcherBase&lt;std::string&gt;(impl) {}\n  explicit Matcher(const MatcherInterface&lt;std::string&gt;* impl)\n      : internal::MatcherBase&lt;std::string&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;std::string&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n// The following two specializations allow the user to write str\n// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a absl::string_view\n// matcher is expected.\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;const internal::StringView&amp;&gt;\n    : public internal::MatcherBase&lt;const internal::StringView&amp;&gt; {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)\n      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(std::forward&lt;M&gt;(m)) {\n  }\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass absl::string_views or std::string_views directly.\n  Matcher(internal::StringView s);  // NOLINT\n};\n\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;internal::StringView&gt;\n    : public internal::MatcherBase&lt;internal::StringView&gt; {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)\n      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}\n  explicit Matcher(const MatcherInterface&lt;internal::StringView&gt;* impl)\n      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;internal::StringView&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass absl::string_views or std::string_views directly.\n  Matcher(internal::StringView s);  // NOLINT\n};\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n// Prints a matcher in a human-readable format.\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matcher&lt;T&gt;&amp; matcher) {\n  matcher.DescribeTo(&amp;os);\n  return os;\n}\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value&amp; value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate &lt;class Impl&gt;\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl&amp; an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl&amp; mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl&amp; impl() const { return impl_; }\n\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    return Matcher&lt;T&gt;(new MonomorphicImpl&lt;const T&amp;&gt;(impl_));\n  }\n\n private:\n  template &lt;typename T&gt;\n  class MonomorphicImpl : public MatcherInterface&lt;T&gt; {\n   public:\n    explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}\n\n    void DescribeTo(::std::ostream* os) const override { impl_.DescribeTo(os); }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      impl_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(T x, MatchResultListener* listener) const override {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n  };\n\n  Impl impl_;\n};\n\n// Creates a matcher from its implementation.\n// DEPRECATED: Especially in the generic code, prefer:\n//   Matcher&lt;T&gt;(new MyMatcherImpl&lt;const T&amp;&gt;(...));\n//\n// MakeMatcher may create a Matcher that accepts its argument by value, which\n// leads to unnecessary copies &amp; lack of support for non-copyable types.\ntemplate &lt;typename T&gt;\ninline Matcher&lt;T&gt; MakeMatcher(const MatcherInterface&lt;T&gt;* impl) {\n  return Matcher&lt;T&gt;(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher&lt;Impl&gt; constructor as it\n// doesn&#x27;t require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher&lt;TypeOfFoo&gt;(foo);\ntemplate &lt;class Impl&gt;\ninline PolymorphicMatcher&lt;Impl&gt; MakePolymorphicMatcher(const Impl&amp; impl) {\n  return PolymorphicMatcher&lt;Impl&gt;(impl);\n}\n\nnamespace internal {\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, &lt;=, &lt;, etc, operators.  The\n// two values being compared don&#x27;t have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a &quot;bare&quot; type (i.e. neither &#x27;const T&#x27; nor &#x27;T&amp;&#x27;).\ntemplate &lt;typename D, typename Rhs, typename Op&gt;\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs&amp; rhs) : rhs_(rhs) {}\n\n  using is_gtest_matcher = void;\n\n  template &lt;typename Lhs&gt;\n  bool MatchAndExplain(const Lhs&amp; lhs, std::ostream*) const {\n    return Op()(lhs, Unwrap(rhs_));\n  }\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; D::Desc() &lt;&lt; &quot; &quot;;\n    UniversalPrint(Unwrap(rhs_), os);\n  }\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; D::NegatedDesc() &lt;&lt; &quot; &quot;;\n    UniversalPrint(Unwrap(rhs_), os);\n  }\n\n private:\n  template &lt;typename T&gt;\n  static const T&amp; Unwrap(const T&amp; v) {\n    return v;\n  }\n  template &lt;typename T&gt;\n  static const T&amp; Unwrap(std::reference_wrapper&lt;T&gt; v) {\n    return v;\n  }\n\n  Rhs rhs_;\n};\n\ntemplate &lt;typename Rhs&gt;\nclass EqMatcher : public ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt; {\n public:\n  explicit EqMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt;(rhs) {}\n  static const char* Desc() { return &quot;is equal to&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t equal to&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass NeMatcher : public ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt; {\n public:\n  explicit NeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt;(rhs) {}\n  static const char* Desc() { return &quot;isn&#x27;t equal to&quot;; }\n  static const char* NegatedDesc() { return &quot;is equal to&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass LtMatcher : public ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt; {\n public:\n  explicit LtMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &lt;&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &lt;&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass GtMatcher : public ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt; {\n public:\n  explicit GtMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &gt;&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &gt;&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass LeMatcher : public ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt; {\n public:\n  explicit LeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &lt;=&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &lt;=&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass GeMatcher : public ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt; {\n public:\n  explicit GeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &gt;=&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &gt;=&quot;; }\n};\n\ntemplate &lt;typename T, typename = typename std::enable_if&lt;\n                          std::is_constructible&lt;std::string, T&gt;::value&gt;::type&gt;\nusing StringLike = T;\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher&lt;T&gt; as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    return MatchAndExplain(std::string(s), listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != nullptr &amp;&amp; MatchAndExplain(std::string(s), listener);\n  }\n\n  // Matches anything that can convert to std::string.\n  //\n  // This is a template, not just a plain function with const std::string&amp;,\n  // because absl::string_view has some interfering non-explicit constructors.\n  template &lt;class MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    const std::string&amp; s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_)\n                       : RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; (full_match_ ? &quot;matches&quot; : &quot;contains&quot;) &lt;&lt; &quot; regular expression &quot;;\n    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;doesn&#x27;t &quot; &lt;&lt; (full_match_ ? &quot;match&quot; : &quot;contain&quot;)\n        &lt;&lt; &quot; regular expression &quot;;\n    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);\n  }\n\n private:\n  const std::shared_ptr&lt;const RE&gt; regex_;\n  const bool full_match_;\n};\n}  // namespace internal\n\n// Matches a string that fully matches regular expression &#x27;regex&#x27;.\n// The matcher takes ownership of &#x27;regex&#x27;.\ninline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(\n    const internal::StringLike&lt;T&gt;&amp; regex) {\n  return MatchesRegex(new internal::RE(std::string(regex)));\n}\n\n// Matches a string that contains regular expression &#x27;regex&#x27;.\n// The matcher takes ownership of &#x27;regex&#x27;.\ninline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(\n    const internal::StringLike&lt;T&gt;&amp; regex) {\n  return ContainsRegex(new internal::RE(std::string(regex)));\n}\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&amp;, Eq(&quot;foo&quot;)\n// wouldn&#x27;t compile.\ntemplate &lt;typename T&gt;\ninline internal::EqMatcher&lt;T&gt; Eq(T x) {\n  return internal::EqMatcher&lt;T&gt;(x);\n}\n\n// Constructs a Matcher&lt;T&gt; from a &#x27;value&#x27; of type T.  The constructed\n// matcher matches any value that&#x27;s equal to &#x27;value&#x27;.\ntemplate &lt;typename T&gt;\nMatcher&lt;T&gt;::Matcher(T value) {\n  *this = Eq(value);\n}\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq&lt;T&gt;(x) is just a convenient short-hand for Matcher&lt;T&gt;(Eq(x))\n// or Matcher&lt;T&gt;(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher&lt;T&gt;(Lt(5)) to be explicit about the type,\n// for example.\ntemplate &lt;typename Lhs, typename Rhs&gt;\ninline Matcher&lt;Lhs&gt; TypedEq(const Rhs&amp; rhs) {\n  return Eq(rhs);\n}\n\n// Creates a polymorphic matcher that matches anything &gt;= x.\ntemplate &lt;typename Rhs&gt;\ninline internal::GeMatcher&lt;Rhs&gt; Ge(Rhs x) {\n  return internal::GeMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &gt; x.\ntemplate &lt;typename Rhs&gt;\ninline internal::GtMatcher&lt;Rhs&gt; Gt(Rhs x) {\n  return internal::GtMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &lt;= x.\ntemplate &lt;typename Rhs&gt;\ninline internal::LeMatcher&lt;Rhs&gt; Le(Rhs x) {\n  return internal::LeMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &lt; x.\ntemplate &lt;typename Rhs&gt;\ninline internal::LtMatcher&lt;Rhs&gt; Lt(Rhs x) {\n  return internal::LtMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate &lt;typename Rhs&gt;\ninline internal::NeMatcher&lt;Rhs&gt; Ne(Rhs x) {\n  return internal::NeMatcher&lt;Rhs&gt;(x);\n}\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais&#x27; (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n\n#include &lt;cstddef&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-assertion-result.h&quot;\n#include &quot;gtest/gtest-death-test.h&quot;\n#include &quot;gtest/gtest-matchers.h&quot;\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/gtest-param-test.h&quot;\n#include &quot;gtest/gtest-printers.h&quot;\n#include &quot;gtest/gtest-test-part.h&quot;\n#include &quot;gtest/gtest-typed-test.h&quot;\n#include &quot;gtest/gtest_pred_impl.h&quot;\n#include &quot;gtest/gtest_prod.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// &quot;yes&quot; to enable colors, &quot;no&quot; (disable colors), or &quot;auto&quot; (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag controls whether the test runner should continue execution past\n// first failure.\nGTEST_DECLARE_bool_(fail_fast);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag controls whether Google Test installs a signal handler that dumps\n// debugging information when fatal signals are raised.\nGTEST_DECLARE_bool_(install_failure_signal_handler);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints only test failures.\nGTEST_DECLARE_bool_(brief);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flags control whether Google Test prints UTF8 characters as text.\nGTEST_DECLARE_bool_(print_utf8);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test Environments are recreated for each\n// repeat of the tests. The default value is true. If set to false the global\n// test Environment objects are only set up once, for the first iteration, and\n// only torn down once, for the last.\nGTEST_DECLARE_bool_(recreate_environments_when_repeating);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests&#x27; order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise. For use with an external test framework.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a &quot;host:port&quot; string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\nGTEST_DECLARE_string_(flagfile);\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n\nnamespace testing {\n\n// Silence C4100 (unreferenced formal parameter) and 4805\n// unsafe mix of type &#x27;const int&#x27; and type &#x27;const bool&#x27;\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4805)\n#pragma warning(disable : 4100)\n#endif\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass FuchsiaDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string&amp; message);\nstd::set&lt;std::string&gt;* GetIgnoredParameterizedTestSuites();\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don&#x27;t forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestSuite;\n\n// Old API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nusing TestCase = TestSuite;\n#endif\nclass TestInfo;\nclass UnitTest;\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestSuites, and\n// each TestSuite contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don&#x27;t need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used in a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // The d&#x27;tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test suite.\n  //\n  // Google Test will call Foo::SetUpTestSuite() before running the first\n  // test in test suite Foo.  Hence a sub-class can define its own\n  // SetUpTestSuite() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestSuite() {}\n\n  // Tears down the stuff shared by all tests in this test suite.\n  //\n  // Google Test will call Foo::TearDownTestSuite() after running the last\n  // test in test suite Foo.  Hence a sub-class can define its own\n  // TearDownTestSuite() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestSuite() {}\n\n  // Legacy API is deprecated but still available. Use SetUpTestSuite and\n  // TearDownTestSuite instead.\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  static void TearDownTestCase() {}\n  static void SetUpTestCase() {}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns true if and only if the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true if and only if the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true if and only if the current test was skipped.\n  static bool IsSkipped();\n\n  // Returns true if and only if the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test suite, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test suite.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the &lt;testcase&gt; element.  Properties recorded from fixture&#x27;s\n  // SetUpTestSuite or TearDownTestSuite are logged as attributes of the\n  // corresponding &lt;testsuite&gt; element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the &lt;testsuites&gt; element.\n  static void RecordProperty(const std::string&amp; key, const std::string&amp; value);\n  static void RecordProperty(const std::string&amp; key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true if and only if the current test has the same fixture class\n  // as the first test in the current test suite.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const std::unique_ptr&lt;GTEST_FLAG_SAVER_&gt; gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user&#x27;s\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user&#x27;s test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return nullptr; }\n\n  // We disallow copying Tests.\n  Test(const Test&amp;) = delete;\n  Test&amp; operator=(const Test&amp;) = delete;\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don&#x27;t inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C&#x27;tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string&amp; a_key, const std::string&amp; a_value)\n      : key_(a_key), value_(a_value) {}\n\n  // Gets the user supplied key.\n  const char* key() const { return key_.c_str(); }\n\n  // Gets the user supplied value.\n  const char* value() const { return value_.c_str(); }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string&amp; new_value) { value_ = new_value; }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D&#x27;tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true if and only if the test passed (i.e. no test part failed).\n  bool Passed() const { return !Skipped() &amp;&amp; !Failed(); }\n\n  // Returns true if and only if the test was skipped.\n  bool Skipped() const;\n\n  // Returns true if and only if the test failed.\n  bool Failed() const;\n\n  // Returns true if and only if the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true if and only if the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Gets the time of the test case start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const { return start_timestamp_; }\n\n  // Returns the i-th test part result among all the results. i can range from 0\n  // to total_part_count() - 1. If i is not in that range, aborts the program.\n  const TestPartResult&amp; GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty&amp; GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestSuite;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n  friend class internal::FuchsiaDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector&lt;TestPartResult&gt;&amp; test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector&lt;TestProperty&gt;&amp; test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the start time.\n  void set_start_timestamp(TimeInMillis start) { start_timestamp_ = start; }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string&amp; xml_element,\n                      const TestProperty&amp; test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testsuite tags.  Returns true if the property is valid.\n  // FIXME: Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string&amp; xml_element,\n                                   const TestProperty&amp; test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult&amp; test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properties_mutex_;\n\n  // The vector of TestPartResults\n  std::vector&lt;TestPartResult&gt; test_part_results_;\n  // The vector of TestProperties\n  std::vector&lt;TestProperty&gt; test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The start time, in milliseconds since UNIX Epoch.\n  TimeInMillis start_timestamp_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  TestResult(const TestResult&amp;) = delete;\n  TestResult&amp; operator=(const TestResult&amp;) = delete;\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test suite name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don&#x27;t inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test suite name.\n  const char* test_suite_name() const { return test_suite_name_.c_str(); }\n\n// Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const char* test_case_name() const { return test_suite_name(); }\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != nullptr) return type_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != nullptr) return value_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Return true if this test should not be run because it&#x27;s in another shard.\n  bool is_in_another_shard() const { return is_in_another_shard_; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test suite Foo is defined as\n  // &quot;Foo.Bar&quot;.  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a &#x27;-&#x27; and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character &#x27;A&#x27; or starts with &quot;Foo.&quot;.\n  bool should_run() const { return should_run_; }\n\n  // Returns true if and only if this test will appear in the XML report.\n  bool is_reportable() const {\n    // The XML report includes tests matching the filter, excluding those\n    // run in other shards.\n    return matches_filter_ &amp;&amp; !is_in_another_shard_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &amp;result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestSuite;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_suite_name, const char* name, const char* type_param,\n      const char* value_param, internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id, internal::SetUpTestSuiteFunc set_up_tc,\n      internal::TearDownTestSuiteFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string&amp; test_suite_name, const std::string&amp; name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  // Skip and records the test result for this object.\n  void Skip();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info-&gt;result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_suite_name_;  // test suite name\n  const std::string name_;             // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;  // ID of the test fixture class\n  bool should_run_;           // True if and only if this test should run\n  bool is_disabled_;          // True if and only if this test is disabled\n  bool matches_filter_;       // True if this test matches the\n                              // user-specified filter.\n  bool is_in_another_shard_;  // Will be run in another shard.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  TestInfo(const TestInfo&amp;) = delete;\n  TestInfo&amp; operator=(const TestInfo&amp;) = delete;\n};\n\n// A test suite, which consists of a vector of TestInfos.\n//\n// TestSuite is not copyable.\nclass GTEST_API_ TestSuite {\n public:\n  // Creates a TestSuite with the given name.\n  //\n  // TestSuite does NOT have a default constructor.  Always use this\n  // constructor to create a TestSuite object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test suite\n  //   a_type_param: the name of the test&#x27;s type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test suite\n  //   tear_down_tc: pointer to the function that tears down the test suite\n  TestSuite(const char* name, const char* a_type_param,\n            internal::SetUpTestSuiteFunc set_up_tc,\n            internal::TearDownTestSuiteFunc tear_down_tc);\n\n  // Destructor of TestSuite.\n  virtual ~TestSuite();\n\n  // Gets the name of the TestSuite.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test suite.\n  const char* type_param() const {\n    if (type_param_.get() != nullptr) return type_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns true if any test in this test suite should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test suite.\n  int successful_test_count() const;\n\n  // Gets the number of skipped tests in this test suite.\n  int skipped_test_count() const;\n\n  // Gets the number of failed tests in this test suite.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test suite.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test suite that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test suite.\n  int total_test_count() const;\n\n  // Returns true if and only if the test suite passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true if and only if the test suite failed.\n  bool Failed() const {\n    return failed_test_count() &gt; 0 || ad_hoc_test_result().Failed();\n  }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Gets the time of the test suite start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const { return start_timestamp_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestSuite and TearDownTestSuite.\n  const TestResult&amp; ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestSuite.\n  std::vector&lt;TestInfo*&gt;&amp; test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestSuite.\n  const std::vector&lt;TestInfo*&gt;&amp; test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test suite.  Will delete the TestInfo upon\n  // destruction of the TestSuite object.\n  void AddTestInfo(TestInfo* test_info);\n\n  // Clears the results of all tests in this test suite.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test suite.\n  static void ClearTestSuiteResult(TestSuite* test_suite) {\n    test_suite-&gt;ClearResult();\n  }\n\n  // Runs every test in this TestSuite.\n  void Run();\n\n  // Skips the execution of tests under this TestSuite\n  void Skip();\n\n  // Runs SetUpTestSuite() for this TestSuite.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestSuite().\n  void RunSetUpTestSuite() {\n    if (set_up_tc_ != nullptr) {\n      (*set_up_tc_)();\n    }\n  }\n\n  // Runs TearDownTestSuite() for this TestSuite.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestSuite().\n  void RunTearDownTestSuite() {\n    if (tear_down_tc_ != nullptr) {\n      (*tear_down_tc_)();\n    }\n  }\n\n  // Returns true if and only if test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Passed();\n  }\n\n  // Returns true if and only if test skipped.\n  static bool TestSkipped(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Skipped();\n  }\n\n  // Returns true if and only if test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Failed();\n  }\n\n  // Returns true if and only if the test is disabled and will be reported in\n  // the XML report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info-&gt;is_reportable() &amp;&amp; test_info-&gt;is_disabled_;\n  }\n\n  // Returns true if and only if test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info-&gt;is_disabled_;\n  }\n\n  // Returns true if and only if this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info-&gt;is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info-&gt;should_run();\n  }\n\n  // Shuffles the tests in this test suite.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test suite.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector&lt;TestInfo*&gt; test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector&lt;int&gt; test_indices_;\n  // Pointer to the function that sets up the test suite.\n  internal::SetUpTestSuiteFunc set_up_tc_;\n  // Pointer to the function that tears down the test suite.\n  internal::TearDownTestSuiteFunc tear_down_tc_;\n  // True if and only if any test in this test suite should run.\n  bool should_run_;\n  // The start time, in milliseconds since UNIX Epoch.\n  TimeInMillis start_timestamp_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestSuite and\n  // TearDownTestSuite.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestSuites.\n  TestSuite(const TestSuite&amp;) = delete;\n  TestSuite&amp; operator=(const TestSuite&amp;) = delete;\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d&#x27;tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return nullptr; }\n};\n\n#if GTEST_HAS_EXCEPTIONS\n\n// Exception which can be thrown from TestEventListener::OnTestPartResult.\nclass GTEST_API_ AssertionException\n    : public internal::GoogleTestFailureException {\n public:\n  explicit AssertionException(const TestPartResult&amp; result)\n      : GoogleTestFailureException(result) {}\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest&amp; unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest&amp; unit_test) = 0;\n\n  // Fired before the test suite starts.\n  virtual void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) {}\n\n  //  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  virtual void OnTestCaseStart(const TestCase&amp; /*test_case*/) {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo&amp; test_info) = 0;\n\n  // Fired when a test is disabled\n  virtual void OnTestDisabled(const TestInfo&amp; /*test_info*/) {}\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  // If you want to throw an exception from this function to skip to the next\n  // TEST, it must be AssertionException defined above, or inherited from it.\n  virtual void OnTestPartResult(const TestPartResult&amp; test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo&amp; test_info) = 0;\n\n  // Fired after the test suite ends.\n  virtual void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) {}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  virtual void OnTestCaseEnd(const TestCase&amp; /*test_case*/) {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest&amp; unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; /*unit_test*/,\n                            int /*iteration*/) override {}\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override {}\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; /*test_case*/) override {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnTestStart(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestDisabled(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestPartResult(const TestPartResult&amp; /*test_part_result*/) override {}\n  void OnTestEnd(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; /*test_case*/) override {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; /*unit_test*/,\n                          int /*iteration*/) override {}\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller&#x27;s responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestSuite;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  TestEventListeners(const TestEventListeners&amp;) = delete;\n  TestEventListeners&amp; operator=(const TestEventListeners&amp;) = delete;\n};\n\n// A UnitTest consists of a vector of TestSuites.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestSuite object for the test that&#x27;s currently running,\n  // or NULL if no test is running.\n  const TestSuite* current_test_suite() const GTEST_LOCK_EXCLUDED_(mutex_);\n\n// Legacy API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const TestCase* current_test_case() const GTEST_LOCK_EXCLUDED_(mutex_);\n#endif\n\n  // Returns the TestInfo object for the test that&#x27;s currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n  // Returns the ParameterizedTestSuiteRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestSuiteRegistry&amp; parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Gets the number of successful test suites.\n  int successful_test_suite_count() const;\n\n  // Gets the number of failed test suites.\n  int failed_test_suite_count() const;\n\n  // Gets the number of all test suites.\n  int total_test_suite_count() const;\n\n  // Gets the number of all test suites that contain at least one test\n  // that should run.\n  int test_suite_to_run_count() const;\n\n  //  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  int successful_test_case_count() const;\n  int failed_test_case_count() const;\n  int total_test_case_count() const;\n  int test_case_to_run_count() const;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of skipped tests.\n  int skipped_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true if and only if the unit test passed (i.e. all test suites\n  // passed).\n  bool Passed() const;\n\n  // Returns true if and only if the unit test failed (i.e. some test suite\n  // failed or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  const TestSuite* GetTestSuite(int i) const;\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const TestCase* GetTestCase(int i) const;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test suites.\n  const TestResult&amp; ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners&amp; listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name, int line_number,\n                         const std::string&amp; message,\n                         const std::string&amp; os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestSuite&#x27;s ad_hoc_test_result_ when invoked\n  // from SetUpTestSuite or TearDownTestSuite, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string&amp; key, const std::string&amp; value);\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  TestSuite* GetMutableTestSuite(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and functions are friends as they need to access private\n  // members of UnitTest.\n  friend class ScopedTrace;\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend std::set&lt;std::string&gt;* internal::GetIgnoredParameterizedTestSuites();\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type, const std::string&amp; message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D&#x27;tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo&amp; trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don&#x27;t mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  UnitTest(const UnitTest&amp;) = delete;\n  UnitTest&amp; operator=(const UnitTest&amp;) = delete;\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn&#x27;t guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()-&gt;AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\n// This overloaded version can be used on Arduino/embedded platforms where\n// there is no argc/argv.\nGTEST_API_ void InitGoogleTest();\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression, const T1&amp; lhs,\n                                   const T2&amp; rhs) {\n  return EqFailure(lhs_expression, rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs), false);\n}\n\n// This block of code defines operator==/!=\n// to block lexical scope lookup.\n// It prevents using invalid operator==/!= defined at namespace scope.\nstruct faketype {};\ninline bool operator==(faketype, faketype) { return true; }\ninline bool operator!=(faketype, faketype) { return false; }\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression, const T1&amp; lhs,\n                            const T2&amp; rhs) {\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template &lt;\n      typename T1, typename T2,\n      // Disable this overload for cases where one argument is a pointer\n      // and the other is the null pointer constant.\n      typename std::enable_if&lt;!std::is_integral&lt;T1&gt;::value ||\n                              !std::is_pointer&lt;T2&gt;::value&gt;::type* = nullptr&gt;\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression, const T1&amp; lhs,\n                                 const T2&amp; rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression, BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  template &lt;typename T&gt;\n  static AssertionResult Compare(\n      const char* lhs_expression, const char* rhs_expression,\n      // Handle cases where &#x27;0&#x27; is used as a null pointer literal.\n      std::nullptr_t /* lhs */, T* rhs) {\n    // We already know that &#x27;lhs&#x27; is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression, static_cast&lt;T*&gt;(nullptr),\n                       rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1&amp; val1, const T2&amp; val2,\n                                   const char* op) {\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; expr1 &lt;&lt; &quot;) &quot; &lt;&lt; op &lt;&lt; &quot; (&quot; &lt;&lt; expr2\n         &lt;&lt; &quot;), actual: &quot; &lt;&lt; FormatForComparisonFailureMessage(val1, val2)\n         &lt;&lt; &quot; vs &quot; &lt;&lt; FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)                                \\\n  template &lt;typename T1, typename T2&gt;                                      \\\n  AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                     const T1&amp; val1, const T2&amp; val2) {     \\\n    if (val1 op val2) {                                                    \\\n      return AssertionSuccess();                                           \\\n    } else {                                                               \\\n      return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);            \\\n    }                                                                      \\\n  }\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=)\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, &lt;=)\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, &lt;)\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, &gt;=)\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, &gt;)\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1, const char* s2);\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1, const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1, const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const char* needle,\n                                       const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const wchar_t* needle,\n                                       const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const char* needle,\n                                          const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const wchar_t* needle,\n                                          const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const ::std::string&amp; needle,\n                                       const ::std::string&amp; haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const ::std::string&amp; needle,\n                                          const ::std::string&amp; haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const ::std::wstring&amp; needle,\n                                       const ::std::wstring&amp; haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const ::std::wstring&amp; needle,\n                                          const ::std::wstring&amp; haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate &lt;typename RawType&gt;\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value, RawType rhs_value) {\n  const FloatingPoint&lt;RawType&gt; lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n         &lt;&lt; lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n         &lt;&lt; rhs_value;\n\n  return EqFailure(lhs_expression, rhs_expression,\n                   StringStreamToString(&amp;lhs_ss), StringStreamToString(&amp;rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1, double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type, const char* file, int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message&amp; message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t, const char* srcfile, int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) {}\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    AssertHelperData(const AssertHelperData&amp;) = delete;\n    AssertHelperData&amp; operator=(const AssertHelperData&amp;) = delete;\n  };\n\n  AssertHelperData* const data_;\n\n  AssertHelper(const AssertHelper&amp;) = delete;\n  AssertHelper&amp; operator=(const AssertHelper&amp;) = delete;\n};\n\n}  // namespace internal\n\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam&lt;int&gt; {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   ~FooTest() override {\n//     // Can use GetParam() here.\n//   }\n//   void SetUp() override {\n//     // Can use GetParam() here.\n//   }\n//   void TearDown override {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_SUITE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate &lt;typename T&gt;\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture&#x27;s\n  // constructor.\n  static const ParamType&amp; GetParam() {\n    GTEST_CHECK_(parameter_ != nullptr)\n        &lt;&lt; &quot;GetParam() can only be called inside a value-parameterized test &quot;\n        &lt;&lt; &quot;-- did you intend to write TEST_P instead of TEST_F?&quot;;\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) { parameter_ = parameter; }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface&lt;T&gt; and Test.\n  template &lt;class TestClass&gt;\n  friend class internal::ParameterizedTestFactory;\n};\n\ntemplate &lt;typename T&gt;\nconst T* WithParamInterface&lt;T&gt;::parameter_ = nullptr;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate &lt;typename T&gt;\nclass TestWithParam : public Test, public WithParamInterface&lt;T&gt; {};\n\n// Macros for indicating success/failure in test code.\n\n// Skips test in runtime.\n// Skipping test aborts current function.\n// Skipped tests are neither successful nor failed.\n#define GTEST_SKIP() GTEST_SKIP_(&quot;&quot;)\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn&#x27;t automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(&quot;Failed&quot;)\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line)        \\\n  GTEST_MESSAGE_AT_(file, line, &quot;Failed&quot;, \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(&quot;Failed&quot;)\n\n// Like GTEST_FAIL(), but at the given source file location.\n#define GTEST_FAIL_AT(file, line)         \\\n  GTEST_MESSAGE_AT_(file, line, &quot;Failed&quot;, \\\n                    ::testing::TestPartResult::kFatalFailure)\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n#define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(&quot;Succeeded&quot;)\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n#define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn&#x27;t throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define GTEST_EXPECT_TRUE(condition)                      \\\n  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define GTEST_EXPECT_FALSE(condition)                        \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define GTEST_ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)\n#define GTEST_ASSERT_FALSE(condition)                        \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Define these macros to 1 to omit the definition of the corresponding\n// EXPECT or ASSERT, which clashes with some users&#x27; own code.\n\n#if !GTEST_DONT_DEFINE_EXPECT_TRUE\n#define EXPECT_TRUE(condition) GTEST_EXPECT_TRUE(condition)\n#endif\n\n#if !GTEST_DONT_DEFINE_EXPECT_FALSE\n#define EXPECT_FALSE(condition) GTEST_EXPECT_FALSE(condition)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_TRUE\n#define ASSERT_TRUE(condition) GTEST_ASSERT_TRUE(condition)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_FALSE\n#define ASSERT_FALSE(condition) GTEST_ASSERT_FALSE(condition)\n#endif\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 &lt; v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 &lt;= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 &gt; v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 &gt;= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By &quot;compatible&quot; we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(Foo(), 5);\n//   EXPECT_EQ(a_pointer, NULL);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) &lt;&lt; &quot;There is no record left.&quot;;\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users&#x27; own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n#define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n#define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n#define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n#define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n#define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n#define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don&#x27;t depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)                                         \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)                                         \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)                                         \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)                                         \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)                                   \\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \\\n                      abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)                                   \\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \\\n                      abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n#define EXPECT_HRESULT_SUCCEEDED(expr) \\\n  EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n#define ASSERT_HRESULT_SUCCEEDED(expr) \\\n  ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n#define EXPECT_HRESULT_FAILED(expr) \\\n  EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#define ASSERT_HRESULT_FAILED(expr) \\\n  ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn&#x27;t generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) &lt;&lt; &quot;Process() failed&quot;;\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n  GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n  GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the given source file path and line number,\n// and the given message) to be included in every test failure message generated\n// by code in the scope of the lifetime of an instance of this class. The effect\n// is undone with the destruction of the instance.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// Example:\n//   testing::ScopedTrace trace(&quot;file.cc&quot;, 123, &quot;message&quot;);\n//\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c&#x27;tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n\n  // Template version. Uses Message() to convert the values into strings.\n  // Slow, but flexible.\n  template &lt;typename T&gt;\n  ScopedTrace(const char* file, int line, const T&amp; message) {\n    PushTrace(file, line, (Message() &lt;&lt; message).GetString());\n  }\n\n  // Optimize for some known types.\n  ScopedTrace(const char* file, int line, const char* message) {\n    PushTrace(file, line, message ? message : &quot;(null)&quot;);\n  }\n\n  ScopedTrace(const char* file, int line, const std::string&amp; message) {\n    PushTrace(file, line, message);\n  }\n\n  // The d&#x27;tor pops the info pushed by the c&#x27;tor.\n  //\n  // Note that the d&#x27;tor is not virtual in order to be efficient.\n  // Don&#x27;t inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  void PushTrace(const char* file, int line, std::string message);\n\n  ScopedTrace(const ScopedTrace&amp;) = delete;\n  ScopedTrace&amp; operator=(const ScopedTrace&amp;) = delete;\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c&#x27;tor and d&#x27;tor.  Therefore it doesn&#x27;t\n                            // need to be used otherwise.\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n//\n// Assuming that each thread maintains its own stack of traces.\n// Therefore, a SCOPED_TRACE() would (correctly) only affect the\n// assertions in its own thread.\n#define SCOPED_TRACE(message)                                         \\\n  ::testing::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)( \\\n      __FILE__, __LINE__, (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq&lt;type1, type2&gt;() compiles if and only if type1 and type2\n// are the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq&lt;T1, T2&gt; by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq&lt;T1, T2&gt;() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template &lt;typename T&gt; class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq&lt;int, T&gt;(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo&lt;bool&gt; foo; }\n//\n// will NOT generate a compiler error, as Foo&lt;bool&gt;::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo&lt;bool&gt; foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate &lt;typename T1, typename T2&gt;\nconstexpr bool StaticAssertTypeEq() noexcept {\n  static_assert(std::is_same&lt;T1, T2&gt;::value, &quot;T1 and T2 are not the same type&quot;);\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test suite, and the second\n// parameter is the name of the test within the test suite.\n//\n// The convention is to end the test suite name with &quot;Test&quot;.  For\n// example, a test suite for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId&lt;\n// ::testing::Test&gt;() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId&lt;\n// ::testing::Test&gt;() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId&lt;&gt;() from the Google Test\n// framework.\n#define GTEST_TEST(test_suite_name, test_name)             \\\n  GTEST_TEST_(test_suite_name, test_name, ::testing::Test, \\\n              ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n#define TEST(test_suite_name, test_name) GTEST_TEST(test_suite_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test suite name.  The second parameter is the\n// name of the test within the test suite.\n//\n// A test fixture class must be declared earlier.  The user should put\n// the test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(a_.size(), 0);\n//     EXPECT_EQ(b_.size(), 1);\n//   }\n#define GTEST_TEST_F(test_fixture, test_name)        \\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId&lt;test_fixture&gt;())\n#if !GTEST_DONT_DEFINE_TEST_F\n#define TEST_F(test_fixture, test_name) GTEST_TEST_F(test_fixture, test_name)\n#endif\n\n// Returns a path to temporary directory.\n// Tries to determine an appropriate directory for the platform.\nGTEST_API_ std::string TempDir();\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n// Dynamically registers a test with the framework.\n//\n// This is an advanced API only to be used when the `TEST` macros are\n// insufficient. The macros should be preferred when possible, as they avoid\n// most of the complexity of calling this function.\n//\n// The `factory` argument is a factory callable (move-constructible) object or\n// function pointer that creates a new instance of the Test object. It\n// handles ownership to the caller. The signature of the callable is\n// `Fixture*()`, where `Fixture` is the test fixture class for the test. All\n// tests registered with the same `test_suite_name` must return the same\n// fixture type. This is checked at runtime.\n//\n// The framework will infer the fixture class from the factory and will call\n// the `SetUpTestSuite` and `TearDownTestSuite` for it.\n//\n// Must be called before `RUN_ALL_TESTS()` is invoked, otherwise behavior is\n// undefined.\n//\n// Use case example:\n//\n// class MyFixture : public ::testing::Test {\n//  public:\n//   // All of these optional, just like in regular macro usage.\n//   static void SetUpTestSuite() { ... }\n//   static void TearDownTestSuite() { ... }\n//   void SetUp() override { ... }\n//   void TearDown() override { ... }\n// };\n//\n// class MyTest : public MyFixture {\n//  public:\n//   explicit MyTest(int data) : data_(data) {}\n//   void TestBody() override { ... }\n//\n//  private:\n//   int data_;\n// };\n//\n// void RegisterMyTests(const std::vector&lt;int&gt;&amp; values) {\n//   for (int v : values) {\n//     ::testing::RegisterTest(\n//         &quot;MyFixture&quot;, (&quot;Test&quot; + std::to_string(v)).c_str(), nullptr,\n//         std::to_string(v).c_str(),\n//         __FILE__, __LINE__,\n//         // Important to use the fixture type as the return type here.\n//         [=]() -&gt; MyFixture* { return new MyTest(v); });\n//   }\n// }\n// ...\n// int main(int argc, char** argv) {\n//   ::testing::InitGoogleTest(&amp;argc, argv);\n//   std::vector&lt;int&gt; values_to_test = LoadValuesFromConfig();\n//   RegisterMyTests(values_to_test);\n//   ...\n//   return RUN_ALL_TESTS();\n// }\n//\ntemplate &lt;int&amp;... ExplicitParameterBarrier, typename Factory&gt;\nTestInfo* RegisterTest(const char* test_suite_name, const char* test_name,\n                       const char* type_param, const char* value_param,\n                       const char* file, int line, Factory factory) {\n  using TestT = typename std::remove_pointer&lt;decltype(factory())&gt;::type;\n\n  class FactoryImpl : public internal::TestFactoryBase {\n   public:\n    explicit FactoryImpl(Factory f) : factory_(std::move(f)) {}\n    Test* CreateTest() override { return factory_(); }\n\n   private:\n    Factory factory_;\n  };\n\n  return internal::MakeAndRegisterTestInfo(\n      test_suite_name, test_name, type_param, value_param,\n      internal::CodeLocation(file, line), internal::GetTypeId&lt;TestT&gt;(),\n      internal::SuiteApiResolver&lt;TestT&gt;::GetSetUpCaseOrSuite(file, line),\n      internal::SuiteApiResolver&lt;TestT&gt;::GetTearDownCaseOrSuite(file, line),\n      new FactoryImpl{std::move(factory)});\n}\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() { return ::testing::UnitTest::GetInstance()-&gt;Run(); }\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#if GTEST_OS_LINUX\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n#include &lt;stdexcept&gt;\n#endif\n\n#include &lt;ctype.h&gt;\n#include &lt;float.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;iomanip&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-filepath.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;gtest/internal/gtest-type-util.h&quot;\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo##bar\n\n// Stringifies its argument.\n// Work around a bug in visual studio which doesn&#x27;t accept code like this:\n//\n//   #define GTEST_STRINGIFY_(name) #name\n//   #define MACRO(a, b, c) ... GTEST_STRINGIFY_(a) ...\n//   MACRO(, x, y)\n//\n// Complaining about the argument to GTEST_STRINGIFY_ being empty.\n// This is allowed by the spec.\n#define GTEST_STRINGIFY_HELPER_(name, ...) #name\n#define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )\n\nnamespace proto2 {\nclass MessageLite;\n}\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;  // Result of an assertion.\nclass Message;          // Represents a failure message.\nclass Test;             // Represents a test.\nclass TestInfo;         // Information about a test.\nclass TestPartResult;   // Result of a test part.\nclass UnitTest;         // A collection of test suites.\n\ntemplate &lt;typename T&gt;\n::std::string PrintToString(const T&amp; value);\n\nnamespace internal {\n\nstruct TraceInfo;    // Information about a trace point.\nclass TestInfoImpl;  // Opaque implementation of TestInfo\nclass UnitTestImpl;  // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// An IgnoredValue object can be implicitly constructed from ANY value.\nclass IgnoredValue {\n  struct Sink {};\n\n public:\n  // This constructor template allows any value to be implicitly\n  // converted to IgnoredValue.  The object has no data member and\n  // doesn&#x27;t try to remember anything about the argument.  We\n  // deliberately omit the &#x27;explicit&#x27; keyword in order to allow the\n  // conversion to be implicit.\n  // Disable the conversion if T already has a magical conversion operator.\n  // Otherwise we get ambiguity.\n  template &lt;typename T,\n            typename std::enable_if&lt;!std::is_convertible&lt;T, Sink&gt;::value,\n                                    int&gt;::type = 0&gt;\n  IgnoredValue(const T&amp; /* ignored */) {}  // NOLINT(runtime/explicit)\n};\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(const std::string&amp; gtest_msg,\n                                         const Message&amp; user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(\n    4275 /* an exported class was derived from a class that was not exported */)\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult&amp; failure);\n};\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4275\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\nnamespace edit_distance {\n// Returns the optimal edits to go from &#x27;left&#x27; to &#x27;right&#x27;.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner-Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;size_t&gt;&amp; left, const std::vector&lt;size_t&gt;&amp; right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;std::string&gt;&amp; left,\n    const std::vector&lt;std::string&gt;&amp; right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,\n                                         const std::vector&lt;std::string&gt;&amp; right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: &quot;foo&quot;\n//   actual_expression:   &quot;bar&quot;\n//   expected_value:      &quot;5&quot;\n//   actual_value:        &quot;6&quot;\n//\n// The ignoring_case parameter is true if and only if the assertion is a\n// *_STRCASEEQ*.  When it&#x27;s true, the string &quot; (ignoring case)&quot; will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string&amp; expected_value,\n                                     const std::string&amp; actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult&amp; assertion_result, const char* expression_text,\n    const char* actual_predicate_value, const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it&#x27;s very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn&#x27;t work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate &lt;typename RawType&gt;\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8 * sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n      std::numeric_limits&lt;RawType&gt;::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask = ~static_cast&lt;Bits&gt;(0) &gt;&gt;\n                                       (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP&#x27;s (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU&#x27;s, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const uint32_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don&#x27;t expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() { return ReinterpretBits(kExponentBitMask); }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits&amp; bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }\n\n  // Returns true if and only if this is NAN (not a number).\n  bool is_nan() const {\n    // It&#x27;s a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);\n  }\n\n  // Returns true if and only if this number is at most kMaxUlps ULP&#x27;s away\n  // from rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP&#x27;s apart.\n  bool AlmostEquals(const FloatingPoint&amp; rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_) &lt;=\n           kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits&amp; sam) {\n    if (kSignBitMask &amp; sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits&amp; sam1,\n                                                     const Bits&amp; sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits&lt;T&gt;::max() as it clashes with the max()\n// macro defined by &lt;windows.h&gt;.\ntemplate &lt;&gt;\ninline float FloatingPoint&lt;float&gt;::Max() {\n  return FLT_MAX;\n}\ntemplate &lt;&gt;\ninline double FloatingPoint&lt;double&gt;::Max() {\n  return DBL_MAX;\n}\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint&lt;float&gt; Float;\ntypedef FloatingPoint&lt;double&gt; Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test suite, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate &lt;typename T&gt;\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 &amp; 8.0) may try to merge\n  // TypeIdHelper&lt;T&gt;::dummy_ for different Ts as an &quot;optimization&quot;.\n  static bool dummy_;\n};\n\ntemplate &lt;typename T&gt;\nbool TypeIdHelper&lt;T&gt;::dummy_ = false;\n\n// GetTypeId&lt;T&gt;() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate &lt;typename T&gt;\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper&lt;T&gt;::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &amp;(TypeIdHelper&lt;T&gt;::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  TestFactoryBase(const TestFactoryBase&amp;) = delete;\n  TestFactoryBase&amp; operator=(const TestFactoryBase&amp;) = delete;\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate &lt;class TestClass&gt;\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  Test* CreateTest() override { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestSuite() and TearDownTestSuite() functions.\nusing SetUpTestSuiteFunc = void (*)();\nusing TearDownTestSuiteFunc = void (*)();\n\nstruct CodeLocation {\n  CodeLocation(const std::string&amp; a_file, int a_line)\n      : file(a_file), line(a_line) {}\n\n  std::string file;\n  int line;\n};\n\n//  Helper to identify which setup function for TestCase / TestSuite to call.\n//  Only one function is allowed, either TestCase or TestSute but not both.\n\n// Utility functions to help SuiteApiResolver\nusing SetUpTearDownSuiteFuncType = void (*)();\n\ninline SetUpTearDownSuiteFuncType GetNotDefaultOrNull(\n    SetUpTearDownSuiteFuncType a, SetUpTearDownSuiteFuncType def) {\n  return a == def ? nullptr : a;\n}\n\ntemplate &lt;typename T&gt;\n//  Note that SuiteApiResolver inherits from T because\n//  SetUpTestSuite()/TearDownTestSuite() could be protected. This way\n//  SuiteApiResolver can access them.\nstruct SuiteApiResolver : T {\n  // testing::Test is only forward declared at this point. So we make it a\n  // dependent class for the compiler to be OK with it.\n  using Test =\n      typename std::conditional&lt;sizeof(T) != 0, ::testing::Test, void&gt;::type;\n\n  static SetUpTearDownSuiteFuncType GetSetUpCaseOrSuite(const char* filename,\n                                                        int line_num) {\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n    SetUpTearDownSuiteFuncType test_case_fp =\n        GetNotDefaultOrNull(&amp;T::SetUpTestCase, &amp;Test::SetUpTestCase);\n    SetUpTearDownSuiteFuncType test_suite_fp =\n        GetNotDefaultOrNull(&amp;T::SetUpTestSuite, &amp;Test::SetUpTestSuite);\n\n    GTEST_CHECK_(!test_case_fp || !test_suite_fp)\n        &lt;&lt; &quot;Test can not provide both SetUpTestSuite and SetUpTestCase, please &quot;\n           &quot;make sure there is only one present at &quot;\n        &lt;&lt; filename &lt;&lt; &quot;:&quot; &lt;&lt; line_num;\n\n    return test_case_fp != nullptr ? test_case_fp : test_suite_fp;\n#else\n    (void)(filename);\n    (void)(line_num);\n    return &amp;T::SetUpTestSuite;\n#endif\n  }\n\n  static SetUpTearDownSuiteFuncType GetTearDownCaseOrSuite(const char* filename,\n                                                           int line_num) {\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n    SetUpTearDownSuiteFuncType test_case_fp =\n        GetNotDefaultOrNull(&amp;T::TearDownTestCase, &amp;Test::TearDownTestCase);\n    SetUpTearDownSuiteFuncType test_suite_fp =\n        GetNotDefaultOrNull(&amp;T::TearDownTestSuite, &amp;Test::TearDownTestSuite);\n\n    GTEST_CHECK_(!test_case_fp || !test_suite_fp)\n        &lt;&lt; &quot;Test can not provide both TearDownTestSuite and TearDownTestCase,&quot;\n           &quot; please make sure there is only one present at&quot;\n        &lt;&lt; filename &lt;&lt; &quot;:&quot; &lt;&lt; line_num;\n\n    return test_case_fp != nullptr ? test_case_fp : test_suite_fp;\n#else\n    (void)(filename);\n    (void)(line_num);\n    return &amp;T::TearDownTestSuite;\n#endif\n  }\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_suite_name:  name of the test suite\n//   name:             name of the test\n//   type_param:       the name of the test&#x27;s type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param:      text representation of the test&#x27;s value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test suite\n//   tear_down_tc:     pointer to the function that tears down the test suite\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_suite_name, const char* name, const char* type_param,\n    const char* value_param, CodeLocation code_location,\n    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,\n    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// State of the definition of a type-parameterized test suite.\nclass GTEST_API_ TypedTestSuitePState {\n public:\n  TypedTestSuitePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test suite hasn&#x27;t been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr,\n              &quot;%s Test %s must be defined before &quot;\n              &quot;REGISTER_TYPED_TEST_SUITE_P(%s, ...).\\n&quot;,\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string&amp; test_name) const {\n    return registered_tests_.count(test_name) &gt; 0;\n  }\n\n  const CodeLocation&amp; GetCodeLocation(const std::string&amp; test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it-&gt;second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(const char* test_suite_name,\n                                        const char* file, int line,\n                                        const char* registered_tests);\n\n private:\n  typedef ::std::map&lt;std::string, CodeLocation&gt; RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nusing TypedTestCasePState = TypedTestSuitePState;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n// Skips to the first non-space char after the first comma in &#x27;str&#x27;;\n// returns NULL if no comma is found in &#x27;str&#x27;.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, &#x27;,&#x27;);\n  if (comma == nullptr) {\n    return nullptr;\n  }\n  while (IsSpace(*(++comma))) {\n  }\n  return comma;\n}\n\n// Returns the prefix of &#x27;str&#x27; before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, &#x27;,&#x27;);\n  return comma == nullptr ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string&amp; str, char delimiter,\n                 ::std::vector&lt;::std::string&gt;* dest);\n\n// The default argument to the template below for the case when the user does\n// not provide a name generator.\nstruct DefaultNameGenerator {\n  template &lt;typename T&gt;\n  static std::string GetName(int i) {\n    return StreamableToString(i);\n  }\n};\n\ntemplate &lt;typename Provided = DefaultNameGenerator&gt;\nstruct NameGeneratorSelector {\n  typedef Provided type;\n};\n\ntemplate &lt;typename NameGenerator&gt;\nvoid GenerateNamesRecursively(internal::None, std::vector&lt;std::string&gt;*, int) {}\n\ntemplate &lt;typename NameGenerator, typename Types&gt;\nvoid GenerateNamesRecursively(Types, std::vector&lt;std::string&gt;* result, int i) {\n  result-&gt;push_back(NameGenerator::template GetName&lt;typename Types::Head&gt;(i));\n  GenerateNamesRecursively&lt;NameGenerator&gt;(typename Types::Tail(), result,\n                                          i + 1);\n}\n\ntemplate &lt;typename NameGenerator, typename Types&gt;\nstd::vector&lt;std::string&gt; GenerateNames() {\n  std::vector&lt;std::string&gt; result;\n  GenerateNamesRecursively&lt;NameGenerator&gt;(Types(), &amp;result, 0);\n  return result;\n}\n\n// TypeParameterizedTest&lt;Fixture, TestSel, Types&gt;::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It&#x27;s defined in gtest-type-util.h.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;\nclass TypeParameterizedTest {\n public:\n  // &#x27;index&#x27; is the index of the test in the type list &#x27;Types&#x27;\n  // specified in INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestSuite,\n  // Types).  Valid values for &#x27;index&#x27; are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix, const CodeLocation&amp; code_location,\n                       const char* case_name, const char* test_names, int index,\n                       const std::vector&lt;std::string&gt;&amp; type_names =\n                           GenerateNames&lt;DefaultNameGenerator, Types&gt;()) {\n    typedef typename Types::Head Type;\n    typedef Fixture&lt;Type&gt; FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == &#x27;\\0&#x27; ? &quot;&quot; : &quot;/&quot;) + case_name +\n         &quot;/&quot; + type_names[static_cast&lt;size_t&gt;(index)])\n            .c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName&lt;Type&gt;().c_str(),\n        nullptr,  // No value parameter.\n        code_location, GetTypeId&lt;FixtureClass&gt;(),\n        SuiteApiResolver&lt;TestClass&gt;::GetSetUpCaseOrSuite(\n            code_location.file.c_str(), code_location.line),\n        SuiteApiResolver&lt;TestClass&gt;::GetTearDownCaseOrSuite(\n            code_location.file.c_str(), code_location.line),\n        new TestFactoryImpl&lt;TestClass&gt;);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest&lt;Fixture, TestSel,\n                                 typename Types::Tail&gt;::Register(prefix,\n                                                                 code_location,\n                                                                 case_name,\n                                                                 test_names,\n                                                                 index + 1,\n                                                                 type_names);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;\nclass TypeParameterizedTest&lt;Fixture, TestSel, internal::None&gt; {\n public:\n  static bool Register(const char* /*prefix*/, const CodeLocation&amp;,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/,\n                       const std::vector&lt;std::string&gt;&amp; =\n                           std::vector&lt;std::string&gt;() /*type_names*/) {\n    return true;\n  }\n};\n\nGTEST_API_ void RegisterTypeParameterizedTestSuite(const char* test_suite_name,\n                                                   CodeLocation code_location);\nGTEST_API_ void RegisterTypeParameterizedTestSuiteInstantiation(\n    const char* case_name);\n\n// TypeParameterizedTestSuite&lt;Fixture, Tests, Types&gt;::Register()\n// registers *all combinations* of &#x27;Tests&#x27; and &#x27;Types&#x27; with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;\nclass TypeParameterizedTestSuite {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestSuitePState* state, const char* case_name,\n                       const char* test_names,\n                       const std::vector&lt;std::string&gt;&amp; type_names =\n                           GenerateNames&lt;DefaultNameGenerator, Types&gt;()) {\n    RegisterTypeParameterizedTestSuiteInstantiation(case_name);\n    std::string test_name =\n        StripTrailingSpaces(GetPrefixUntilComma(test_names));\n    if (!state-&gt;TestExists(test_name)) {\n      fprintf(stderr, &quot;Failed to get code location for test %s.%s at %s.&quot;,\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(), code_location.line)\n                  .c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation&amp; test_location = state-&gt;GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in &#x27;Test&#x27; for each type in &#x27;Types&#x27;.\n    TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(\n        prefix, test_location, case_name, test_names, 0, type_names);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestSuite&lt;Fixture, typename Tests::Tail,\n                                      Types&gt;::Register(prefix, code_location,\n                                                       state, case_name,\n                                                       SkipComma(test_names),\n                                                       type_names);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;\nclass TypeParameterizedTestSuite&lt;Fixture, internal::None, Types&gt; {\n public:\n  static bool Register(const char* /*prefix*/, const CodeLocation&amp;,\n                       const TypedTestSuitePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       const std::vector&lt;std::string&gt;&amp; =\n                           std::vector&lt;std::string&gt;() /*type_names*/) {\n    return true;\n  }\n};\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won&#x27;t.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(UnitTest* unit_test,\n                                                       int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// Helper for declaring std::string within &#x27;if&#x27; statement\n// in pre C++17 build environment.\nstruct TrueWithString {\n  TrueWithString() = default;\n  explicit TrueWithString(const char* str) : value(str) {}\n  explicit TrueWithString(const std::string&amp; str) : value(str) {}\n  explicit operator bool() const { return true; }\n  std::string value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn&#x27;t use global state (and therefore can&#x27;t interfere with user\n// code).  Unlike rand_r(), it&#x27;s portable.  An LCG isn&#x27;t very random,\n// but it&#x27;s good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const uint32_t kMaxRange = 1u &lt;&lt; 31;\n\n  explicit Random(uint32_t seed) : state_(seed) {}\n\n  void Reseed(uint32_t seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if &#x27;range&#x27; is\n  // 0 or greater than kMaxRange.\n  uint32_t Generate(uint32_t range);\n\n private:\n  uint32_t state_;\n  Random(const Random&amp;) = delete;\n  Random&amp; operator=(const Random&amp;) = delete;\n};\n\n// Turns const U&amp;, U&amp;, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n  typename std::remove_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type\n\n// HasDebugStringAndShortDebugString&lt;T&gt;::value is a compile-time bool constant\n// that&#x27;s true if and only if T has methods DebugString() and ShortDebugString()\n// that return std::string.\ntemplate &lt;typename T&gt;\nclass HasDebugStringAndShortDebugString {\n private:\n  template &lt;typename C&gt;\n  static auto CheckDebugString(C*) -&gt; typename std::is_same&lt;\n      std::string, decltype(std::declval&lt;const C&gt;().DebugString())&gt;::type;\n  template &lt;typename&gt;\n  static std::false_type CheckDebugString(...);\n\n  template &lt;typename C&gt;\n  static auto CheckShortDebugString(C*) -&gt; typename std::is_same&lt;\n      std::string, decltype(std::declval&lt;const C&gt;().ShortDebugString())&gt;::type;\n  template &lt;typename&gt;\n  static std::false_type CheckShortDebugString(...);\n\n  using HasDebugStringType = decltype(CheckDebugString&lt;T&gt;(nullptr));\n  using HasShortDebugStringType = decltype(CheckShortDebugString&lt;T&gt;(nullptr));\n\n public:\n  static constexpr bool value =\n      HasDebugStringType::value &amp;&amp; HasShortDebugStringType::value;\n};\n\ntemplate &lt;typename T&gt;\nconstexpr bool HasDebugStringAndShortDebugString&lt;T&gt;::value;\n\n// When the compiler sees expression IsContainerTest&lt;C&gt;(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as &#x27;int&#x27; is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest&lt;C&gt;(0).\n// The value of the expression is insignificant.\n//\n// In C++11 mode we check the existence of a const_iterator and that an\n// iterator is properly implemented for the container.\n//\n// For pre-C++11 that we look for both C::iterator and C::const_iterator.\n// The reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// &#x27;iterator&#x27; or &#x27;iterator::iterator&#x27;).  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn&#x27;t work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate &lt;class C,\n          class Iterator = decltype(::std::declval&lt;const C&amp;&gt;().begin()),\n          class = decltype(::std::declval&lt;const C&amp;&gt;().end()),\n          class = decltype(++::std::declval&lt;Iterator&amp;&gt;()),\n          class = decltype(*::std::declval&lt;Iterator&gt;()),\n          class = typename C::const_iterator&gt;\nIsContainer IsContainerTest(int /* dummy */) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate &lt;class C&gt;\nIsNotContainer IsContainerTest(long /* dummy */) {\n  return &#x27;\\0&#x27;;\n}\n\n// Trait to detect whether a type T is a hash table.\n// The heuristic used is that the type contains an inner type `hasher` and does\n// not contain an inner type `reverse_iterator`.\n// If the container is iterable in reverse, then order might actually matter.\ntemplate &lt;typename T&gt;\nstruct IsHashTable {\n private:\n  template &lt;typename U&gt;\n  static char test(typename U::hasher*, typename U::reverse_iterator*);\n  template &lt;typename U&gt;\n  static int test(typename U::hasher*, ...);\n  template &lt;typename U&gt;\n  static char test(...);\n\n public:\n  static const bool value = sizeof(test&lt;T&gt;(nullptr, nullptr)) == sizeof(int);\n};\n\ntemplate &lt;typename T&gt;\nconst bool IsHashTable&lt;T&gt;::value;\n\ntemplate &lt;typename C,\n          bool = sizeof(IsContainerTest&lt;C&gt;(0)) == sizeof(IsContainer)&gt;\nstruct IsRecursiveContainerImpl;\n\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainerImpl&lt;C, false&gt; : public std::false_type {};\n\n// Since the IsRecursiveContainerImpl depends on the IsContainerTest we need to\n// obey the same inconsistencies as the IsContainerTest, namely check if\n// something is a container is relying on only const_iterator in C++11 and\n// is relying on both const_iterator and iterator otherwise\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainerImpl&lt;C, true&gt; {\n  using value_type = decltype(*std::declval&lt;typename C::const_iterator&gt;());\n  using type =\n      std::is_same&lt;typename std::remove_const&lt;\n                       typename std::remove_reference&lt;value_type&gt;::type&gt;::type,\n                   C&gt;;\n};\n\n// IsRecursiveContainer&lt;Type&gt; is a unary compile-time predicate that\n// evaluates whether C is a recursive container type. A recursive container\n// type is a container type whose value_type is equal to the container type\n// itself. An example for a recursive container type is\n// boost::filesystem::path, whose iterator has a value_type that is equal to\n// boost::filesystem::path.\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainer : public IsRecursiveContainerImpl&lt;C&gt;::type {};\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements&#x27; operator==, where k can be any integer &gt;= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate &lt;typename T, typename U&gt;\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate &lt;typename T, typename U&gt;\ninline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) {\n  return lhs == rhs;\n}\n\n// This overload is used when k &gt;= 1.\ntemplate &lt;typename T, typename U, size_t N&gt;\ninline bool ArrayEq(const T (&amp;lhs)[N], const U (&amp;rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate &lt;typename T, typename U&gt;\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i])) return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate &lt;typename Iter, typename Element&gt;\nIter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem)) return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements&#x27;\n// operator=, where k can be any integer &gt;= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate &lt;typename T, typename U&gt;\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate &lt;typename T, typename U&gt;\ninline void CopyArray(const T&amp; from, U* to) {\n  *to = from;\n}\n\n// This overload is used when k &gt;= 1.\ntemplate &lt;typename T, typename U, size_t N&gt;\ninline void CopyArray(const T (&amp;from)[N], U (*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate &lt;typename T, typename U&gt;\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock&#x27;s container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It&#x27;s the client&#x27;s responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate &lt;typename Element&gt;\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray&amp; rhs) {\n    (this-&gt;*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &amp;NativeArray::InitRef) delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray&amp; rhs) const {\n    return size() == rhs.size() &amp;&amp; ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  static_assert(!std::is_const&lt;Element&gt;::value, &quot;Type must not be const&quot;);\n  static_assert(!std::is_reference&lt;Element&gt;::value,\n                &quot;Type must not be a reference&quot;);\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &amp;NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &amp;NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n};\n\n// Backport of std::index_sequence.\ntemplate &lt;size_t... Is&gt;\nstruct IndexSequence {\n  using type = IndexSequence;\n};\n\n// Double the IndexSequence, and one if plus_one is true.\ntemplate &lt;bool plus_one, typename T, size_t sizeofT&gt;\nstruct DoubleSequence;\ntemplate &lt;size_t... I, size_t sizeofT&gt;\nstruct DoubleSequence&lt;true, IndexSequence&lt;I...&gt;, sizeofT&gt; {\n  using type = IndexSequence&lt;I..., (sizeofT + I)..., 2 * sizeofT&gt;;\n};\ntemplate &lt;size_t... I, size_t sizeofT&gt;\nstruct DoubleSequence&lt;false, IndexSequence&lt;I...&gt;, sizeofT&gt; {\n  using type = IndexSequence&lt;I..., (sizeofT + I)...&gt;;\n};\n\n// Backport of std::make_index_sequence.\n// It uses O(ln(N)) instantiation depth.\ntemplate &lt;size_t N&gt;\nstruct MakeIndexSequenceImpl\n    : DoubleSequence&lt;N % 2 == 1, typename MakeIndexSequenceImpl&lt;N / 2&gt;::type,\n                     N / 2&gt;::type {};\n\ntemplate &lt;&gt;\nstruct MakeIndexSequenceImpl&lt;0&gt; : IndexSequence&lt;&gt; {};\n\ntemplate &lt;size_t N&gt;\nusing MakeIndexSequence = typename MakeIndexSequenceImpl&lt;N&gt;::type;\n\ntemplate &lt;typename... T&gt;\nusing IndexSequenceFor = typename MakeIndexSequence&lt;sizeof...(T)&gt;::type;\n\ntemplate &lt;size_t&gt;\nstruct Ignore {\n  Ignore(...);  // NOLINT\n};\n\ntemplate &lt;typename&gt;\nstruct ElemFromListImpl;\ntemplate &lt;size_t... I&gt;\nstruct ElemFromListImpl&lt;IndexSequence&lt;I...&gt;&gt; {\n  // We make Ignore a template to solve a problem with MSVC.\n  // A non-template Ignore would work fine with `decltype(Ignore(I))...`, but\n  // MSVC doesn&#x27;t understand how to deal with that pack expansion.\n  // Use `0 * I` to have a single instantiation of Ignore.\n  template &lt;typename R&gt;\n  static R Apply(Ignore&lt;0 * I&gt;..., R (*)(), ...);\n};\n\ntemplate &lt;size_t N, typename... T&gt;\nstruct ElemFromList {\n  using type =\n      decltype(ElemFromListImpl&lt;typename MakeIndexSequence&lt;N&gt;::type&gt;::Apply(\n          static_cast&lt;T (*)()&gt;(nullptr)...));\n};\n\nstruct FlatTupleConstructTag {};\n\ntemplate &lt;typename... T&gt;\nclass FlatTuple;\n\ntemplate &lt;typename Derived, size_t I&gt;\nstruct FlatTupleElemBase;\n\ntemplate &lt;typename... T, size_t I&gt;\nstruct FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt; {\n  using value_type = typename ElemFromList&lt;I, T...&gt;::type;\n  FlatTupleElemBase() = default;\n  template &lt;typename Arg&gt;\n  explicit FlatTupleElemBase(FlatTupleConstructTag, Arg&amp;&amp; t)\n      : value(std::forward&lt;Arg&gt;(t)) {}\n  value_type value;\n};\n\ntemplate &lt;typename Derived, typename Idx&gt;\nstruct FlatTupleBase;\n\ntemplate &lt;size_t... Idx, typename... T&gt;\nstruct FlatTupleBase&lt;FlatTuple&lt;T...&gt;, IndexSequence&lt;Idx...&gt;&gt;\n    : FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, Idx&gt;... {\n  using Indices = IndexSequence&lt;Idx...&gt;;\n  FlatTupleBase() = default;\n  template &lt;typename... Args&gt;\n  explicit FlatTupleBase(FlatTupleConstructTag, Args&amp;&amp;... args)\n      : FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, Idx&gt;(FlatTupleConstructTag{},\n                                                std::forward&lt;Args&gt;(args))... {}\n\n  template &lt;size_t I&gt;\n  const typename ElemFromList&lt;I, T...&gt;::type&amp; Get() const {\n    return FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt;::value;\n  }\n\n  template &lt;size_t I&gt;\n  typename ElemFromList&lt;I, T...&gt;::type&amp; Get() {\n    return FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt;::value;\n  }\n\n  template &lt;typename F&gt;\n  auto Apply(F&amp;&amp; f) -&gt; decltype(std::forward&lt;F&gt;(f)(this-&gt;Get&lt;Idx&gt;()...)) {\n    return std::forward&lt;F&gt;(f)(Get&lt;Idx&gt;()...);\n  }\n\n  template &lt;typename F&gt;\n  auto Apply(F&amp;&amp; f) const -&gt; decltype(std::forward&lt;F&gt;(f)(this-&gt;Get&lt;Idx&gt;()...)) {\n    return std::forward&lt;F&gt;(f)(Get&lt;Idx&gt;()...);\n  }\n};\n\n// Analog to std::tuple but with different tradeoffs.\n// This class minimizes the template instantiation depth, thus allowing more\n// elements than std::tuple would. std::tuple has been seen to require an\n// instantiation depth of more than 10x the number of elements in some\n// implementations.\n// FlatTuple and ElemFromList are not recursive and have a fixed depth\n// regardless of T...\n// MakeIndexSequence, on the other hand, it is recursive but with an\n// instantiation depth of O(ln(N)).\ntemplate &lt;typename... T&gt;\nclass FlatTuple\n    : private FlatTupleBase&lt;FlatTuple&lt;T...&gt;,\n                            typename MakeIndexSequence&lt;sizeof...(T)&gt;::type&gt; {\n  using Indices = typename FlatTupleBase&lt;\n      FlatTuple&lt;T...&gt;, typename MakeIndexSequence&lt;sizeof...(T)&gt;::type&gt;::Indices;\n\n public:\n  FlatTuple() = default;\n  template &lt;typename... Args&gt;\n  explicit FlatTuple(FlatTupleConstructTag tag, Args&amp;&amp;... args)\n      : FlatTuple::FlatTupleBase(tag, std::forward&lt;Args&gt;(args)...) {}\n\n  using FlatTuple::FlatTupleBase::Apply;\n  using FlatTuple::FlatTupleBase::Get;\n};\n\n// Utility functions to be called with static_assert to induce deprecation\n// warnings.\nGTEST_INTERNAL_DEPRECATED(\n    &quot;INSTANTIATE_TEST_CASE_P is deprecated, please use &quot;\n    &quot;INSTANTIATE_TEST_SUITE_P&quot;)\nconstexpr bool InstantiateTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;TYPED_TEST_SUITE_P&quot;)\nconstexpr bool TypedTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;TYPED_TEST_CASE is deprecated, please use &quot;\n    &quot;TYPED_TEST_SUITE&quot;)\nconstexpr bool TypedTestCaseIsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;REGISTER_TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;REGISTER_TYPED_TEST_SUITE_P&quot;)\nconstexpr bool RegisterTypedTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;INSTANTIATE_TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;INSTANTIATE_TYPED_TEST_SUITE_P&quot;)\nconstexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }\n\n}  // namespace internal\n}  // namespace testing\n\nnamespace std {\n// Some standard library implementations use `struct tuple_size` and some use\n// `class tuple_size`. Clang warns about the mismatch.\n// https://reviews.llvm.org/D55466\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Wmismatched-tags&quot;\n#endif\ntemplate &lt;typename... Ts&gt;\nstruct tuple_size&lt;testing::internal::FlatTuple&lt;Ts...&gt;&gt;\n    : std::integral_constant&lt;size_t, sizeof...(Ts)&gt; {};\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n}  // namespace std\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type)             \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) = \\\n      ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n#define GTEST_SKIP_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)\n\n// Suppress MSVC warning 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn&#x27;t return or throw in some\n// situations).\n// NOTE: The &quot;else&quot; is important to keep this expansion to prevent a top-level\n// &quot;else&quot; from attaching to our &quot;if&quot;.\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) {                        \\\n    statement;                                                    \\\n  } else                     /* NOLINT */                         \\\n    static_assert(true, &quot;&quot;)  // User must have a semicolon after expansion.\n\n#if GTEST_HAS_EXCEPTIONS\n\nnamespace testing {\nnamespace internal {\n\nclass NeverThrown {\n public:\n  const char* what() const noexcept {\n    return &quot;this exception should never be thrown&quot;;\n  }\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#if GTEST_HAS_RTTI\n\n#define GTEST_EXCEPTION_TYPE_(e) ::testing::internal::GetTypeName(typeid(e))\n\n#else  // GTEST_HAS_RTTI\n\n#define GTEST_EXCEPTION_TYPE_(e) \\\n  std::string { &quot;an std::exception-derived error&quot; }\n\n#endif  // GTEST_HAS_RTTI\n\n#define GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)   \\\n  catch (typename std::conditional&lt;                                            \\\n         std::is_same&lt;typename std::remove_cv&lt;typename std::remove_reference&lt;  \\\n                          expected_exception&gt;::type&gt;::type,                    \\\n                      std::exception&gt;::value,                                  \\\n         const ::testing::internal::NeverThrown&amp;, const std::exception&amp;&gt;::type \\\n             e) {                                                              \\\n    gtest_msg.value = &quot;Expected: &quot; #statement                                  \\\n                      &quot; throws an exception of type &quot; #expected_exception      \\\n                      &quot;.\\n  Actual: it throws &quot;;                               \\\n    gtest_msg.value += GTEST_EXCEPTION_TYPE_(e);                               \\\n    gtest_msg.value += &quot; with description \\&quot;&quot;;                                 \\\n    gtest_msg.value += e.what();                                               \\\n    gtest_msg.value += &quot;\\&quot;.&quot;;                                                  \\\n    goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);                \\\n  }\n\n#else  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail)              \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                             \\\n  if (::testing::internal::TrueWithString gtest_msg{}) {                    \\\n    bool gtest_caught_expected = false;                                     \\\n    try {                                                                   \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);            \\\n    } catch (expected_exception const&amp;) {                                   \\\n      gtest_caught_expected = true;                                         \\\n    }                                                                       \\\n    GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)    \\\n    catch (...) {                                                           \\\n      gtest_msg.value = &quot;Expected: &quot; #statement                             \\\n                        &quot; throws an exception of type &quot; #expected_exception \\\n                        &quot;.\\n  Actual: it throws a different type.&quot;;         \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);           \\\n    }                                                                       \\\n    if (!gtest_caught_expected) {                                           \\\n      gtest_msg.value = &quot;Expected: &quot; #statement                             \\\n                        &quot; throws an exception of type &quot; #expected_exception \\\n                        &quot;.\\n  Actual: it throws nothing.&quot;;                  \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);           \\\n    }                                                                       \\\n  } else /*NOLINT*/                                                         \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__)                   \\\n        : fail(gtest_msg.value.c_str())\n\n#if GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()                \\\n  catch (std::exception const&amp; e) {                               \\\n    gtest_msg.value = &quot;it throws &quot;;                               \\\n    gtest_msg.value += GTEST_EXCEPTION_TYPE_(e);                  \\\n    gtest_msg.value += &quot; with description \\&quot;&quot;;                    \\\n    gtest_msg.value += e.what();                                  \\\n    gtest_msg.value += &quot;\\&quot;.&quot;;                                     \\\n    goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n  }\n\n#else  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_(statement, fail)                            \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                          \\\n  if (::testing::internal::TrueWithString gtest_msg{}) {                 \\\n    try {                                                                \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);         \\\n    }                                                                    \\\n    GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()                           \\\n    catch (...) {                                                        \\\n      gtest_msg.value = &quot;it throws.&quot;;                                    \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__);      \\\n    }                                                                    \\\n  } else                                                                 \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__)              \\\n        : fail((&quot;Expected: &quot; #statement &quot; doesn&#x27;t throw an exception.\\n&quot; \\\n                &quot;  Actual: &quot; +                                           \\\n                gtest_msg.value)                                         \\\n                   .c_str())\n\n#define GTEST_TEST_ANY_THROW_(statement, fail)                       \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                      \\\n  if (::testing::internal::AlwaysTrue()) {                           \\\n    bool gtest_caught_any = false;                                   \\\n    try {                                                            \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);     \\\n    } catch (...) {                                                  \\\n      gtest_caught_any = true;                                       \\\n    }                                                                \\\n    if (!gtest_caught_any) {                                         \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    }                                                                \\\n  } else                                                             \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__)         \\\n        : fail(&quot;Expected: &quot; #statement                               \\\n               &quot; throws an exception.\\n&quot;                             \\\n               &quot;  Actual: it doesn&#x27;t.&quot;)\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// representation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                       \\\n  if (const ::testing::AssertionResult gtest_ar_ =                    \\\n          ::testing::AssertionResult(expression))                     \\\n    ;                                                                 \\\n  else                                                                \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(         \\\n             gtest_ar_, text, #actual, #expected)                     \\\n             .c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail)                          \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                                \\\n  if (::testing::internal::AlwaysTrue()) {                                     \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);                 \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) {                 \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__);            \\\n    }                                                                          \\\n  } else                                                                       \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__)                    \\\n        : fail(&quot;Expected: &quot; #statement                                         \\\n               &quot; doesn&#x27;t generate new fatal &quot;                                  \\\n               &quot;failures in the current thread.\\n&quot;                             \\\n               &quot;  Actual: it does.&quot;)\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \\\n  test_suite_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_suite_name, test_name, parent_class, parent_id)       \\\n  static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) &gt; 1,                 \\\n                &quot;test_suite_name must not be empty&quot;);                          \\\n  static_assert(sizeof(GTEST_STRINGIFY_(test_name)) &gt; 1,                       \\\n                &quot;test_name must not be empty&quot;);                                \\\n  class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                     \\\n      : public parent_class {                                                  \\\n   public:                                                                     \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default;            \\\n    ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default;  \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                         \\\n    (const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp;) = delete;     \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp; operator=(            \\\n        const GTEST_TEST_CLASS_NAME_(test_suite_name,                          \\\n                                     test_name) &amp;) = delete; /* NOLINT */      \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                         \\\n    (GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp;&amp;) noexcept = delete; \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp; operator=(            \\\n        GTEST_TEST_CLASS_NAME_(test_suite_name,                                \\\n                               test_name) &amp;&amp;) noexcept = delete; /* NOLINT */  \\\n                                                                               \\\n   private:                                                                    \\\n    void TestBody() override;                                                  \\\n    static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;      \\\n  };                                                                           \\\n                                                                               \\\n  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name,           \\\n                                                    test_name)::test_info_ =   \\\n      ::testing::internal::MakeAndRegisterTestInfo(                            \\\n          #test_suite_name, #test_name, nullptr, nullptr,                      \\\n          ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id),  \\\n          ::testing::internal::SuiteApiResolver&lt;                               \\\n              parent_class&gt;::GetSetUpCaseOrSuite(__FILE__, __LINE__),          \\\n          ::testing::internal::SuiteApiResolver&lt;                               \\\n              parent_class&gt;::GetTearDownCaseOrSuite(__FILE__, __LINE__),       \\\n          new ::testing::internal::TestFactoryImpl&lt;GTEST_TEST_CLASS_NAME_(     \\\n              test_suite_name, test_name)&gt;);                                   \\\n  void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don&#x27;t\n// end with _ are part of Google Test&#x27;s public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don&#x27;t need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it&#x27;s necessary for a user to define some of the following\n// macros in the build script to override Google Test&#x27;s decisions.\n//\n// If the user doesn&#x27;t define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don&#x27;t use #ifdef or &quot;#if\n//     defined(...)&quot;, which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren&#x27;t available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that &lt;pthread.h&gt;\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn&#x27;t\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn&#x27;t work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft&#x27;s &quot;Structured\n//                              Exception Handling&quot;.\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n//   GTEST_DEFAULT_DEATH_TEST_STYLE\n//                            - The default value of --gtest_death_test_style.\n//                              The legacy default has been &quot;fast&quot; in the open\n//                              source version since 2008. The recommended value\n//                              is &quot;threadsafe&quot;, and can be set in\n//                              custom/gtest-port.h.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_DRAGONFLY - DragonFlyBSD\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_FUCHSIA  - Fuchsia\n//   GTEST_OS_GNU_HURD - GNU/Hurd\n//   GTEST_OS_GNU_KFREEBSD - GNU/kFreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_NETBSD   - NetBSD\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_OS2      - OS/2\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Mac OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don&#x27;t have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_RE2         - the RE2 regular expression library is used\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above RE\\b(s) are mutually exclusive.\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test&#x27;s INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class&#x27; instances or a\n//                              variable don&#x27;t have to be used.\n//   GTEST_MUST_USE_RESULT_   - declares that a function&#x27;s result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//   GTEST_INTERNAL_HAS_ANY - for enabling UniversalPrinter&lt;std::any&gt; or\n//                            UniversalPrinter&lt;absl::any&gt; specializations.\n//   GTEST_INTERNAL_HAS_OPTIONAL - for enabling UniversalPrinter&lt;std::optional&gt;\n//   or\n//                                 UniversalPrinter&lt;absl::optional&gt;\n//                                 specializations.\n//   GTEST_INTERNAL_HAS_STRING_VIEW - for enabling Matcher&lt;std::string_view&gt; or\n//                                    Matcher&lt;absl::string_view&gt;\n//                                    specializations.\n//   GTEST_INTERNAL_HAS_VARIANT - for enabling UniversalPrinter&lt;std::variant&gt; or\n//                                UniversalPrinter&lt;absl::variant&gt;\n//                                specializations.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using\n//                     1) the RE2 syntax on all platforms when built with RE2\n//                        and Abseil as dependencies\n//                     2) the POSIX Extended Regular Expression syntax on\n//                        UNIX-like platforms,\n//                     3) A reduced regular exception syntax on other platforms,\n//                        including Windows.\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   TimeInMillis   - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an int32_t environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n//\n// Deprecation warnings:\n//   GTEST_INTERNAL_DEPRECATED(message) - attribute marking a function as\n//                                        deprecated; calling a marked function\n//                                        should generate a compiler warning\n\n#include &lt;ctype.h&gt;   // for isspace, etc\n#include &lt;stddef.h&gt;  // for ptrdiff_t\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cerrno&gt;\n// #include &lt;condition_variable&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n// #include &lt;mutex&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#ifndef _WIN32_WCE\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n#include &lt;AvailabilityMacros.h&gt;\n#include &lt;TargetConditionals.h&gt;\n#endif\n\n#include &quot;gtest/internal/custom/gtest-port.h&quot;\n#include &quot;gtest/internal/gtest-port-arch.h&quot;\n\n#if GTEST_HAS_ABSL\n#include &quot;absl/flags/declare.h&quot;\n#include &quot;absl/flags/flag.h&quot;\n#include &quot;absl/flags/reflection.h&quot;\n#endif\n\n#if !defined(GTEST_DEV_EMAIL_)\n#define GTEST_DEV_EMAIL_ &quot;googletestframework@@googlegroups.com&quot;\n#define GTEST_FLAG_PREFIX_ &quot;gtest_&quot;\n#define GTEST_FLAG_PREFIX_DASH_ &quot;gtest-&quot;\n#define GTEST_FLAG_PREFIX_UPPER_ &quot;GTEST_&quot;\n#define GTEST_NAME_ &quot;Google Test&quot;\n#define GTEST_PROJECT_URL_ &quot;https://github.com/google/googletest/&quot;\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n#define GTEST_INIT_GOOGLE_TEST_NAME_ &quot;testing::InitGoogleTest&quot;\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n#define GTEST_GCC_VER_ \\\n  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if defined(_MSC_VER)\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n  __pragma(warning(push)) __pragma(warning(disable : warnings))\n#define GTEST_DISABLE_MSC_WARNINGS_POP_() __pragma(warning(pop))\n#else\n// Not all compilers are MSVC\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n#define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Clang on Windows does not understand MSVC&#x27;s pragma warning.\n// We need clang-specific way to disable function deprecation warning.\n#ifdef __clang__\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_()                            \\\n  _Pragma(&quot;clang diagnostic push&quot;)                                      \\\n      _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-declarations\\&quot;&quot;) \\\n          _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-implementations\\&quot;&quot;)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() _Pragma(&quot;clang diagnostic pop&quot;)\n#else\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n#if !GTEST_OS_WINDOWS_MOBILE\n#include &lt;direct.h&gt;\n#include &lt;io.h&gt;\n#endif\n// In order to avoid having to include &lt;windows.h&gt;, use forward declaration\n#if GTEST_OS_WINDOWS_MINGW &amp;&amp; !defined(__MINGW64_VERSION_MAJOR)\n// MinGW defined _CRITICAL_SECTION and _RTL_CRITICAL_SECTION as two\n// separate (equivalent) structs, instead of using typedef\ntypedef struct _CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#else\n// Assume CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\ntypedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#endif\n#elif GTEST_OS_XTENSA\n#include &lt;unistd.h&gt;\n// Xtensa toolchains define strcasecmp in the string.h header instead of\n// strings.h. string.h is already included.\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n#include &lt;strings.h&gt;\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#include &lt;android/api-level.h&gt;  // NOLINT\n#endif\n\n// Defines this to true if and only if Google Test can use POSIX regular\n// expressions.\n#ifndef GTEST_HAS_POSIX_RE\n#if GTEST_OS_LINUX_ANDROID\n// On Android, &lt;regex.h&gt; is only available starting with Gingerbread.\n#define GTEST_HAS_POSIX_RE (__ANDROID_API__ &gt;= 9)\n#else\n#define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_XTENSA)\n#endif\n#endif\n\n// Select the regular expression implementation.\n#if GTEST_HAS_ABSL\n// When using Abseil, RE2 is required.\n#include &quot;absl/strings/string_view.h&quot;\n#include &quot;re2/re2.h&quot;\n#define GTEST_USES_RE2 1\n#elif GTEST_HAS_POSIX_RE\n#include &lt;regex.h&gt;  // NOLINT\n#define GTEST_USES_POSIX_RE 1\n#else\n// Use our own simple regex implementation.\n#define GTEST_USES_SIMPLE_RE 1\n#endif\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn&#x27;t tell us whether exceptions are enabled, so we need\n// to figure it out.\n#if defined(_MSC_VER) &amp;&amp; defined(_CPPUNWIND)\n// MSVC defines _CPPUNWIND to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__BORLANDC__)\n// C++Builder&#x27;s implementation of the STL uses the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we&#x27;ll do the same.\n// Assumes that exceptions are enabled by default.\n#ifndef _HAS_EXCEPTIONS\n#define _HAS_EXCEPTIONS 1\n#endif  // _HAS_EXCEPTIONS\n#define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n#elif defined(__clang__)\n// clang defines __EXCEPTIONS if and only if exceptions are enabled before clang\n// 220714, but if and only if cleanups are enabled after that. In Obj-C++ files,\n// there can be cleanups for ObjC exceptions which also need cleanups, even if\n// C++ exceptions are disabled. clang has __has_feature(cxx_exceptions) which\n// checks for C++ exceptions starting at clang r206352, but which checked for\n// cleanups prior to that. To reliably check for C++ exception availability with\n// clang, check for\n// __EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions).\n#define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions))\n#elif defined(__GNUC__) &amp;&amp; __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__IBMCPP__) &amp;&amp; __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#define GTEST_HAS_EXCEPTIONS 1\n#else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#define GTEST_HAS_EXCEPTIONS 0\n#endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn&#x27;t tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// Cygwin 1.7 and below doesn&#x27;t support ::std::wstring.\n// Solaris&#x27; libc++ doesn&#x27;t support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n#define GTEST_HAS_STD_WSTRING                                         \\\n  (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     GTEST_OS_HAIKU || GTEST_OS_ESP32 || GTEST_OS_ESP8266 || GTEST_OS_XTENSA))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn&#x27;t tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n#ifdef _MSC_VER\n\n#ifdef _CPPRTTI  // MSVC defines this macro if and only if RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI if and only if RTTI is\n// enabled.\n#elif defined(__GNUC__)\n\n#ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#if GTEST_OS_LINUX_ANDROID &amp;&amp; defined(_STLPORT_MAJOR) &amp;&amp; !defined(__EXCEPTIONS)\n#define GTEST_HAS_RTTI 0\n#else\n#define GTEST_HAS_RTTI 1\n#endif  // GTEST_OS_LINUX_ANDROID &amp;&amp; __STLPORT_MAJOR &amp;&amp; !__EXCEPTIONS\n#else\n#define GTEST_HAS_RTTI 0\n#endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n#elif defined(__clang__)\n\n#define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n#elif defined(__IBMCPP__) &amp;&amp; (__IBMCPP__ &gt;= 900)\n\n#ifdef __RTTI_ALL__\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n#else\n\n// For all other compilers, we assume RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n\n#endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It&#x27;s this header&#x27;s responsibility to #include &lt;typeinfo&gt; when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n#include &lt;typeinfo&gt;\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn&#x27;t tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n#define GTEST_HAS_PTHREAD                                                      \\\n  (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX || GTEST_OS_QNX ||          \\\n   GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD || GTEST_OS_FUCHSIA || \\\n   GTEST_OS_DRAGONFLY || GTEST_OS_GNU_KFREEBSD || GTEST_OS_OPENBSD ||          \\\n   GTEST_OS_HAIKU || GTEST_OS_GNU_HURD)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include &lt;pthread.h&gt; when GTEST_HAS_PTHREAD is\n// true.\n#include &lt;pthread.h&gt;  // NOLINT\n\n// For timespec and nanosleep, used below.\n#include &lt;time.h&gt;  // NOLINT\n#endif\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if GTEST_OS_LINUX &amp;&amp; !defined(__ia64__)\n#if GTEST_OS_LINUX_ANDROID\n// On Android, clone() became available at different API levels for each 32-bit\n// architecture.\n#if defined(__LP64__) || (defined(__arm__) &amp;&amp; __ANDROID_API__ &gt;= 9) || \\\n    (defined(__mips__) &amp;&amp; __ANDROID_API__ &gt;= 12) ||                    \\\n    (defined(__i386__) &amp;&amp; __ANDROID_API__ &gt;= 17)\n#define GTEST_HAS_CLONE 1\n#else\n#define GTEST_HAS_CLONE 0\n#endif\n#else\n#define GTEST_HAS_CLONE 1\n#endif\n#else\n#define GTEST_HAS_CLONE 0\n#endif  // GTEST_OS_LINUX &amp;&amp; !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || \\\n    GTEST_OS_WINDOWS_RT || GTEST_OS_ESP8266 || GTEST_OS_XTENSA\n#define GTEST_HAS_STREAM_REDIRECTION 0\n#else\n#define GTEST_HAS_STREAM_REDIRECTION 1\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS ||             \\\n     (GTEST_OS_MAC &amp;&amp; !GTEST_OS_IOS) ||                                   \\\n     (GTEST_OS_WINDOWS_DESKTOP &amp;&amp; _MSC_VER) || GTEST_OS_WINDOWS_MINGW ||  \\\n     GTEST_OS_AIX || GTEST_OS_HPUX || GTEST_OS_OPENBSD || GTEST_OS_QNX || \\\n     GTEST_OS_FREEBSD || GTEST_OS_NETBSD || GTEST_OS_FUCHSIA ||           \\\n     GTEST_OS_DRAGONFLY || GTEST_OS_GNU_KFREEBSD || GTEST_OS_HAIKU ||     \\\n     GTEST_OS_GNU_HURD)\n#define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need &lt;typeinfo&gt; and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || defined(_MSC_VER) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n#define GTEST_HAS_TYPED_TEST 1\n#define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n  (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_AIX || GTEST_OS_OS2)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX || GTEST_OS_GNU_KFREEBSD || GTEST_OS_DRAGONFLY || \\\n    GTEST_OS_FREEBSD || GTEST_OS_NETBSD || GTEST_OS_OPENBSD ||       \\\n    GTEST_OS_GNU_HURD\n#define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested &quot;if&quot; statements are followed by\n// an &quot;else&quot; statement and braces are not used to explicitly disambiguate the\n// &quot;else&quot; binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) &lt;&lt; &quot;Some message&quot;;\n//\n// The &quot;switch (0) case 0:&quot; idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  switch (0)                          \\\n  case 0:                             \\\n  default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c&#x27;tor and / or d&#x27;tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) &amp;&amp; !defined(COMPILER_ICC)\n#define GTEST_ATTRIBUTE_UNUSED_ __attribute__((unused))\n#elif defined(__clang__)\n#if __has_attribute(unused)\n#define GTEST_ATTRIBUTE_UNUSED_ __attribute__((unused))\n#endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n#define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// Use this annotation before a function that takes a printf format string.\n#if (defined(__GNUC__) || defined(__clang__)) &amp;&amp; !defined(COMPILER_ICC)\n#if defined(__MINGW_PRINTF_FORMAT)\n// MinGW has two different printf implementations. Ensure the format macro\n// matches the selected implementation. See\n// https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/.\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((                                             \\\n      __format__(__MINGW_PRINTF_FORMAT, string_index, first_to_check)))\n#else\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((__format__(__printf__, string_index, first_to_check)))\n#endif\n#else\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check)\n#endif\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) &amp;&amp; !defined(COMPILER_ICC)\n#define GTEST_MUST_USE_RESULT_ __attribute__((warn_unused_result))\n#else\n#define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ &amp;&amp; !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n#define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n#define GTEST_INTENTIONAL_CONST_COND_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft&#x27;s Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#define GTEST_HAS_SEH 1\n#else\n// Assume no SEH.\n#define GTEST_HAS_SEH 0\n#endif\n\n#endif  // GTEST_HAS_SEH\n\n#ifndef GTEST_IS_THREADSAFE\n\n#define GTEST_IS_THREADSAFE                                                 \\\n  (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ ||                                     \\\n   (GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT) || \\\n   GTEST_HAS_PTHREAD)\n\n#endif  // GTEST_IS_THREADSAFE\n\n#if GTEST_IS_THREADSAFE\n// Some platforms don&#x27;t support including these threading related headers.\n#include &lt;condition_variable&gt;  // NOLINT\n#include &lt;mutex&gt;               // NOLINT\n#endif                         // GTEST_IS_THREADSAFE\n\n// GTEST_API_ qualifies all symbols that must be exported. The definitions below\n// are guarded by #ifndef to give embedders a chance to define GTEST_API_ in\n// gtest/internal/custom/gtest-port.h\n#ifndef GTEST_API_\n\n#ifdef _MSC_VER\n#if GTEST_LINKED_AS_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllimport)\n#elif GTEST_CREATE_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllexport)\n#endif\n#elif __GNUC__ &gt;= 4 || defined(__clang__)\n#define GTEST_API_ __attribute__((visibility(&quot;default&quot;)))\n#endif  // _MSC_VER\n\n#endif  // GTEST_API_\n\n#ifndef GTEST_API_\n#define GTEST_API_\n#endif  // GTEST_API_\n\n#ifndef GTEST_DEFAULT_DEATH_TEST_STYLE\n#define GTEST_DEFAULT_DEATH_TEST_STYLE &quot;fast&quot;\n#endif  // GTEST_DEFAULT_DEATH_TEST_STYLE\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n#define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n#define GTEST_NO_INLINE_\n#endif\n\n#if defined(__clang__)\n// Nested ifs to avoid triggering MSVC warning.\n#if __has_attribute(disable_tail_calls)\n// Ask the compiler not to perform tail call optimization inside\n// the marked function.\n#define GTEST_NO_TAIL_CALL_ __attribute__((disable_tail_calls))\n#endif\n#elif __GNUC__\n#define GTEST_NO_TAIL_CALL_ \\\n  __attribute__((optimize(&quot;no-optimize-sibling-calls&quot;)))\n#else\n#define GTEST_NO_TAIL_CALL_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if !defined(GTEST_HAS_CXXABI_H_)\n#if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) &amp;&amp; !defined(_MSC_VER))\n#define GTEST_HAS_CXXABI_H_ 1\n#else\n#define GTEST_HAS_CXXABI_H_ 0\n#endif\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n#if __has_feature(memory_sanitizer)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ __attribute__((no_sanitize_memory))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __has_feature(memory_sanitizer)\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n#if __has_feature(address_sanitizer)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n  __attribute__((no_sanitize_address))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __has_feature(address_sanitizer)\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable HWAddressSanitizer instrumentation.\n#if defined(__clang__)\n#if __has_feature(hwaddress_sanitizer)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ \\\n  __attribute__((no_sanitize(&quot;hwaddress&quot;)))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n#endif  // __has_feature(hwaddress_sanitizer)\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n#if __has_feature(thread_sanitizer)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ __attribute__((no_sanitize_thread))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __has_feature(thread_sanitizer)\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n// Legacy imports for backwards compatibility.\n// New code should use std:: names directly.\nusing std::get;\nusing std::make_tuple;\nusing std::tuple;\nusing std::tuple_element;\nusing std::tuple_size;\n\nnamespace internal {\n\n// A secret type that Google Test users don&#x27;t know about.  It has no\n// definition on purpose.  Therefore it&#x27;s impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns &#x27;condition&#x27;.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines RE.\n\n#if GTEST_USES_RE2\n\n// This is almost `using RE = ::RE2`, except it is copy-constructible, and it\n// needs to disambiguate the `std::string`, `absl::string_view`, and `const\n// char*` constructors.\nclass GTEST_API_ RE {\n public:\n  RE(absl::string_view regex) : regex_(regex) {}                  // NOLINT\n  RE(const char* regex) : RE(absl::string_view(regex)) {}         // NOLINT\n  RE(const std::string&amp; regex) : RE(absl::string_view(regex)) {}  // NOLINT\n  RE(const RE&amp; other) : RE(other.pattern()) {}\n\n  const std::string&amp; pattern() const { return regex_.pattern(); }\n\n  static bool FullMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::FullMatch(str, re.regex_);\n  }\n  static bool PartialMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::PartialMatch(str, re.regex_);\n  }\n\n private:\n  RE2 regex_;\n};\n\n#elif GTEST_USES_POSIX_RE || GTEST_USES_SIMPLE_RE\n\n// A simple C++ wrapper for &lt;regex.h&gt;.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE&amp; other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string&amp; regex) { Init(regex.c_str()); }  // NOLINT\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true if and only if regular expression re\n  // matches the entire str.\n  // PartialMatch(str, re) returns true if and only if regular expression re\n  // matches a substring of str (including str itself).\n  static bool FullMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n  static bool FullMatch(const char* str, const RE&amp; re);\n  static bool PartialMatch(const char* str, const RE&amp; re);\n\n private:\n  void Init(const char* regex);\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n};\n\n#endif  // ::testing::internal::RE implementation\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity { GTEST_INFO, GTEST_WARNING, GTEST_ERROR, GTEST_FATAL };\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream&amp; GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTestLog(const GTestLog&amp;) = delete;\n  GTestLog&amp; operator=(const GTestLog&amp;) = delete;\n};\n\n#if !defined(GTEST_LOG_)\n\n#define GTEST_LOG_(severity)                                           \\\n  ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                __FILE__, __LINE__)                    \\\n      .GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(nullptr); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsis:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) &lt;&lt; &quot;Additional message&quot;;\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n#define GTEST_CHECK_(condition)               \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_               \\\n  if (::testing::internal::IsTrue(condition)) \\\n    ;                                         \\\n  else                                        \\\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Condition &quot; #condition &quot; failed. &quot;\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn&#x27;t expand to a balanced &#x27;if&#x27; statement, so enclose the macro\n// in {} if you need to use it as the only statement in an &#x27;if&#x27;\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call))    \\\n  GTEST_LOG_(FATAL) &lt;&lt; #posix_call &lt;&lt; &quot;failed with error &quot; &lt;&lt; gtest_error\n\n// Transforms &quot;T&quot; into &quot;const T&amp;&quot; according to standard reference collapsing\n// rules (this is only needed as a backport for C++98 compilers that do not\n// support reference collapsing). Specifically, it transforms:\n//\n//   char         ==&gt; const char&amp;\n//   const char   ==&gt; const char&amp;\n//   char&amp;        ==&gt; char&amp;\n//   const char&amp;  ==&gt; const char&amp;\n//\n// Note that the non-const reference will not have &quot;const&quot; added. This is\n// standard, and necessary so that &quot;T&quot; can always bind to &quot;const T&amp;&quot;.\ntemplate &lt;typename T&gt;\nstruct ConstRef {\n  typedef const T&amp; type;\n};\ntemplate &lt;typename T&gt;\nstruct ConstRef&lt;T&amp;&gt; {\n  typedef T&amp; type;\n};\n\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n  typename ::testing::internal::ConstRef&lt;T&gt;::type\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertible to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_&lt;ToType&gt;(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate &lt;typename To&gt;\ninline To ImplicitCast_(To x) {\n  return x;\n}\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it&#x27;s fine to use ImplicitCast_&lt;&gt;, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast&lt;&gt; isn&#x27;t safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast&lt;&gt; to double-check the downcast is legal (we die\n// if it&#x27;s not).  In normal mode, we do the efficient static_cast&lt;&gt;\n// instead.  Thus, it&#x27;s important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast&lt;&gt;.\n// In particular, you SHOULDN&#x27;T be using dynamic_cast&lt;&gt; in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast&lt;Subclass1&gt;(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast&lt;Subclass2&gt;(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate &lt;typename To, typename From&gt;  // use like this: DownCast_&lt;T*&gt;(foo);\ninline To DownCast_(From* f) {         // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n    GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = nullptr;\n    ::testing::internal::ImplicitCast_&lt;From*&gt;(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == nullptr || dynamic_cast&lt;To&gt;(f) != nullptr);\n#endif\n  return static_cast&lt;To&gt;(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate &lt;class Derived, class Base&gt;\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast&lt;Derived*&gt;(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast&lt;Derived*&gt;(base);  // NOLINT\n#else\n  return static_cast&lt;Derived*&gt;(base);  // Poor man&#x27;s downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ std::vector&lt;std::string&gt; GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nstd::vector&lt;std::string&gt; GetInjectableArgvs();\n// Deprecated: pass the args vector by value instead.\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;* new_argvs);\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;&amp; new_argvs);\nvoid ClearInjectableArgvs();\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n\n#if GTEST_OS_WINDOWS\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including &lt;windows.h&gt; in this header file. Including &lt;windows.h&gt; is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true if and only if the handle is a valid handle object that can be\n  // closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  AutoHandle(const AutoHandle&amp;) = delete;\n  AutoHandle&amp; operator=(const AutoHandle&amp;) = delete;\n};\n#endif\n\n#if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n#else\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test&#x27;s own constructs. Do not\n// use it in user tests, either directly or indirectly.\n// TODO(b/203539622): Replace unconditionally with absl::Notification.\nclass GTEST_API_ Notification {\n public:\n  Notification() : notified_(false) {}\n  Notification(const Notification&amp;) = delete;\n  Notification&amp; operator=(const Notification&amp;) = delete;\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    std::lock_guard&lt;std::mutex&gt; lock(mu_);\n    notified_ = true;\n    cv_.notify_all();\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    std::unique_lock&lt;std::mutex&gt; lock(mu_);\n    cv_.wait(lock, [this]() { return notified_; });\n  }\n\n private:\n  std::mutex mu_;\n  std::condition_variable cv_;\n  bool notified_;\n};\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n#endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don&#x27;t want to use MinGW&#x27;s pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n#if GTEST_HAS_PTHREAD &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern &quot;C&quot; inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast&lt;ThreadWithParamBase*&gt;(thread)-&gt;Run();\n  return nullptr;\n}\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam&lt;int&gt; thread(&amp;ThreadFunc, 5, &amp;thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test&#x27;s own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&amp;thread_, nullptr, &amp;ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() override { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, nullptr));\n      finished_ = true;\n    }\n  }\n\n  void Run() override {\n    if (thread_can_start_ != nullptr) thread_can_start_-&gt;WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true if and only if we know that the thread function has\n                   // finished.\n  pthread_t thread_;  // The native thread object.\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; GTEST_HAS_PTHREAD ||\n        // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n#elif GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&amp;mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per https://blogs.msdn.microsoft.com/oldnewthing/20040223-00/?p=40503,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  GTEST_CRITICAL_SECTION* critical_section_;\n\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder&lt;T&gt;.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder&lt;T&gt; object holding a default value passed to\n  // this ThreadLocal&lt;T&gt;&#x27;s constructor and returns it.  It is the caller&#x27;s\n  // responsibility not to call this when the ThreadLocal&lt;T&gt; instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  ThreadLocalBase(const ThreadLocalBase&amp;) = delete;\n  ThreadLocalBase&amp; operator=(const ThreadLocalBase&amp;) = delete;\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable* runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {}\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param) : func_(func), param_(param) {}\n    virtual ~RunnableImpl() {}\n    virtual void Run() { func_(param_); }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    RunnableImpl(const RunnableImpl&amp;) = delete;\n    RunnableImpl&amp; operator=(const RunnableImpl&amp;) = delete;\n  };\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal&lt;int&gt; tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate &lt;typename T&gt;\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() override { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  T* GetOrCreateValue() const {\n    return static_cast&lt;ValueHolder*&gt;(\n               ThreadLocalRegistry::GetValueOnCurrentThread(this))\n        -&gt;pointer();\n  }\n\n  ThreadLocalValueHolderBase* NewValueForCurrentThread() const override {\n    return default_factory_-&gt;MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&amp;mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don&#x27;t protect writing to has_owner_ here, as it&#x27;s\n    // the caller&#x27;s responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&amp;mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ &amp;&amp; pthread_equal(owner_, pthread_self()))\n        &lt;&lt; &quot;The current thread is not holding the mutex @&quot; &lt;&lt; this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there&#x27;s no\n  // guarantee that a zero&#x27;d pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n// The initialization list here does not explicitly initialize each field,\n// instead relying on default initialization for the unspecified fields. In\n// particular, the owner_ field (a pthread_t) is not explicitly initialized.\n// This allows initialization to work whether pthread_t is a scalar or struct.\n// The flag -Wmissing-field-initializers must not be specified for this to work.\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::MutexBase mutex = {PTHREAD_MUTEX_INITIALIZER, false, 0}\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&amp;mutex_, nullptr));\n    has_owner_ = false;\n  }\n  ~Mutex() { GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&amp;mutex_)); }\n\n private:\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal&lt;T&gt;.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern &quot;C&quot; inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast&lt;ThreadLocalValueHolderBase*&gt;(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&amp;key, &amp;DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast&lt;ThreadLocalValueHolderBase*&gt;(pthread_getspecific(key_));\n    if (holder != nullptr) {\n      return CheckedDowncastToActualType&lt;ValueHolder&gt;(holder)-&gt;pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_-&gt;MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder-&gt;pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T&amp; value) : value_(value) {}\n  T* pointer() { return &amp;value_; }\n  const T* pointer() const { return &amp;value_; }\n  const T&amp; get() const { return value_; }\n  void set(const T&amp; value) { value_ = value; }\n\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n#if GTEST_OS_WINDOWS\n#define GTEST_PATH_SEP_ &quot;\\\\&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 1\n#else\n#define GTEST_PATH_SEP_ &quot;/&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 0\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#ifdef __cpp_char8_t\ninline bool IsXDigit(char8_t ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#endif\ninline bool IsXDigit(char16_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(char32_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast&lt;char&gt;(tolower(static_cast&lt;unsigned char&gt;(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast&lt;char&gt;(toupper(static_cast&lt;unsigned char&gt;(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() &amp;&amp; IsSpace(*--it)) it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n#ifdef __BORLANDC__\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n#else  // !__BORLANDC__\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_ZOS || GTEST_OS_IOS || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT || defined(ESP_PLATFORM)\ninline int DoIsATTY(int /* fd */) { return 0; }\n#else\ninline int DoIsATTY(int fd) { return _isatty(fd); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n#endif  // __BORLANDC__\n\n#if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast&lt;int&gt;(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n#else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return (_S_IFDIR &amp; st.st_mode) != 0; }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n#elif GTEST_OS_ESP8266\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) {\n  // stat function not implemented on ESP8266\n  return 0;\n}\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\ninline int IsATTY(int fd) {\n  // DoIsATTY might change errno (for example ENOTTY in case you redirect stdout\n  // to a file on Linux), which is unexpected, so save the previous value, and\n  // restore it after the call.\n  int savedErrno = errno;\n  int isAttyValue = DoIsATTY(fd);\n  errno = savedErrno;\n\n  return isAttyValue;\n}\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_DEPRECATED_PUSH_()\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren&#x27;t needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; \\\n    !GTEST_OS_WINDOWS_RT &amp;&amp; !GTEST_OS_ESP8266 &amp;&amp; !GTEST_OS_XTENSA\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n  struct wchar_codecvt : public std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; {};\n  std::wstring_convert&lt;wchar_codecvt&gt; converter;\n  std::wstring wide_path = converter.from_bytes(path);\n  std::wstring wide_mode = converter.from_bytes(mode);\n  return _wfopen(wide_path.c_str(), wide_mode.c_str());\n#else   // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n  return fopen(path, mode);\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE* FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || \\\n    GTEST_OS_WINDOWS_RT || GTEST_OS_ESP8266 || GTEST_OS_XTENSA\n  // We are on an embedded platform, which has no environment variables.\n  static_cast&lt;void&gt;(name);  // To prevent &#x27;unused argument&#x27; warning.\n  return nullptr;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != nullptr &amp;&amp; env[0] != &#x27;\\0&#x27;) ? env : nullptr;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_DEPRECATED_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\n[[noreturn]] void Abort();\n#else\n[[noreturn]] inline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC &quot;deprecates&quot; snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n#define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n  _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s\n#define GTEST_SNPRINTF_ _snprintf\n#else\n#define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The biggest signed integer type the compiler supports.\n//\n// long long is guaranteed to be at least 64-bits in C++11.\nusing BiggestInt = long long;  // NOLINT\n\n// The maximum number a BiggestInt can represent.\nconstexpr BiggestInt kMaxBiggestInt = (std::numeric_limits&lt;BiggestInt&gt;::max)();\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize&lt;4&gt;::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that&#x27;s all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate &lt;size_t size&gt;\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize&lt;N&gt; with incorrect\n  // values of N.\n  using UInt = void;\n};\n\n// The specialization for size 4.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;4&gt; {\n public:\n  using Int = std::int32_t;\n  using UInt = std::uint32_t;\n};\n\n// The specialization for size 8.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;8&gt; {\n public:\n  using Int = std::int64_t;\n  using UInt = std::uint64_t;\n};\n\n// Integer types of known sizes.\nusing TimeInMillis = int64_t;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n#define GTEST_FLAG_NAME_(name) gtest_##name\n#define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n// Pick a command line flags implementation.\n#if GTEST_HAS_ABSL\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n  ABSL_FLAG(bool, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n  ABSL_FLAG(int32_t, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n  ABSL_FLAG(std::string, GTEST_FLAG_NAME_(name), default_val, doc)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name) \\\n  ABSL_DECLARE_FLAG(bool, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_int32_(name) \\\n  ABSL_DECLARE_FLAG(int32_t, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_string_(name) \\\n  ABSL_DECLARE_FLAG(std::string, GTEST_FLAG_NAME_(name))\n\n#define GTEST_FLAG_SAVER_ ::absl::FlagSaver\n\n#define GTEST_FLAG_GET(name) ::absl::GetFlag(GTEST_FLAG(name))\n#define GTEST_FLAG_SET(name, value) \\\n  (void)(::absl::SetFlag(&amp;GTEST_FLAG(name), value))\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 0\n\n#else  // GTEST_HAS_ABSL\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc)  \\\n  namespace testing {                               \\\n  GTEST_API_ bool GTEST_FLAG(name) = (default_val); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_int32_(name, default_val, doc)         \\\n  namespace testing {                                       \\\n  GTEST_API_ std::int32_t GTEST_FLAG(name) = (default_val); \\\n  }                                                         \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_string_(name, default_val, doc)         \\\n  namespace testing {                                        \\\n  GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val); \\\n  }                                                          \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name)          \\\n  namespace testing {                      \\\n  GTEST_API_ extern bool GTEST_FLAG(name); \\\n  }                                        \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_int32_(name)                 \\\n  namespace testing {                              \\\n  GTEST_API_ extern std::int32_t GTEST_FLAG(name); \\\n  }                                                \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_string_(name)                 \\\n  namespace testing {                               \\\n  GTEST_API_ extern ::std::string GTEST_FLAG(name); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n#define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n#define GTEST_FLAG_GET(name) ::testing::GTEST_FLAG(name)\n#define GTEST_FLAG_SET(name, value) (void)(::testing::GTEST_FLAG(name) = value)\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n\n#endif  // GTEST_HAS_ABSL\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n#define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n#define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses &#x27;str&#x27; for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\nGTEST_API_ bool ParseInt32(const Message&amp; src_text, const char* str,\n                           int32_t* value);\n\n// Parses a bool/int32_t/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ int32_t Int32FromGTestEnv(const char* flag, int32_t default_val);\nstd::string OutputFlagAlsoCheckEnvVar();\nconst char* StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#if !defined(GTEST_INTERNAL_DEPRECATED)\n\n// Internal Macro to mark an API deprecated, for googletest usage only\n// Usage: class GTEST_INTERNAL_DEPRECATED(message) MyClass or\n// GTEST_INTERNAL_DEPRECATED(message) &lt;return_type&gt; myFunction(); Every usage of\n// a deprecated entity will trigger a warning when compiled with\n// `-Wdeprecated-declarations` option (clang, gcc, any __GNUC__ compiler).\n// For msvc /W3 option will need to be used\n// Note that for &#x27;other&#x27; compilers this macro evaluates to nothing to prevent\n// compilations errors.\n#if defined(_MSC_VER)\n#define GTEST_INTERNAL_DEPRECATED(message) __declspec(deprecated(message))\n#elif defined(__GNUC__)\n#define GTEST_INTERNAL_DEPRECATED(message) __attribute__((deprecated(message)))\n#else\n#define GTEST_INTERNAL_DEPRECATED(message)\n#endif\n\n#endif  // !defined(GTEST_INTERNAL_DEPRECATED)\n\n#if GTEST_HAS_ABSL\n// Always use absl::any for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &quot;absl/types/any.h&quot;\nnamespace testing {\nnamespace internal {\nusing Any = ::absl::any;\n}  // namespace internal\n}  // namespace testing\n#else\n#ifdef __has_include\n#if __has_include(&lt;any&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n// Otherwise for C++17 and higher use std::any for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &lt;any&gt;\nnamespace testing {\nnamespace internal {\nusing Any = ::std::any;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::any is not\n// supported.\n#endif  // __has_include(&lt;any&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n#endif  // __has_include\n#endif  // GTEST_HAS_ABSL\n\n#if GTEST_HAS_ABSL\n// Always use absl::optional for UniversalPrinter&lt;&gt; specializations if\n// googletest is built with absl support.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &quot;absl/types/optional.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::absl::optional&lt;T&gt;;\ninline ::absl::nullopt_t Nullopt() { return ::absl::nullopt; }\n}  // namespace internal\n}  // namespace testing\n#else\n#ifdef __has_include\n#if __has_include(&lt;optional&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n// Otherwise for C++17 and higher use std::optional for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &lt;optional&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::std::optional&lt;T&gt;;\ninline ::std::nullopt_t Nullopt() { return ::std::nullopt; }\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::optional is not\n// supported.\n#endif  // __has_include(&lt;optional&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n#endif  // __has_include\n#endif  // GTEST_HAS_ABSL\n\n#if GTEST_HAS_ABSL\n// Always use absl::string_view for Matcher&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &quot;absl/strings/string_view.h&quot;\nnamespace testing {\nnamespace internal {\nusing StringView = ::absl::string_view;\n}  // namespace internal\n}  // namespace testing\n#else\n#ifdef __has_include\n#if __has_include(&lt;string_view&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n// Otherwise for C++17 and higher use std::string_view for Matcher&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &lt;string_view&gt;\nnamespace testing {\nnamespace internal {\nusing StringView = ::std::string_view;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::string_view is not\n// supported.\n#endif  // __has_include(&lt;string_view&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n#endif  // __has_include\n#endif  // GTEST_HAS_ABSL\n\n#if GTEST_HAS_ABSL\n// Always use absl::variant for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &quot;absl/types/variant.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::absl::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n#else\n#ifdef __has_include\n#if __has_include(&lt;variant&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n// Otherwise for C++17 and higher use std::variant for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &lt;variant&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::std::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::variant is not supported.\n#endif  // __has_include(&lt;variant&gt;) &amp;&amp; __cplusplus &gt;= 201703L\n#endif  // __has_include\n#endif  // GTEST_HAS_ABSL\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Type utilities needed for implementing typed and type-parameterized\n// tests.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using\n// libstdc++ (which is where cxxabi.h comes from).\n#if GTEST_HAS_CXXABI_H_\n#include &lt;cxxabi.h&gt;\n#elif defined(__HP_aCC)\n#include &lt;acxx_demangle.h&gt;\n#endif  // GTEST_HASH_CXXABI_H_\n\nnamespace testing {\nnamespace internal {\n\n// Canonicalizes a given name with respect to the Standard C++ Library.\n// This handles removing the inline namespace within `std` that is\n// used by various standard libraries (e.g., `std::__1`).  Names outside\n// of namespace std are returned unmodified.\ninline std::string CanonicalizeForStdLibVersioning(std::string s) {\n  static const char prefix[] = &quot;std::__&quot;;\n  if (s.compare(0, strlen(prefix), prefix) == 0) {\n    std::string::size_type end = s.find(&quot;::&quot;, strlen(prefix));\n    if (end != s.npos) {\n      // Erase everything between the initial `std` and the second `::`.\n      s.erase(strlen(&quot;std&quot;), end - strlen(&quot;std&quot;));\n    }\n  }\n  return s;\n}\n\n#if GTEST_HAS_RTTI\n// GetTypeName(const std::type_info&amp;) returns a human-readable name of type T.\ninline std::string GetTypeName(const std::type_info&amp; type) {\n  const char* const name = type.name();\n#if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)\n  int status = 0;\n  // gcc&#x27;s implementation of typeid(T).name() mangles the type name,\n  // so we have to demangle it.\n#if GTEST_HAS_CXXABI_H_\n  using abi::__cxa_demangle;\n#endif  // GTEST_HAS_CXXABI_H_\n  char* const readable_name = __cxa_demangle(name, nullptr, nullptr, &amp;status);\n  const std::string name_str(status == 0 ? readable_name : name);\n  free(readable_name);\n  return CanonicalizeForStdLibVersioning(name_str);\n#else\n  return name;\n#endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC\n}\n#endif  // GTEST_HAS_RTTI\n\n// GetTypeName&lt;T&gt;() returns a human-readable name of type T if and only if\n// RTTI is enabled, otherwise it returns a dummy type name.\n// NB: This function is also used in Google Mock, so don&#x27;t move it inside of\n// the typed-test-only section below.\ntemplate &lt;typename T&gt;\nstd::string GetTypeName() {\n#if GTEST_HAS_RTTI\n  return GetTypeName(typeid(T));\n#else\n  return &quot;&lt;type&gt;&quot;;\n#endif  // GTEST_HAS_RTTI\n}\n\n// A unique type indicating an empty node\nstruct None {};\n\n#define GTEST_TEMPLATE_ \\\n  template &lt;typename T&gt; \\\n  class\n\n// The template &quot;selector&quot; struct TemplateSel&lt;Tmpl&gt; is used to\n// represent Tmpl, which must be a class template with one type\n// parameter, as a type.  TemplateSel&lt;Tmpl&gt;::Bind&lt;T&gt;::type is defined\n// as the type Tmpl&lt;T&gt;.  This allows us to actually instantiate the\n// template &quot;selected&quot; by TemplateSel&lt;Tmpl&gt;.\n//\n// This trick is necessary for simulating typedef for class templates,\n// which C++ doesn&#x27;t support directly.\ntemplate &lt;GTEST_TEMPLATE_ Tmpl&gt;\nstruct TemplateSel {\n  template &lt;typename T&gt;\n  struct Bind {\n    typedef Tmpl&lt;T&gt; type;\n  };\n};\n\n#define GTEST_BIND_(TmplSel, T) TmplSel::template Bind&lt;T&gt;::type\n\ntemplate &lt;GTEST_TEMPLATE_ Head_, GTEST_TEMPLATE_... Tail_&gt;\nstruct Templates {\n  using Head = TemplateSel&lt;Head_&gt;;\n  using Tail = Templates&lt;Tail_...&gt;;\n};\n\ntemplate &lt;GTEST_TEMPLATE_ Head_&gt;\nstruct Templates&lt;Head_&gt; {\n  using Head = TemplateSel&lt;Head_&gt;;\n  using Tail = None;\n};\n\n// Tuple-like type lists\ntemplate &lt;typename Head_, typename... Tail_&gt;\nstruct Types {\n  using Head = Head_;\n  using Tail = Types&lt;Tail_...&gt;;\n};\n\ntemplate &lt;typename Head_&gt;\nstruct Types&lt;Head_&gt; {\n  using Head = Head_;\n  using Tail = None;\n};\n\n// Helper metafunctions to tell apart a single type from types\n// generated by ::testing::Types\ntemplate &lt;typename... Ts&gt;\nstruct ProxyTypeList {\n  using type = Types&lt;Ts...&gt;;\n};\n\ntemplate &lt;typename&gt;\nstruct is_proxy_type_list : std::false_type {};\n\ntemplate &lt;typename... Ts&gt;\nstruct is_proxy_type_list&lt;ProxyTypeList&lt;Ts...&gt;&gt; : std::true_type {};\n\n// Generator which conditionally creates type lists.\n// It recognizes if a requested type list should be created\n// and prevents creating a new type list nested within another one.\ntemplate &lt;typename T&gt;\nstruct GenerateTypeList {\n private:\n  using proxy = typename std::conditional&lt;is_proxy_type_list&lt;T&gt;::value, T,\n                                          ProxyTypeList&lt;T&gt;&gt;::type;\n\n public:\n  using type = typename proxy::type;\n};\n\n}  // namespace internal\n\ntemplate &lt;typename... Ts&gt;\nusing Types = internal::ProxyTypeList&lt;Ts...&gt;;\n\n}  // namespace testing\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This file defines the AssertionResult type.\n\n#include &quot;gtest/gtest-assertion-result.h&quot;\n\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\n#include &quot;gtest/gtest-message.h&quot;\n\nnamespace testing {\n\n// AssertionResult constructors.\n// Used in EXPECT_TRUE/FALSE(assertion_result).\nAssertionResult::AssertionResult(const AssertionResult&amp; other)\n    : success_(other.success_),\n      message_(other.message_.get() != nullptr\n                   ? new ::std::string(*other.message_)\n                   : static_cast&lt; ::std::string*&gt;(nullptr)) {}\n\n// Swaps two AssertionResults.\nvoid AssertionResult::swap(AssertionResult&amp; other) {\n  using std::swap;\n  swap(success_, other.success_);\n  swap(message_, other.message_);\n}\n\n// Returns the assertion&#x27;s negation. Used with EXPECT/ASSERT_FALSE.\nAssertionResult AssertionResult::operator!() const {\n  AssertionResult negation(!success_);\n  if (message_.get() != nullptr) negation &lt;&lt; *message_;\n  return negation;\n}\n\n// Makes a successful assertion result.\nAssertionResult AssertionSuccess() { return AssertionResult(true); }\n\n// Makes a failed assertion result.\nAssertionResult AssertionFailure() { return AssertionResult(false); }\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() &lt;&lt; message.\nAssertionResult AssertionFailure(const Message&amp; message) {\n  return AssertionFailure() &lt;&lt; message;\n}\n\n}  // namespace testing\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n//\n// This file implements death tests.\n\n#include &quot;gtest/gtest-death-test.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;utility&gt;\n\n#include &quot;gtest/internal/custom/gtest.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#if GTEST_HAS_DEATH_TEST\n\n#if GTEST_OS_MAC\n#include &lt;crt_externs.h&gt;\n#endif  // GTEST_OS_MAC\n\n#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;limits.h&gt;\n\n#if GTEST_OS_LINUX\n#include &lt;signal.h&gt;\n#endif  // GTEST_OS_LINUX\n\n#include &lt;stdarg.h&gt;\n\n#if GTEST_OS_WINDOWS\n#include &lt;windows.h&gt;\n#else\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/wait.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_QNX\n#include &lt;spawn.h&gt;\n#endif  // GTEST_OS_QNX\n\n#if GTEST_OS_FUCHSIA\n#include &lt;lib/fdio/fd.h&gt;\n#include &lt;lib/fdio/io.h&gt;\n#include &lt;lib/fdio/spawn.h&gt;\n#include &lt;lib/zx/channel.h&gt;\n#include &lt;lib/zx/port.h&gt;\n#include &lt;lib/zx/process.h&gt;\n#include &lt;lib/zx/socket.h&gt;\n#include &lt;zircon/processargs.h&gt;\n#include &lt;zircon/syscalls.h&gt;\n#include &lt;zircon/syscalls/policy.h&gt;\n#include &lt;zircon/syscalls/port.h&gt;\n#endif  // GTEST_OS_FUCHSIA\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;src/gtest-internal-inl.h&quot;\n\nnamespace testing {\n\n// Constants.\n\n// The default death test style.\n//\n// This is defined in internal/gtest-port.h as &quot;fast&quot;, but can be overridden by\n// a definition in internal/custom/gtest-port.h. The recommended value, which is\n// used internally at Google, is &quot;threadsafe&quot;.\nstatic const char kDefaultDeathTestStyle[] = GTEST_DEFAULT_DEATH_TEST_STYLE;\n\n}  // namespace testing\n\nGTEST_DEFINE_string_(\n    death_test_style,\n    testing::internal::StringFromGTestEnv(&quot;death_test_style&quot;,\n                                          testing::kDefaultDeathTestStyle),\n    &quot;Indicates how to run a death test in a forked child process: &quot;\n    &quot;\\&quot;threadsafe\\&quot; (child process re-executes the test binary &quot;\n    &quot;from the beginning, running only the specific death test) or &quot;\n    &quot;\\&quot;fast\\&quot; (child process runs the death test immediately &quot;\n    &quot;after forking).&quot;);\n\nGTEST_DEFINE_bool_(\n    death_test_use_fork,\n    testing::internal::BoolFromGTestEnv(&quot;death_test_use_fork&quot;, false),\n    &quot;Instructs to use fork()/_exit() instead of clone() in death tests. &quot;\n    &quot;Ignored and always uses fork() on POSIX systems where clone() is not &quot;\n    &quot;implemented. Useful when running under valgrind or similar tools if &quot;\n    &quot;those do not support clone(). Valgrind 3.3.1 will just fail if &quot;\n    &quot;it sees an unsupported combination of clone() flags. &quot;\n    &quot;It is not recommended to use this flag w/o valgrind though it will &quot;\n    &quot;work in 99% of the cases. Once valgrind is fixed, this flag will &quot;\n    &quot;most likely be removed.&quot;);\n\nGTEST_DEFINE_string_(\n    internal_run_death_test, &quot;&quot;,\n    &quot;Indicates the file, line number, temporal index of &quot;\n    &quot;the single death test to run, and a file descriptor to &quot;\n    &quot;which a success code may be sent, all separated by &quot;\n    &quot;the &#x27;|&#x27; characters.  This flag is specified if and only if the &quot;\n    &quot;current process is a sub-process launched for running a thread-safe &quot;\n    &quot;death test.  FOR INTERNAL USE ONLY.&quot;);\n\nnamespace testing {\n\n#if GTEST_HAS_DEATH_TEST\n\nnamespace internal {\n\n// Valid only for fast death tests. Indicates the code is running in the\n// child process of a fast style death test.\n#if !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\nstatic bool g_in_fast_death_test_child = false;\n#endif\n\n// Returns a Boolean value indicating whether the caller is currently\n// executing in the context of the death test child process.  Tools such as\n// Valgrind heap checkers may need this to modify their behavior in death\n// tests.  IMPORTANT: This is an internal utility.  Using it may break the\n// implementation of death tests.  User code MUST NOT use it.\nbool InDeathTestChild() {\n#if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  // On Windows and Fuchsia, death tests are thread-safe regardless of the value\n  // of the death_test_style flag.\n  return !GTEST_FLAG_GET(internal_run_death_test).empty();\n\n#else\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot;)\n    return !GTEST_FLAG_GET(internal_run_death_test).empty();\n  else\n    return g_in_fast_death_test_child;\n#endif\n}\n\n}  // namespace internal\n\n// ExitedWithCode constructor.\nExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) {}\n\n// ExitedWithCode function-call operator.\nbool ExitedWithCode::operator()(int exit_status) const {\n#if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  return exit_status == exit_code_;\n\n#else\n\n  return WIFEXITED(exit_status) &amp;&amp; WEXITSTATUS(exit_status) == exit_code_;\n\n#endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n}\n\n#if !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n// KilledBySignal constructor.\nKilledBySignal::KilledBySignal(int signum) : signum_(signum) {}\n\n// KilledBySignal function-call operator.\nbool KilledBySignal::operator()(int exit_status) const {\n#if defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  {\n    bool result;\n    if (GTEST_KILLED_BY_SIGNAL_OVERRIDE_(signum_, exit_status, &amp;result)) {\n      return result;\n    }\n  }\n#endif  // defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  return WIFSIGNALED(exit_status) &amp;&amp; WTERMSIG(exit_status) == signum_;\n}\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n\nnamespace internal {\n\n// Utilities needed for death tests.\n\n// Generates a textual description of a given exit code, in the format\n// specified by wait(2).\nstatic std::string ExitSummary(int exit_code) {\n  Message m;\n\n#if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  m &lt;&lt; &quot;Exited with exit status &quot; &lt;&lt; exit_code;\n\n#else\n\n  if (WIFEXITED(exit_code)) {\n    m &lt;&lt; &quot;Exited with exit status &quot; &lt;&lt; WEXITSTATUS(exit_code);\n  } else if (WIFSIGNALED(exit_code)) {\n    m &lt;&lt; &quot;Terminated by signal &quot; &lt;&lt; WTERMSIG(exit_code);\n  }\n#ifdef WCOREDUMP\n  if (WCOREDUMP(exit_code)) {\n    m &lt;&lt; &quot; (core dumped)&quot;;\n  }\n#endif\n#endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  return m.GetString();\n}\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nbool ExitedUnsuccessfully(int exit_status) {\n  return !ExitedWithCode(0)(exit_status);\n}\n\n#if !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n// Generates a textual failure message when a death test finds more than\n// one thread running, or cannot determine the number of threads, prior\n// to executing the given statement.  It is the responsibility of the\n// caller not to pass a thread_count of 1.\nstatic std::string DeathTestThreadWarning(size_t thread_count) {\n  Message msg;\n  msg &lt;&lt; &quot;Death tests use fork(), which is unsafe particularly&quot;\n      &lt;&lt; &quot; in a threaded context. For this test, &quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot; &quot;;\n  if (thread_count == 0) {\n    msg &lt;&lt; &quot;couldn&#x27;t detect the number of threads.&quot;;\n  } else {\n    msg &lt;&lt; &quot;detected &quot; &lt;&lt; thread_count &lt;&lt; &quot; threads.&quot;;\n  }\n  msg &lt;&lt; &quot; See &quot;\n         &quot;https://github.com/google/googletest/blob/master/docs/&quot;\n         &quot;advanced.md#death-tests-and-threads&quot;\n      &lt;&lt; &quot; for more explanation and suggested solutions, especially if&quot;\n      &lt;&lt; &quot; this is the last message you see before your test times out.&quot;;\n  return msg.GetString();\n}\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n\n// Flag characters for reporting a death test that did not die.\nstatic const char kDeathTestLived = &#x27;L&#x27;;\nstatic const char kDeathTestReturned = &#x27;R&#x27;;\nstatic const char kDeathTestThrew = &#x27;T&#x27;;\nstatic const char kDeathTestInternalError = &#x27;I&#x27;;\n\n#if GTEST_OS_FUCHSIA\n\n// File descriptor used for the pipe in the child process.\nstatic const int kFuchsiaReadPipeFd = 3;\n\n#endif\n\n// An enumeration describing all of the possible ways that a death test can\n// conclude.  DIED means that the process died while executing the test\n// code; LIVED means that process lived beyond the end of the test code;\n// RETURNED means that the test statement attempted to execute a return\n// statement, which is not allowed; THREW means that the test statement\n// returned control by throwing an exception.  IN_PROGRESS means the test\n// has not yet concluded.\nenum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW };\n\n// Routine for aborting the program which is safe to call from an\n// exec-style death test child process, in which case the error\n// message is propagated back to the parent process.  Otherwise, the\n// message is simply printed to stderr.  In either case, the program\n// then exits with status 1.\nstatic void DeathTestAbort(const std::string&amp; message) {\n  // On a POSIX system, this function may be called from a threadsafe-style\n  // death test child process, which operates on a very small stack.  Use\n  // the heap for any additional non-minuscule memory requirements.\n  const InternalRunDeathTestFlag* const flag =\n      GetUnitTestImpl()-&gt;internal_run_death_test_flag();\n  if (flag != nullptr) {\n    FILE* parent = posix::FDOpen(flag-&gt;write_fd(), &quot;w&quot;);\n    fputc(kDeathTestInternalError, parent);\n    fprintf(parent, &quot;%s&quot;, message.c_str());\n    fflush(parent);\n    _exit(1);\n  } else {\n    fprintf(stderr, &quot;%s&quot;, message.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n}\n\n// A replacement for CHECK that calls DeathTestAbort if the assertion\n// fails.\n#define GTEST_DEATH_TEST_CHECK_(expression)                              \\\n  do {                                                                   \\\n    if (!::testing::internal::IsTrue(expression)) {                      \\\n      DeathTestAbort(::std::string(&quot;CHECK failed: File &quot;) + __FILE__ +   \\\n                     &quot;, line &quot; +                                         \\\n                     ::testing::internal::StreamableToString(__LINE__) + \\\n                     &quot;: &quot; + #expression);                                \\\n    }                                                                    \\\n  } while (::testing::internal::AlwaysFalse())\n\n// This macro is similar to GTEST_DEATH_TEST_CHECK_, but it is meant for\n// evaluating any system call that fulfills two conditions: it must return\n// -1 on failure, and set errno to EINTR when it is interrupted and\n// should be tried again.  The macro expands to a loop that repeatedly\n// evaluates the expression as long as it evaluates to -1 and sets\n// errno to EINTR.  If the expression evaluates to -1 but errno is\n// something other than EINTR, DeathTestAbort is called.\n#define GTEST_DEATH_TEST_CHECK_SYSCALL_(expression)                      \\\n  do {                                                                   \\\n    int gtest_retval;                                                    \\\n    do {                                                                 \\\n      gtest_retval = (expression);                                       \\\n    } while (gtest_retval == -1 &amp;&amp; errno == EINTR);                      \\\n    if (gtest_retval == -1) {                                            \\\n      DeathTestAbort(::std::string(&quot;CHECK failed: File &quot;) + __FILE__ +   \\\n                     &quot;, line &quot; +                                         \\\n                     ::testing::internal::StreamableToString(__LINE__) + \\\n                     &quot;: &quot; + #expression + &quot; != -1&quot;);                     \\\n    }                                                                    \\\n  } while (::testing::internal::AlwaysFalse())\n\n// Returns the message describing the last system error in errno.\nstd::string GetLastErrnoDescription() {\n  return errno == 0 ? &quot;&quot; : posix::StrError(errno);\n}\n\n// This is called from a death test parent process to read a failure\n// message from the death test child process and log it with the FATAL\n// severity. On Windows, the message is read from a pipe handle. On other\n// platforms, it is read from a file descriptor.\nstatic void FailFromInternalError(int fd) {\n  Message error;\n  char buffer[256];\n  int num_read;\n\n  do {\n    while ((num_read = posix::Read(fd, buffer, 255)) &gt; 0) {\n      buffer[num_read] = &#x27;\\0&#x27;;\n      error &lt;&lt; buffer;\n    }\n  } while (num_read == -1 &amp;&amp; errno == EINTR);\n\n  if (num_read == 0) {\n    GTEST_LOG_(FATAL) &lt;&lt; error.GetString();\n  } else {\n    const int last_error = errno;\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Error while reading death test internal: &quot;\n                      &lt;&lt; GetLastErrnoDescription() &lt;&lt; &quot; [&quot; &lt;&lt; last_error &lt;&lt; &quot;]&quot;;\n  }\n}\n\n// Death test constructor.  Increments the running death test count\n// for the current test.\nDeathTest::DeathTest() {\n  TestInfo* const info = GetUnitTestImpl()-&gt;current_test_info();\n  if (info == nullptr) {\n    DeathTestAbort(\n        &quot;Cannot run a death test outside of a TEST or &quot;\n        &quot;TEST_F construct&quot;);\n  }\n}\n\n// Creates and returns a death test by dispatching to the current\n// death test factory.\nbool DeathTest::Create(const char* statement,\n                       Matcher&lt;const std::string&amp;&gt; matcher, const char* file,\n                       int line, DeathTest** test) {\n  return GetUnitTestImpl()-&gt;death_test_factory()-&gt;Create(\n      statement, std::move(matcher), file, line, test);\n}\n\nconst char* DeathTest::LastMessage() {\n  return last_death_test_message_.c_str();\n}\n\nvoid DeathTest::set_last_death_test_message(const std::string&amp; message) {\n  last_death_test_message_ = message;\n}\n\nstd::string DeathTest::last_death_test_message_;\n\n// Provides cross platform implementation for some death functionality.\nclass DeathTestImpl : public DeathTest {\n protected:\n  DeathTestImpl(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher)\n      : statement_(a_statement),\n        matcher_(std::move(matcher)),\n        spawned_(false),\n        status_(-1),\n        outcome_(IN_PROGRESS),\n        read_fd_(-1),\n        write_fd_(-1) {}\n\n  // read_fd_ is expected to be closed and cleared by a derived class.\n  ~DeathTestImpl() override { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }\n\n  void Abort(AbortReason reason) override;\n  bool Passed(bool status_ok) override;\n\n  const char* statement() const { return statement_; }\n  bool spawned() const { return spawned_; }\n  void set_spawned(bool is_spawned) { spawned_ = is_spawned; }\n  int status() const { return status_; }\n  void set_status(int a_status) { status_ = a_status; }\n  DeathTestOutcome outcome() const { return outcome_; }\n  void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }\n  int read_fd() const { return read_fd_; }\n  void set_read_fd(int fd) { read_fd_ = fd; }\n  int write_fd() const { return write_fd_; }\n  void set_write_fd(int fd) { write_fd_ = fd; }\n\n  // Called in the parent process only. Reads the result code of the death\n  // test child process via a pipe, interprets it to set the outcome_\n  // member, and closes read_fd_.  Outputs diagnostics and terminates in\n  // case of unexpected codes.\n  void ReadAndInterpretStatusByte();\n\n  // Returns stderr output from the child process.\n  virtual std::string GetErrorLogs();\n\n private:\n  // The textual content of the code this object is testing.  This class\n  // doesn&#x27;t own this string and should not attempt to delete it.\n  const char* const statement_;\n  // A matcher that&#x27;s expected to match the stderr output by the child process.\n  Matcher&lt;const std::string&amp;&gt; matcher_;\n  // True if the death test child process has been successfully spawned.\n  bool spawned_;\n  // The exit status of the child process.\n  int status_;\n  // How the death test concluded.\n  DeathTestOutcome outcome_;\n  // Descriptor to the read end of the pipe to the child process.  It is\n  // always -1 in the child process.  The child keeps its write end of the\n  // pipe in write_fd_.\n  int read_fd_;\n  // Descriptor to the child&#x27;s write end of the pipe to the parent process.\n  // It is always -1 in the parent process.  The parent keeps its end of the\n  // pipe in read_fd_.\n  int write_fd_;\n};\n\n// Called in the parent process only. Reads the result code of the death\n// test child process via a pipe, interprets it to set the outcome_\n// member, and closes read_fd_.  Outputs diagnostics and terminates in\n// case of unexpected codes.\nvoid DeathTestImpl::ReadAndInterpretStatusByte() {\n  char flag;\n  int bytes_read;\n\n  // The read() here blocks until data is available (signifying the\n  // failure of the death test) or until the pipe is closed (signifying\n  // its success), so it&#x27;s okay to call this in the parent before\n  // the child process has exited.\n  do {\n    bytes_read = posix::Read(read_fd(), &amp;flag, 1);\n  } while (bytes_read == -1 &amp;&amp; errno == EINTR);\n\n  if (bytes_read == 0) {\n    set_outcome(DIED);\n  } else if (bytes_read == 1) {\n    switch (flag) {\n      case kDeathTestReturned:\n        set_outcome(RETURNED);\n        break;\n      case kDeathTestThrew:\n        set_outcome(THREW);\n        break;\n      case kDeathTestLived:\n        set_outcome(LIVED);\n        break;\n      case kDeathTestInternalError:\n        FailFromInternalError(read_fd());  // Does not return.\n        break;\n      default:\n        GTEST_LOG_(FATAL) &lt;&lt; &quot;Death test child process reported &quot;\n                          &lt;&lt; &quot;unexpected status byte (&quot;\n                          &lt;&lt; static_cast&lt;unsigned int&gt;(flag) &lt;&lt; &quot;)&quot;;\n    }\n  } else {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Read from death test child process failed: &quot;\n                      &lt;&lt; GetLastErrnoDescription();\n  }\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));\n  set_read_fd(-1);\n}\n\nstd::string DeathTestImpl::GetErrorLogs() { return GetCapturedStderr(); }\n\n// Signals that the death test code which should have exited, didn&#x27;t.\n// Should be called only in a death test child process.\n// Writes a status byte to the child&#x27;s status file descriptor, then\n// calls _exit(1).\nvoid DeathTestImpl::Abort(AbortReason reason) {\n  // The parent process considers the death test to be a failure if\n  // it finds any data in our pipe.  So, here we write a single flag byte\n  // to the pipe, then exit.\n  const char status_ch = reason == TEST_DID_NOT_DIE       ? kDeathTestLived\n                         : reason == TEST_THREW_EXCEPTION ? kDeathTestThrew\n                                                          : kDeathTestReturned;\n\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &amp;status_ch, 1));\n  // We are leaking the descriptor here because on some platforms (i.e.,\n  // when built as Windows DLL), destructors of global objects will still\n  // run after calling _exit(). On such systems, write_fd_ will be\n  // indirectly closed from the destructor of UnitTestImpl, causing double\n  // close if it is also closed here. On debug configurations, double close\n  // may assert. As there are no in-process buffers to flush here, we are\n  // relying on the OS to close the descriptor after the process terminates\n  // when the destructors are not run.\n  _exit(1);  // Exits w/o any normal exit hooks (we were supposed to crash)\n}\n\n// Returns an indented copy of stderr output for a death test.\n// This makes distinguishing death test output lines from regular log lines\n// much easier.\nstatic ::std::string FormatDeathTestOutput(const ::std::string&amp; output) {\n  ::std::string ret;\n  for (size_t at = 0;;) {\n    const size_t line_end = output.find(&#x27;\\n&#x27;, at);\n    ret += &quot;[  DEATH   ] &quot;;\n    if (line_end == ::std::string::npos) {\n      ret += output.substr(at);\n      break;\n    }\n    ret += output.substr(at, line_end + 1 - at);\n    at = line_end + 1;\n  }\n  return ret;\n}\n\n// Assesses the success or failure of a death test, using both private\n// members which have previously been set, and one argument:\n//\n// Private data members:\n//   outcome:  An enumeration describing how the death test\n//             concluded: DIED, LIVED, THREW, or RETURNED.  The death test\n//             fails in the latter three cases.\n//   status:   The exit status of the child process. On *nix, it is in the\n//             in the format specified by wait(2). On Windows, this is the\n//             value supplied to the ExitProcess() API or a numeric code\n//             of the exception that terminated the program.\n//   matcher_: A matcher that&#x27;s expected to match the stderr output by the child\n//             process.\n//\n// Argument:\n//   status_ok: true if exit_status is acceptable in the context of\n//              this particular death test, which fails if it is false\n//\n// Returns true if and only if all of the above conditions are met.  Otherwise,\n// the first failing condition, in the order given above, is the one that is\n// reported. Also sets the last death test message string.\nbool DeathTestImpl::Passed(bool status_ok) {\n  if (!spawned()) return false;\n\n  const std::string error_message = GetErrorLogs();\n\n  bool success = false;\n  Message buffer;\n\n  buffer &lt;&lt; &quot;Death test: &quot; &lt;&lt; statement() &lt;&lt; &quot;\\n&quot;;\n  switch (outcome()) {\n    case LIVED:\n      buffer &lt;&lt; &quot;    Result: failed to die.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case THREW:\n      buffer &lt;&lt; &quot;    Result: threw an exception.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case RETURNED:\n      buffer &lt;&lt; &quot;    Result: illegal return in test statement.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case DIED:\n      if (status_ok) {\n        if (matcher_.Matches(error_message)) {\n          success = true;\n        } else {\n          std::ostringstream stream;\n          matcher_.DescribeTo(&amp;stream);\n          buffer &lt;&lt; &quot;    Result: died but not with expected error.\\n&quot;\n                 &lt;&lt; &quot;  Expected: &quot; &lt;&lt; stream.str() &lt;&lt; &quot;\\n&quot;\n                 &lt;&lt; &quot;Actual msg:\\n&quot;\n                 &lt;&lt; FormatDeathTestOutput(error_message);\n        }\n      } else {\n        buffer &lt;&lt; &quot;    Result: died but not with expected exit code:\\n&quot;\n               &lt;&lt; &quot;            &quot; &lt;&lt; ExitSummary(status()) &lt;&lt; &quot;\\n&quot;\n               &lt;&lt; &quot;Actual msg:\\n&quot;\n               &lt;&lt; FormatDeathTestOutput(error_message);\n      }\n      break;\n    case IN_PROGRESS:\n    default:\n      GTEST_LOG_(FATAL)\n          &lt;&lt; &quot;DeathTest::Passed somehow called before conclusion of test&quot;;\n  }\n\n  DeathTest::set_last_death_test_message(buffer.GetString());\n  return success;\n}\n\n#if GTEST_OS_WINDOWS\n// WindowsDeathTest implements death tests on Windows. Due to the\n// specifics of starting new processes on Windows, death tests there are\n// always threadsafe, and Google Test considers the\n// --gtest_death_test_style=fast setting to be equivalent to\n// --gtest_death_test_style=threadsafe there.\n//\n// A few implementation notes:  Like the Linux version, the Windows\n// implementation uses pipes for child-to-parent communication. But due to\n// the specifics of pipes on Windows, some extra steps are required:\n//\n// 1. The parent creates a communication pipe and stores handles to both\n//    ends of it.\n// 2. The parent starts the child and provides it with the information\n//    necessary to acquire the handle to the write end of the pipe.\n// 3. The child acquires the write end of the pipe and signals the parent\n//    using a Windows event.\n// 4. Now the parent can release the write end of the pipe on its side. If\n//    this is done before step 3, the object&#x27;s reference count goes down to\n//    0 and it is destroyed, preventing the child from acquiring it. The\n//    parent now has to release it, or read operations on the read end of\n//    the pipe will not return when the child terminates.\n// 5. The parent reads child&#x27;s output through the pipe (outcome code and\n//    any possible error messages) from the pipe, and its stderr and then\n//    determines whether to fail the test.\n//\n// Note: to distinguish Win32 API calls from the local method and function\n// calls, the former are explicitly resolved in the global namespace.\n//\nclass WindowsDeathTest : public DeathTestImpl {\n public:\n  WindowsDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                   const char* file, int line)\n      : DeathTestImpl(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n\n  // All of these virtual functions are inherited from DeathTest.\n  virtual int Wait();\n  virtual TestRole AssumeRole();\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n  // Handle to the write end of the pipe to the child process.\n  AutoHandle write_handle_;\n  // Child process handle.\n  AutoHandle child_handle_;\n  // Event the child process uses to signal the parent that it has\n  // acquired the handle to the write end of the pipe. After seeing this\n  // event the parent can release its own handles to make sure its\n  // ReadFile() calls return when the child terminates.\n  AutoHandle event_handle_;\n};\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint WindowsDeathTest::Wait() {\n  if (!spawned()) return 0;\n\n  // Wait until the child either signals that it has acquired the write end\n  // of the pipe or it dies.\n  const HANDLE wait_handles[2] = {child_handle_.Get(), event_handle_.Get()};\n  switch (::WaitForMultipleObjects(2, wait_handles,\n                                   FALSE,  // Waits for any of the handles.\n                                   INFINITE)) {\n    case WAIT_OBJECT_0:\n    case WAIT_OBJECT_0 + 1:\n      break;\n    default:\n      GTEST_DEATH_TEST_CHECK_(false);  // Should not get here.\n  }\n\n  // The child has acquired the write end of the pipe or exited.\n  // We release the handle on our side and continue.\n  write_handle_.Reset();\n  event_handle_.Reset();\n\n  ReadAndInterpretStatusByte();\n\n  // Waits for the child process to exit if it haven&#x27;t already. This\n  // returns immediately if the child has already exited, regardless of\n  // whether previous calls to WaitForMultipleObjects synchronized on this\n  // handle or not.\n  GTEST_DEATH_TEST_CHECK_(WAIT_OBJECT_0 ==\n                          ::WaitForSingleObject(child_handle_.Get(), INFINITE));\n  DWORD status_code;\n  GTEST_DEATH_TEST_CHECK_(\n      ::GetExitCodeProcess(child_handle_.Get(), &amp;status_code) != FALSE);\n  child_handle_.Reset();\n  set_status(static_cast&lt;int&gt;(status_code));\n  return status();\n}\n\n// The AssumeRole process for a Windows death test.  It creates a child\n// process with the same executable as the current process to run the\n// death test.  The child process is given the --gtest_filter and\n// --gtest_internal_run_death_test flags such that it knows to run the\n// current death test only.\nDeathTest::TestRole WindowsDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(flag-&gt;write_fd());\n    return EXECUTE_TEST;\n  }\n\n  // WindowsDeathTest uses an anonymous pipe to communicate results of\n  // a death test.\n  SECURITY_ATTRIBUTES handles_are_inheritable = {sizeof(SECURITY_ATTRIBUTES),\n                                                 nullptr, TRUE};\n  HANDLE read_handle, write_handle;\n  GTEST_DEATH_TEST_CHECK_(::CreatePipe(&amp;read_handle, &amp;write_handle,\n                                       &amp;handles_are_inheritable,\n                                       0)  // Default buffer size.\n                          != FALSE);\n  set_read_fd(\n      ::_open_osfhandle(reinterpret_cast&lt;intptr_t&gt;(read_handle), O_RDONLY));\n  write_handle_.Reset(write_handle);\n  event_handle_.Reset(::CreateEvent(\n      &amp;handles_are_inheritable,\n      TRUE,       // The event will automatically reset to non-signaled state.\n      FALSE,      // The initial state is non-signalled.\n      nullptr));  // The even is unnamed.\n  GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != nullptr);\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag =\n      std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n      &quot;internal_run_death_test=&quot; + file_ + &quot;|&quot; + StreamableToString(line_) +\n      &quot;|&quot; + StreamableToString(death_test_index) + &quot;|&quot; +\n      StreamableToString(static_cast&lt;unsigned int&gt;(::GetCurrentProcessId())) +\n      // size_t has the same width as pointers on both 32-bit and 64-bit\n      // Windows platforms.\n      // See http://msdn.microsoft.com/en-us/library/tcxf1dw6.aspx.\n      &quot;|&quot; + StreamableToString(reinterpret_cast&lt;size_t&gt;(write_handle)) + &quot;|&quot; +\n      StreamableToString(reinterpret_cast&lt;size_t&gt;(event_handle_.Get()));\n\n  char executable_path[_MAX_PATH + 1];  // NOLINT\n  GTEST_DEATH_TEST_CHECK_(_MAX_PATH + 1 != ::GetModuleFileNameA(nullptr,\n                                                                executable_path,\n                                                                _MAX_PATH));\n\n  std::string command_line = std::string(::GetCommandLineA()) + &quot; &quot; +\n                             filter_flag + &quot; \\&quot;&quot; + internal_flag + &quot;\\&quot;&quot;;\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n\n  CaptureStderr();\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // The child process will share the standard handles with the parent.\n  STARTUPINFOA startup_info;\n  memset(&amp;startup_info, 0, sizeof(STARTUPINFO));\n  startup_info.dwFlags = STARTF_USESTDHANDLES;\n  startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\n  startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\n  startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\n\n  PROCESS_INFORMATION process_info;\n  GTEST_DEATH_TEST_CHECK_(\n      ::CreateProcessA(\n          executable_path, const_cast&lt;char*&gt;(command_line.c_str()),\n          nullptr,  // Returned process handle is not inheritable.\n          nullptr,  // Returned thread handle is not inheritable.\n          TRUE,  // Child inherits all inheritable handles (for write_handle_).\n          0x0,   // Default creation flags.\n          nullptr,  // Inherit the parent&#x27;s environment.\n          UnitTest::GetInstance()-&gt;original_working_dir(), &amp;startup_info,\n          &amp;process_info) != FALSE);\n  child_handle_.Reset(process_info.hProcess);\n  ::CloseHandle(process_info.hThread);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\n#elif GTEST_OS_FUCHSIA\n\nclass FuchsiaDeathTest : public DeathTestImpl {\n public:\n  FuchsiaDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                   const char* file, int line)\n      : DeathTestImpl(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n\n  // All of these virtual functions are inherited from DeathTest.\n  int Wait() override;\n  TestRole AssumeRole() override;\n  std::string GetErrorLogs() override;\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n  // The stderr data captured by the child process.\n  std::string captured_stderr_;\n\n  zx::process child_process_;\n  zx::channel exception_channel_;\n  zx::socket stderr_socket_;\n};\n\n// Utility class for accumulating command-line arguments.\nclass Arguments {\n public:\n  Arguments() { args_.push_back(nullptr); }\n\n  ~Arguments() {\n    for (std::vector&lt;char*&gt;::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }\n  void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }\n\n  template &lt;typename Str&gt;\n  void AddArguments(const ::std::vector&lt;Str&gt;&amp; arguments) {\n    for (typename ::std::vector&lt;Str&gt;::const_iterator i = arguments.begin();\n         i != arguments.end(); ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i-&gt;c_str()));\n    }\n  }\n  char* const* Argv() { return &amp;args_[0]; }\n\n  int size() { return static_cast&lt;int&gt;(args_.size()) - 1; }\n\n private:\n  std::vector&lt;char*&gt; args_;\n};\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint FuchsiaDeathTest::Wait() {\n  const int kProcessKey = 0;\n  const int kSocketKey = 1;\n  const int kExceptionKey = 2;\n\n  if (!spawned()) return 0;\n\n  // Create a port to wait for socket/task/exception events.\n  zx_status_t status_zx;\n  zx::port port;\n  status_zx = zx::port::create(0, &amp;port);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for the child process to terminate.\n  status_zx =\n      child_process_.wait_async(port, kProcessKey, ZX_PROCESS_TERMINATED, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for the socket to be readable or closed.\n  status_zx = stderr_socket_.wait_async(\n      port, kSocketKey, ZX_SOCKET_READABLE | ZX_SOCKET_PEER_CLOSED, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for an exception.\n  status_zx = exception_channel_.wait_async(port, kExceptionKey,\n                                            ZX_CHANNEL_READABLE, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  bool process_terminated = false;\n  bool socket_closed = false;\n  do {\n    zx_port_packet_t packet = {};\n    status_zx = port.wait(zx::time::infinite(), &amp;packet);\n    GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n    if (packet.key == kExceptionKey) {\n      // Process encountered an exception. Kill it directly rather than\n      // letting other handlers process the event. We will get a kProcessKey\n      // event when the process actually terminates.\n      status_zx = child_process_.kill();\n      GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n    } else if (packet.key == kProcessKey) {\n      // Process terminated.\n      GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));\n      GTEST_DEATH_TEST_CHECK_(packet.signal.observed &amp; ZX_PROCESS_TERMINATED);\n      process_terminated = true;\n    } else if (packet.key == kSocketKey) {\n      GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));\n      if (packet.signal.observed &amp; ZX_SOCKET_READABLE) {\n        // Read data from the socket.\n        constexpr size_t kBufferSize = 1024;\n        do {\n          size_t old_length = captured_stderr_.length();\n          size_t bytes_read = 0;\n          captured_stderr_.resize(old_length + kBufferSize);\n          status_zx =\n              stderr_socket_.read(0, &amp;captured_stderr_.front() + old_length,\n                                  kBufferSize, &amp;bytes_read);\n          captured_stderr_.resize(old_length + bytes_read);\n        } while (status_zx == ZX_OK);\n        if (status_zx == ZX_ERR_PEER_CLOSED) {\n          socket_closed = true;\n        } else {\n          GTEST_DEATH_TEST_CHECK_(status_zx == ZX_ERR_SHOULD_WAIT);\n          status_zx = stderr_socket_.wait_async(\n              port, kSocketKey, ZX_SOCKET_READABLE | ZX_SOCKET_PEER_CLOSED, 0);\n          GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n        }\n      } else {\n        GTEST_DEATH_TEST_CHECK_(packet.signal.observed &amp; ZX_SOCKET_PEER_CLOSED);\n        socket_closed = true;\n      }\n    }\n  } while (!process_terminated &amp;&amp; !socket_closed);\n\n  ReadAndInterpretStatusByte();\n\n  zx_info_process_t buffer;\n  status_zx = child_process_.get_info(ZX_INFO_PROCESS, &amp;buffer, sizeof(buffer),\n                                      nullptr, nullptr);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  GTEST_DEATH_TEST_CHECK_(buffer.flags &amp; ZX_INFO_PROCESS_FLAG_EXITED);\n  set_status(static_cast&lt;int&gt;(buffer.return_code));\n  return status();\n}\n\n// The AssumeRole process for a Fuchsia death test.  It creates a child\n// process with the same executable as the current process to run the\n// death test.  The child process is given the --gtest_filter and\n// --gtest_internal_run_death_test flags such that it knows to run the\n// current death test only.\nDeathTest::TestRole FuchsiaDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(kFuchsiaReadPipeFd);\n    return EXECUTE_TEST;\n  }\n\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // Build the child process command line.\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                    kInternalRunDeathTestFlag + &quot;=&quot; + file_ +\n                                    &quot;|&quot; + StreamableToString(line_) + &quot;|&quot; +\n                                    StreamableToString(death_test_index);\n  Arguments args;\n  args.AddArguments(GetInjectableArgvs());\n  args.AddArgument(filter_flag.c_str());\n  args.AddArgument(internal_flag.c_str());\n\n  // Build the pipe for communication with the child.\n  zx_status_t status;\n  zx_handle_t child_pipe_handle;\n  int child_pipe_fd;\n  status = fdio_pipe_half(&amp;child_pipe_fd, &amp;child_pipe_handle);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  set_read_fd(child_pipe_fd);\n\n  // Set the pipe handle for the child.\n  fdio_spawn_action_t spawn_actions[2] = {};\n  fdio_spawn_action_t* add_handle_action = &amp;spawn_actions[0];\n  add_handle_action-&gt;action = FDIO_SPAWN_ACTION_ADD_HANDLE;\n  add_handle_action-&gt;h.id = PA_HND(PA_FD, kFuchsiaReadPipeFd);\n  add_handle_action-&gt;h.handle = child_pipe_handle;\n\n  // Create a socket pair will be used to receive the child process&#x27; stderr.\n  zx::socket stderr_producer_socket;\n  status = zx::socket::create(0, &amp;stderr_producer_socket, &amp;stderr_socket_);\n  GTEST_DEATH_TEST_CHECK_(status &gt;= 0);\n  int stderr_producer_fd = -1;\n  status =\n      fdio_fd_create(stderr_producer_socket.release(), &amp;stderr_producer_fd);\n  GTEST_DEATH_TEST_CHECK_(status &gt;= 0);\n\n  // Make the stderr socket nonblocking.\n  GTEST_DEATH_TEST_CHECK_(fcntl(stderr_producer_fd, F_SETFL, 0) == 0);\n\n  fdio_spawn_action_t* add_stderr_action = &amp;spawn_actions[1];\n  add_stderr_action-&gt;action = FDIO_SPAWN_ACTION_CLONE_FD;\n  add_stderr_action-&gt;fd.local_fd = stderr_producer_fd;\n  add_stderr_action-&gt;fd.target_fd = STDERR_FILENO;\n\n  // Create a child job.\n  zx_handle_t child_job = ZX_HANDLE_INVALID;\n  status = zx_job_create(zx_job_default(), 0, &amp;child_job);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  zx_policy_basic_t policy;\n  policy.condition = ZX_POL_NEW_ANY;\n  policy.policy = ZX_POL_ACTION_ALLOW;\n  status = zx_job_set_policy(child_job, ZX_JOB_POL_RELATIVE, ZX_JOB_POL_BASIC,\n                             &amp;policy, 1);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  // Create an exception channel attached to the |child_job|, to allow\n  // us to suppress the system default exception handler from firing.\n  status = zx_task_create_exception_channel(\n      child_job, 0, exception_channel_.reset_and_get_address());\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  // Spawn the child process.\n  status = fdio_spawn_etc(child_job, FDIO_SPAWN_CLONE_ALL, args.Argv()[0],\n                          args.Argv(), nullptr, 2, spawn_actions,\n                          child_process_.reset_and_get_address(), nullptr);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\nstd::string FuchsiaDeathTest::GetErrorLogs() { return captured_stderr_; }\n\n#else  // We are neither on Windows, nor on Fuchsia.\n\n// ForkingDeathTest provides implementations for most of the abstract\n// methods of the DeathTest interface.  Only the AssumeRole method is\n// left undefined.\nclass ForkingDeathTest : public DeathTestImpl {\n public:\n  ForkingDeathTest(const char* statement, Matcher&lt;const std::string&amp;&gt; matcher);\n\n  // All of these virtual functions are inherited from DeathTest.\n  int Wait() override;\n\n protected:\n  void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }\n\n private:\n  // PID of child process during death test; 0 in the child process itself.\n  pid_t child_pid_;\n};\n\n// Constructs a ForkingDeathTest.\nForkingDeathTest::ForkingDeathTest(const char* a_statement,\n                                   Matcher&lt;const std::string&amp;&gt; matcher)\n    : DeathTestImpl(a_statement, std::move(matcher)), child_pid_(-1) {}\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint ForkingDeathTest::Wait() {\n  if (!spawned()) return 0;\n\n  ReadAndInterpretStatusByte();\n\n  int status_value;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &amp;status_value, 0));\n  set_status(status_value);\n  return status_value;\n}\n\n// A concrete death test class that forks, then immediately runs the test\n// in the child process.\nclass NoExecDeathTest : public ForkingDeathTest {\n public:\n  NoExecDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher)\n      : ForkingDeathTest(a_statement, std::move(matcher)) {}\n  TestRole AssumeRole() override;\n};\n\n// The AssumeRole process for a fork-and-run death test.  It implements a\n// straightforward fork, with a simple pipe to transmit the status byte.\nDeathTest::TestRole NoExecDeathTest::AssumeRole() {\n  const size_t thread_count = GetThreadCount();\n  if (thread_count != 1) {\n    GTEST_LOG_(WARNING) &lt;&lt; DeathTestThreadWarning(thread_count);\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n  CaptureStderr();\n  // When we fork the process below, the log file buffers are copied, but the\n  // file descriptors are shared.  We flush all log files here so that closing\n  // the file descriptors in the child process doesn&#x27;t throw off the\n  // synchronization between descriptors and buffers in the parent process.\n  // This is as close to the fork as possible to avoid a race condition in case\n  // there are multiple threads running before the death test, and another\n  // thread writes to the log file.\n  FlushInfoLog();\n\n  const pid_t child_pid = fork();\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  set_child_pid(child_pid);\n  if (child_pid == 0) {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));\n    set_write_fd(pipe_fd[1]);\n    // Redirects all logging to stderr in the child process to prevent\n    // concurrent writes to the log files.  We capture stderr in the parent\n    // process and append the child process&#x27; output to a log.\n    LogToStderr();\n    // Event forwarding to the listeners of event listener API mush be shut\n    // down in death test subprocesses.\n    GetUnitTestImpl()-&gt;listeners()-&gt;SuppressEventForwarding();\n    g_in_fast_death_test_child = true;\n    return EXECUTE_TEST;\n  } else {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n    set_read_fd(pipe_fd[0]);\n    set_spawned(true);\n    return OVERSEE_TEST;\n  }\n}\n\n// A concrete death test class that forks and re-executes the main\n// program from the beginning, with command-line flags set that cause\n// only this specific death test to be run.\nclass ExecDeathTest : public ForkingDeathTest {\n public:\n  ExecDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                const char* file, int line)\n      : ForkingDeathTest(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n  TestRole AssumeRole() override;\n\n private:\n  static ::std::vector&lt;std::string&gt; GetArgvsForDeathTestChildProcess() {\n    ::std::vector&lt;std::string&gt; args = GetInjectableArgvs();\n#if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    ::std::vector&lt;std::string&gt; extra_args =\n        GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();\n    args.insert(args.end(), extra_args.begin(), extra_args.end());\n#endif  // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    return args;\n  }\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n};\n\n// Utility class for accumulating command-line arguments.\nclass Arguments {\n public:\n  Arguments() { args_.push_back(nullptr); }\n\n  ~Arguments() {\n    for (std::vector&lt;char*&gt;::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }\n  void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }\n\n  template &lt;typename Str&gt;\n  void AddArguments(const ::std::vector&lt;Str&gt;&amp; arguments) {\n    for (typename ::std::vector&lt;Str&gt;::const_iterator i = arguments.begin();\n         i != arguments.end(); ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i-&gt;c_str()));\n    }\n  }\n  char* const* Argv() { return &amp;args_[0]; }\n\n private:\n  std::vector&lt;char*&gt; args_;\n};\n\n// A struct that encompasses the arguments to the child process of a\n// threadsafe-style death test process.\nstruct ExecDeathTestArgs {\n  char* const* argv;  // Command-line arguments for the child&#x27;s call to exec\n  int close_fd;       // File descriptor to close; the read end of a pipe\n};\n\n#if GTEST_OS_QNX\nextern &quot;C&quot; char** environ;\n#else   // GTEST_OS_QNX\n// The main function for a threadsafe-style death test child process.\n// This function is called in a clone()-ed process and thus must avoid\n// any potentially unsafe operations like malloc or libc functions.\nstatic int ExecDeathTestChildMain(void* child_arg) {\n  ExecDeathTestArgs* const args = static_cast&lt;ExecDeathTestArgs*&gt;(child_arg);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args-&gt;close_fd));\n\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()-&gt;original_working_dir();\n  // We can safely call chdir() as it&#x27;s a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(&quot;chdir(\\&quot;&quot;) + original_dir +\n                   &quot;\\&quot;) failed: &quot; + GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  // We can safely call execv() as it&#x27;s almost a direct system call. We\n  // cannot use execvp() as it&#x27;s a libc function and thus potentially\n  // unsafe.  Since execv() doesn&#x27;t search the PATH, the user must\n  // invoke the test program via a valid path that contains at least\n  // one path separator.\n  execv(args-&gt;argv[0], args-&gt;argv);\n  DeathTestAbort(std::string(&quot;execv(&quot;) + args-&gt;argv[0] + &quot;, ...) in &quot; +\n                 original_dir + &quot; failed: &quot; + GetLastErrnoDescription());\n  return EXIT_FAILURE;\n}\n#endif  // GTEST_OS_QNX\n\n#if GTEST_HAS_CLONE\n// Two utility routines that together determine the direction the stack\n// grows.\n// This could be accomplished more elegantly by a single recursive\n// function, but we want to guard against the unlikely possibility of\n// a smart compiler optimizing the recursion away.\n//\n// GTEST_NO_INLINE_ is required to prevent GCC 4.6 from inlining\n// StackLowerThanAddress into StackGrowsDown, which then doesn&#x27;t give\n// correct answer.\nstatic void StackLowerThanAddress(const void* ptr,\n                                  bool* result) GTEST_NO_INLINE_;\n// Make sure sanitizers do not tamper with the stack here.\n// Ideally, we want to use `__builtin_frame_address` instead of a local variable\n// address with sanitizer disabled, but it does not work when the\n// compiler optimizes the stack frame out, which happens on PowerPC targets.\n// HWAddressSanitizer add a random tag to the MSB of the local variable address,\n// making comparison result unpredictable.\nGTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\nstatic void StackLowerThanAddress(const void* ptr, bool* result) {\n  int dummy = 0;\n  *result = std::less&lt;const void*&gt;()(&amp;dummy, ptr);\n}\n\n// Make sure AddressSanitizer does not tamper with the stack here.\nGTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\nstatic bool StackGrowsDown() {\n  int dummy = 0;\n  bool result;\n  StackLowerThanAddress(&amp;dummy, &amp;result);\n  return result;\n}\n#endif  // GTEST_HAS_CLONE\n\n// Spawns a child process with the same executable as the current process in\n// a thread-safe manner and instructs it to run the death test.  The\n// implementation uses fork(2) + exec.  On systems where clone(2) is\n// available, it is used instead, being slightly more thread-safe.  On QNX,\n// fork supports only single-threaded environments, so this function uses\n// spawn(2) there instead.  The function dies with an error message if\n// anything goes wrong.\nstatic pid_t ExecDeathTestSpawnChild(char* const* argv, int close_fd) {\n  ExecDeathTestArgs args = {argv, close_fd};\n  pid_t child_pid = -1;\n\n#if GTEST_OS_QNX\n  // Obtains the current directory and sets it to be closed in the child\n  // process.\n  const int cwd_fd = open(&quot;.&quot;, O_RDONLY);\n  GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()-&gt;original_working_dir();\n  // We can safely call chdir() as it&#x27;s a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(&quot;chdir(\\&quot;&quot;) + original_dir +\n                   &quot;\\&quot;) failed: &quot; + GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  int fd_flags;\n  // Set close_fd to be closed after spawn.\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      fcntl(close_fd, F_SETFD, fd_flags | FD_CLOEXEC));\n  struct inheritance inherit = {0};\n  // spawn is a system call.\n  child_pid = spawn(args.argv[0], 0, nullptr, &amp;inherit, args.argv, environ);\n  // Restores the current working directory.\n  GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));\n\n#else  // GTEST_OS_QNX\n#if GTEST_OS_LINUX\n  // When a SIGPROF signal is received while fork() or clone() are executing,\n  // the process may hang. To avoid this, we ignore SIGPROF here and re-enable\n  // it after the call to fork()/clone() is complete.\n  struct sigaction saved_sigprof_action;\n  struct sigaction ignore_sigprof_action;\n  memset(&amp;ignore_sigprof_action, 0, sizeof(ignore_sigprof_action));\n  sigemptyset(&amp;ignore_sigprof_action.sa_mask);\n  ignore_sigprof_action.sa_handler = SIG_IGN;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      sigaction(SIGPROF, &amp;ignore_sigprof_action, &amp;saved_sigprof_action));\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_CLONE\n  const bool use_fork = GTEST_FLAG_GET(death_test_use_fork);\n\n  if (!use_fork) {\n    static const bool stack_grows_down = StackGrowsDown();\n    const auto stack_size = static_cast&lt;size_t&gt;(getpagesize() * 2);\n    // MMAP_ANONYMOUS is not defined on Mac, so we use MAP_ANON instead.\n    void* const stack = mmap(nullptr, stack_size, PROT_READ | PROT_WRITE,\n                             MAP_ANON | MAP_PRIVATE, -1, 0);\n    GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);\n\n    // Maximum stack alignment in bytes:  For a downward-growing stack, this\n    // amount is subtracted from size of the stack space to get an address\n    // that is within the stack space and is aligned on all systems we care\n    // about.  As far as I know there is no ABI with stack alignment greater\n    // than 64.  We assume stack and stack_size already have alignment of\n    // kMaxStackAlignment.\n    const size_t kMaxStackAlignment = 64;\n    void* const stack_top =\n        static_cast&lt;char*&gt;(stack) +\n        (stack_grows_down ? stack_size - kMaxStackAlignment : 0);\n    GTEST_DEATH_TEST_CHECK_(\n        static_cast&lt;size_t&gt;(stack_size) &gt; kMaxStackAlignment &amp;&amp;\n        reinterpret_cast&lt;uintptr_t&gt;(stack_top) % kMaxStackAlignment == 0);\n\n    child_pid = clone(&amp;ExecDeathTestChildMain, stack_top, SIGCHLD, &amp;args);\n\n    GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);\n  }\n#else\n  const bool use_fork = true;\n#endif  // GTEST_HAS_CLONE\n\n  if (use_fork &amp;&amp; (child_pid = fork()) == 0) {\n    ExecDeathTestChildMain(&amp;args);\n    _exit(0);\n  }\n#endif  // GTEST_OS_QNX\n#if GTEST_OS_LINUX\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      sigaction(SIGPROF, &amp;saved_sigprof_action, nullptr));\n#endif  // GTEST_OS_LINUX\n\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  return child_pid;\n}\n\n// The AssumeRole process for a fork-and-exec death test.  It re-executes the\n// main program from the beginning, setting the --gtest_filter\n// and --gtest_internal_run_death_test flags to cause only the current\n// death test to be re-run.\nDeathTest::TestRole ExecDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    set_write_fd(flag-&gt;write_fd());\n    return EXECUTE_TEST;\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n  // Clear the close-on-exec flag on the write end of the pipe, lest\n  // it be closed when the child process does an exec:\n  GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);\n\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                    &quot;internal_run_death_test=&quot; + file_ + &quot;|&quot; +\n                                    StreamableToString(line_) + &quot;|&quot; +\n                                    StreamableToString(death_test_index) + &quot;|&quot; +\n                                    StreamableToString(pipe_fd[1]);\n  Arguments args;\n  args.AddArguments(GetArgvsForDeathTestChildProcess());\n  args.AddArgument(filter_flag.c_str());\n  args.AddArgument(internal_flag.c_str());\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n\n  CaptureStderr();\n  // See the comment in NoExecDeathTest::AssumeRole for why the next line\n  // is necessary.\n  FlushInfoLog();\n\n  const pid_t child_pid = ExecDeathTestSpawnChild(args.Argv(), pipe_fd[0]);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n  set_child_pid(child_pid);\n  set_read_fd(pipe_fd[0]);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\n#endif  // !GTEST_OS_WINDOWS\n\n// Creates a concrete DeathTest-derived class that depends on the\n// --gtest_death_test_style flag, and sets the pointer pointed to\n// by the &quot;test&quot; argument to its address.  If the test should be\n// skipped, sets that pointer to NULL.  Returns true, unless the\n// flag is set to an invalid value.\nbool DefaultDeathTestFactory::Create(const char* statement,\n                                     Matcher&lt;const std::string&amp;&gt; matcher,\n                                     const char* file, int line,\n                                     DeathTest** test) {\n  UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const int death_test_index =\n      impl-&gt;current_test_info()-&gt;increment_death_test_count();\n\n  if (flag != nullptr) {\n    if (death_test_index &gt; flag-&gt;index()) {\n      DeathTest::set_last_death_test_message(\n          &quot;Death test count (&quot; + StreamableToString(death_test_index) +\n          &quot;) somehow exceeded expected maximum (&quot; +\n          StreamableToString(flag-&gt;index()) + &quot;)&quot;);\n      return false;\n    }\n\n    if (!(flag-&gt;file() == file &amp;&amp; flag-&gt;line() == line &amp;&amp;\n          flag-&gt;index() == death_test_index)) {\n      *test = nullptr;\n      return true;\n    }\n  }\n\n#if GTEST_OS_WINDOWS\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot; ||\n      GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new WindowsDeathTest(statement, std::move(matcher), file, line);\n  }\n\n#elif GTEST_OS_FUCHSIA\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot; ||\n      GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new FuchsiaDeathTest(statement, std::move(matcher), file, line);\n  }\n\n#else\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot;) {\n    *test = new ExecDeathTest(statement, std::move(matcher), file, line);\n  } else if (GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new NoExecDeathTest(statement, std::move(matcher));\n  }\n\n#endif  // GTEST_OS_WINDOWS\n\n  else {  // NOLINT - this is more readable than unbalanced brackets inside #if.\n    DeathTest::set_last_death_test_message(&quot;Unknown death test style \\&quot;&quot; +\n                                           GTEST_FLAG_GET(death_test_style) +\n                                           &quot;\\&quot; encountered&quot;);\n    return false;\n  }\n\n  return true;\n}\n\n#if GTEST_OS_WINDOWS\n// Recreates the pipe and event handles from the provided parameters,\n// signals the event, and returns a file descriptor wrapped around the pipe\n// handle. This function is called in the child process only.\nstatic int GetStatusFileDescriptor(unsigned int parent_process_id,\n                                   size_t write_handle_as_size_t,\n                                   size_t event_handle_as_size_t) {\n  AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,\n                                                 FALSE,  // Non-inheritable.\n                                                 parent_process_id));\n  if (parent_process_handle.Get() == INVALID_HANDLE_VALUE) {\n    DeathTestAbort(&quot;Unable to open parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  GTEST_CHECK_(sizeof(HANDLE) &lt;= sizeof(size_t));\n\n  const HANDLE write_handle = reinterpret_cast&lt;HANDLE&gt;(write_handle_as_size_t);\n  HANDLE dup_write_handle;\n\n  // The newly initialized handle is accessible only in the parent\n  // process. To obtain one accessible within the child, we need to use\n  // DuplicateHandle.\n  if (!::DuplicateHandle(parent_process_handle.Get(), write_handle,\n                         ::GetCurrentProcess(), &amp;dup_write_handle,\n                         0x0,    // Requested privileges ignored since\n                                 // DUPLICATE_SAME_ACCESS is used.\n                         FALSE,  // Request non-inheritable handler.\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(&quot;Unable to duplicate the pipe handle &quot; +\n                   StreamableToString(write_handle_as_size_t) +\n                   &quot; from the parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  const HANDLE event_handle = reinterpret_cast&lt;HANDLE&gt;(event_handle_as_size_t);\n  HANDLE dup_event_handle;\n\n  if (!::DuplicateHandle(parent_process_handle.Get(), event_handle,\n                         ::GetCurrentProcess(), &amp;dup_event_handle, 0x0, FALSE,\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(&quot;Unable to duplicate the event handle &quot; +\n                   StreamableToString(event_handle_as_size_t) +\n                   &quot; from the parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  const int write_fd =\n      ::_open_osfhandle(reinterpret_cast&lt;intptr_t&gt;(dup_write_handle), O_APPEND);\n  if (write_fd == -1) {\n    DeathTestAbort(&quot;Unable to convert pipe handle &quot; +\n                   StreamableToString(write_handle_as_size_t) +\n                   &quot; to a file descriptor&quot;);\n  }\n\n  // Signals the parent that the write end of the pipe has been acquired\n  // so the parent can release its own write end.\n  ::SetEvent(dup_event_handle);\n\n  return write_fd;\n}\n#endif  // GTEST_OS_WINDOWS\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() {\n  if (GTEST_FLAG_GET(internal_run_death_test) == &quot;&quot;) return nullptr;\n\n  // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we\n  // can use it here.\n  int line = -1;\n  int index = -1;\n  ::std::vector&lt; ::std::string&gt; fields;\n  SplitString(GTEST_FLAG_GET(internal_run_death_test), &#x27;|&#x27;, &amp;fields);\n  int write_fd = -1;\n\n#if GTEST_OS_WINDOWS\n\n  unsigned int parent_process_id = 0;\n  size_t write_handle_as_size_t = 0;\n  size_t event_handle_as_size_t = 0;\n\n  if (fields.size() != 6 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index) ||\n      !ParseNaturalNumber(fields[3], &amp;parent_process_id) ||\n      !ParseNaturalNumber(fields[4], &amp;write_handle_as_size_t) ||\n      !ParseNaturalNumber(fields[5], &amp;event_handle_as_size_t)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n  write_fd = GetStatusFileDescriptor(parent_process_id, write_handle_as_size_t,\n                                     event_handle_as_size_t);\n\n#elif GTEST_OS_FUCHSIA\n\n  if (fields.size() != 3 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n\n#else\n\n  if (fields.size() != 4 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index) ||\n      !ParseNaturalNumber(fields[3], &amp;write_fd)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n\n#endif  // GTEST_OS_WINDOWS\n\n  return new InternalRunDeathTestFlag(fields[0], line, index, write_fd);\n}\n\n}  // namespace internal\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace testing\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;fstream&gt;\n#include &lt;memory&gt;\n\n#if GTEST_OS_WINDOWS\n#include &lt;io.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;windows.h&gt;\n\n#include &lt;map&gt;  // Used in ThreadLocal.\n#ifdef _MSC_VER\n#include &lt;crtdbg.h&gt;\n#endif  // _MSC_VER\n#else\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_MAC\n#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/task.h&gt;\n#include &lt;mach/vm_map.h&gt;\n#endif  // GTEST_OS_MAC\n\n#if GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD || \\\n    GTEST_OS_NETBSD || GTEST_OS_OPENBSD\n#include &lt;sys/sysctl.h&gt;\n#if GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD\n#include &lt;sys/user.h&gt;\n#endif\n#endif\n\n#if GTEST_OS_QNX\n#include &lt;devctl.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/procfs.h&gt;\n#endif  // GTEST_OS_QNX\n\n#if GTEST_OS_AIX\n#include &lt;procinfo.h&gt;\n#include &lt;sys/types.h&gt;\n#endif  // GTEST_OS_AIX\n\n#if GTEST_OS_FUCHSIA\n#include &lt;zircon/process.h&gt;\n#include &lt;zircon/syscalls.h&gt;\n#endif  // GTEST_OS_FUCHSIA\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/gtest-spi.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;src/gtest-internal-inl.h&quot;\n\nnamespace testing {\nnamespace internal {\n\n#if GTEST_OS_LINUX || GTEST_OS_GNU_HURD\n\nnamespace {\ntemplate &lt;typename T&gt;\nT ReadProcFileField(const std::string&amp; filename, int field) {\n  std::string dummy;\n  std::ifstream file(filename.c_str());\n  while (field-- &gt; 0) {\n    file &gt;&gt; dummy;\n  }\n  T output = 0;\n  file &gt;&gt; output;\n  return output;\n}\n}  // namespace\n\n// Returns the number of active threads, or 0 when there is an error.\nsize_t GetThreadCount() {\n  const std::string filename =\n      (Message() &lt;&lt; &quot;/proc/&quot; &lt;&lt; getpid() &lt;&lt; &quot;/stat&quot;).GetString();\n  return ReadProcFileField&lt;size_t&gt;(filename, 19);\n}\n\n#elif GTEST_OS_MAC\n\nsize_t GetThreadCount() {\n  const task_t task = mach_task_self();\n  mach_msg_type_number_t thread_count;\n  thread_act_array_t thread_list;\n  const kern_return_t status = task_threads(task, &amp;thread_list, &amp;thread_count);\n  if (status == KERN_SUCCESS) {\n    // task_threads allocates resources in thread_list and we need to free them\n    // to avoid leaks.\n    vm_deallocate(task, reinterpret_cast&lt;vm_address_t&gt;(thread_list),\n                  sizeof(thread_t) * thread_count);\n    return static_cast&lt;size_t&gt;(thread_count);\n  } else {\n    return 0;\n  }\n}\n\n#elif GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD || \\\n    GTEST_OS_NETBSD\n\n#if GTEST_OS_NETBSD\n#undef KERN_PROC\n#define KERN_PROC KERN_PROC2\n#define kinfo_proc kinfo_proc2\n#endif\n\n#if GTEST_OS_DRAGONFLY\n#define KP_NLWP(kp) (kp.kp_nthreads)\n#elif GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD\n#define KP_NLWP(kp) (kp.ki_numthreads)\n#elif GTEST_OS_NETBSD\n#define KP_NLWP(kp) (kp.p_nlwps)\n#endif\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  int mib[] = {\n    CTL_KERN,\n    KERN_PROC,\n    KERN_PROC_PID,\n    getpid(),\n#if GTEST_OS_NETBSD\n    sizeof(struct kinfo_proc),\n    1,\n#endif\n  };\n  u_int miblen = sizeof(mib) / sizeof(mib[0]);\n  struct kinfo_proc info;\n  size_t size = sizeof(info);\n  if (sysctl(mib, miblen, &amp;info, &amp;size, NULL, 0)) {\n    return 0;\n  }\n  return static_cast&lt;size_t&gt;(KP_NLWP(info));\n}\n#elif GTEST_OS_OPENBSD\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  int mib[] = {\n      CTL_KERN,\n      KERN_PROC,\n      KERN_PROC_PID | KERN_PROC_SHOW_THREADS,\n      getpid(),\n      sizeof(struct kinfo_proc),\n      0,\n  };\n  u_int miblen = sizeof(mib) / sizeof(mib[0]);\n\n  // get number of structs\n  size_t size;\n  if (sysctl(mib, miblen, NULL, &amp;size, NULL, 0)) {\n    return 0;\n  }\n\n  mib[5] = static_cast&lt;int&gt;(size / static_cast&lt;size_t&gt;(mib[4]));\n\n  // populate array of structs\n  struct kinfo_proc info[mib[5]];\n  if (sysctl(mib, miblen, &amp;info, &amp;size, NULL, 0)) {\n    return 0;\n  }\n\n  // exclude empty members\n  size_t nthreads = 0;\n  for (size_t i = 0; i &lt; size / static_cast&lt;size_t&gt;(mib[4]); i++) {\n    if (info[i].p_tid != -1) nthreads++;\n  }\n  return nthreads;\n}\n\n#elif GTEST_OS_QNX\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  const int fd = open(&quot;/proc/self/as&quot;, O_RDONLY);\n  if (fd &lt; 0) {\n    return 0;\n  }\n  procfs_info process_info;\n  const int status =\n      devctl(fd, DCMD_PROC_INFO, &amp;process_info, sizeof(process_info), nullptr);\n  close(fd);\n  if (status == EOK) {\n    return static_cast&lt;size_t&gt;(process_info.num_threads);\n  } else {\n    return 0;\n  }\n}\n\n#elif GTEST_OS_AIX\n\nsize_t GetThreadCount() {\n  struct procentry64 entry;\n  pid_t pid = getpid();\n  int status = getprocs64(&amp;entry, sizeof(entry), nullptr, 0, &amp;pid, 1);\n  if (status == 1) {\n    return entry.pi_thcount;\n  } else {\n    return 0;\n  }\n}\n\n#elif GTEST_OS_FUCHSIA\n\nsize_t GetThreadCount() {\n  int dummy_buffer;\n  size_t avail;\n  zx_status_t status =\n      zx_object_get_info(zx_process_self(), ZX_INFO_PROCESS_THREADS,\n                         &amp;dummy_buffer, 0, nullptr, &amp;avail);\n  if (status == ZX_OK) {\n    return avail;\n  } else {\n    return 0;\n  }\n}\n\n#else\n\nsize_t GetThreadCount() {\n  // There&#x27;s no portable way to detect the number of threads, so we just\n  // return 0 to indicate that we cannot detect it.\n  return 0;\n}\n\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_IS_THREADSAFE &amp;&amp; GTEST_OS_WINDOWS\n\nAutoHandle::AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}\n\nAutoHandle::AutoHandle(Handle handle) : handle_(handle) {}\n\nAutoHandle::~AutoHandle() { Reset(); }\n\nAutoHandle::Handle AutoHandle::Get() const { return handle_; }\n\nvoid AutoHandle::Reset() { Reset(INVALID_HANDLE_VALUE); }\n\nvoid AutoHandle::Reset(HANDLE handle) {\n  // Resetting with the same handle we already own is invalid.\n  if (handle_ != handle) {\n    if (IsCloseable()) {\n      ::CloseHandle(handle_);\n    }\n    handle_ = handle;\n  } else {\n    GTEST_CHECK_(!IsCloseable())\n        &lt;&lt; &quot;Resetting a valid handle to itself is likely a programmer error &quot;\n           &quot;and thus not allowed.&quot;;\n  }\n}\n\nbool AutoHandle::IsCloseable() const {\n  // Different Windows APIs may use either of these values to represent an\n  // invalid handle.\n  return handle_ != nullptr &amp;&amp; handle_ != INVALID_HANDLE_VALUE;\n}\n\nMutex::Mutex()\n    : owner_thread_id_(0),\n      type_(kDynamic),\n      critical_section_init_phase_(0),\n      critical_section_(new CRITICAL_SECTION) {\n  ::InitializeCriticalSection(critical_section_);\n}\n\nMutex::~Mutex() {\n  // Static mutexes are leaked intentionally. It is not thread-safe to try\n  // to clean them up.\n  if (type_ == kDynamic) {\n    ::DeleteCriticalSection(critical_section_);\n    delete critical_section_;\n    critical_section_ = nullptr;\n  }\n}\n\nvoid Mutex::Lock() {\n  ThreadSafeLazyInit();\n  ::EnterCriticalSection(critical_section_);\n  owner_thread_id_ = ::GetCurrentThreadId();\n}\n\nvoid Mutex::Unlock() {\n  ThreadSafeLazyInit();\n  // We don&#x27;t protect writing to owner_thread_id_ here, as it&#x27;s the\n  // caller&#x27;s responsibility to ensure that the current thread holds the\n  // mutex when this is called.\n  owner_thread_id_ = 0;\n  ::LeaveCriticalSection(critical_section_);\n}\n\n// Does nothing if the current thread holds the mutex. Otherwise, crashes\n// with high probability.\nvoid Mutex::AssertHeld() {\n  ThreadSafeLazyInit();\n  GTEST_CHECK_(owner_thread_id_ == ::GetCurrentThreadId())\n      &lt;&lt; &quot;The current thread is not holding the mutex @&quot; &lt;&lt; this;\n}\n\nnamespace {\n\n#ifdef _MSC_VER\n// Use the RAII idiom to flag mem allocs that are intentionally never\n// deallocated. The motivation is to silence the false positive mem leaks\n// that are reported by the debug version of MS&#x27;s CRT which can only detect\n// if an alloc is missing a matching deallocation.\n// Example:\n//    MemoryIsNotDeallocated memory_is_not_deallocated;\n//    critical_section_ = new CRITICAL_SECTION;\n//\nclass MemoryIsNotDeallocated {\n public:\n  MemoryIsNotDeallocated() : old_crtdbg_flag_(0) {\n    old_crtdbg_flag_ = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n    // Set heap allocation block type to _IGNORE_BLOCK so that MS debug CRT\n    // doesn&#x27;t report mem leak if there&#x27;s no matching deallocation.\n    (void)_CrtSetDbgFlag(old_crtdbg_flag_ &amp; ~_CRTDBG_ALLOC_MEM_DF);\n  }\n\n  ~MemoryIsNotDeallocated() {\n    // Restore the original _CRTDBG_ALLOC_MEM_DF flag\n    (void)_CrtSetDbgFlag(old_crtdbg_flag_);\n  }\n\n private:\n  int old_crtdbg_flag_;\n\n  MemoryIsNotDeallocated(const MemoryIsNotDeallocated&amp;) = delete;\n  MemoryIsNotDeallocated&amp; operator=(const MemoryIsNotDeallocated&amp;) = delete;\n};\n#endif  // _MSC_VER\n\n}  // namespace\n\n// Initializes owner_thread_id_ and critical_section_ in static mutexes.\nvoid Mutex::ThreadSafeLazyInit() {\n  // Dynamic mutexes are initialized in the constructor.\n  if (type_ == kStatic) {\n    switch (\n        ::InterlockedCompareExchange(&amp;critical_section_init_phase_, 1L, 0L)) {\n      case 0:\n        // If critical_section_init_phase_ was 0 before the exchange, we\n        // are the first to test it and need to perform the initialization.\n        owner_thread_id_ = 0;\n        {\n          // Use RAII to flag that following mem alloc is never deallocated.\n#ifdef _MSC_VER\n          MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n          critical_section_ = new CRITICAL_SECTION;\n        }\n        ::InitializeCriticalSection(critical_section_);\n        // Updates the critical_section_init_phase_ to 2 to signal\n        // initialization complete.\n        GTEST_CHECK_(::InterlockedCompareExchange(&amp;critical_section_init_phase_,\n                                                  2L, 1L) == 1L);\n        break;\n      case 1:\n        // Somebody else is already initializing the mutex; spin until they\n        // are done.\n        while (::InterlockedCompareExchange(&amp;critical_section_init_phase_, 2L,\n                                            2L) != 2L) {\n          // Possibly yields the rest of the thread&#x27;s time slice to other\n          // threads.\n          ::Sleep(0);\n        }\n        break;\n\n      case 2:\n        break;  // The mutex is already initialized and ready for use.\n\n      default:\n        GTEST_CHECK_(false)\n            &lt;&lt; &quot;Unexpected value of critical_section_init_phase_ &quot;\n            &lt;&lt; &quot;while initializing a static mutex.&quot;;\n    }\n  }\n}\n\nnamespace {\n\nclass ThreadWithParamSupport : public ThreadWithParamBase {\n public:\n  static HANDLE CreateThread(Runnable* runnable,\n                             Notification* thread_can_start) {\n    ThreadMainParam* param = new ThreadMainParam(runnable, thread_can_start);\n    DWORD thread_id;\n    HANDLE thread_handle = ::CreateThread(\n        nullptr,  // Default security.\n        0,        // Default stack size.\n        &amp;ThreadWithParamSupport::ThreadMain,\n        param,        // Parameter to ThreadMainStatic\n        0x0,          // Default creation flags.\n        &amp;thread_id);  // Need a valid pointer for the call to work under Win98.\n    GTEST_CHECK_(thread_handle != nullptr)\n        &lt;&lt; &quot;CreateThread failed with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n    if (thread_handle == nullptr) {\n      delete param;\n    }\n    return thread_handle;\n  }\n\n private:\n  struct ThreadMainParam {\n    ThreadMainParam(Runnable* runnable, Notification* thread_can_start)\n        : runnable_(runnable), thread_can_start_(thread_can_start) {}\n    std::unique_ptr&lt;Runnable&gt; runnable_;\n    // Does not own.\n    Notification* thread_can_start_;\n  };\n\n  static DWORD WINAPI ThreadMain(void* ptr) {\n    // Transfers ownership.\n    std::unique_ptr&lt;ThreadMainParam&gt; param(static_cast&lt;ThreadMainParam*&gt;(ptr));\n    if (param-&gt;thread_can_start_ != nullptr)\n      param-&gt;thread_can_start_-&gt;WaitForNotification();\n    param-&gt;runnable_-&gt;Run();\n    return 0;\n  }\n\n  // Prohibit instantiation.\n  ThreadWithParamSupport();\n\n  ThreadWithParamSupport(const ThreadWithParamSupport&amp;) = delete;\n  ThreadWithParamSupport&amp; operator=(const ThreadWithParamSupport&amp;) = delete;\n};\n\n}  // namespace\n\nThreadWithParamBase::ThreadWithParamBase(Runnable* runnable,\n                                         Notification* thread_can_start)\n    : thread_(\n          ThreadWithParamSupport::CreateThread(runnable, thread_can_start)) {}\n\nThreadWithParamBase::~ThreadWithParamBase() { Join(); }\n\nvoid ThreadWithParamBase::Join() {\n  GTEST_CHECK_(::WaitForSingleObject(thread_.Get(), INFINITE) == WAIT_OBJECT_0)\n      &lt;&lt; &quot;Failed to join the thread with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n}\n\n// Maps a thread to a set of ThreadIdToThreadLocals that have values\n// instantiated on that thread and notifies them when the thread exits.  A\n// ThreadLocal instance is expected to persist until all threads it has\n// values on have terminated.\nclass ThreadLocalRegistryImpl {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance) {\n#ifdef _MSC_VER\n    MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n    DWORD current_thread = ::GetCurrentThreadId();\n    MutexLock lock(&amp;mutex_);\n    ThreadIdToThreadLocals* const thread_to_thread_locals =\n        GetThreadLocalsMapLocked();\n    ThreadIdToThreadLocals::iterator thread_local_pos =\n        thread_to_thread_locals-&gt;find(current_thread);\n    if (thread_local_pos == thread_to_thread_locals-&gt;end()) {\n      thread_local_pos =\n          thread_to_thread_locals\n              -&gt;insert(std::make_pair(current_thread, ThreadLocalValues()))\n              .first;\n      StartWatcherThreadFor(current_thread);\n    }\n    ThreadLocalValues&amp; thread_local_values = thread_local_pos-&gt;second;\n    ThreadLocalValues::iterator value_pos =\n        thread_local_values.find(thread_local_instance);\n    if (value_pos == thread_local_values.end()) {\n      value_pos =\n          thread_local_values\n              .insert(std::make_pair(\n                  thread_local_instance,\n                  std::shared_ptr&lt;ThreadLocalValueHolderBase&gt;(\n                      thread_local_instance-&gt;NewValueForCurrentThread())))\n              .first;\n    }\n    return value_pos-&gt;second.get();\n  }\n\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance) {\n    std::vector&lt;std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt; value_holders;\n    // Clean up the ThreadLocalValues data structure while holding the lock, but\n    // defer the destruction of the ThreadLocalValueHolderBases.\n    {\n      MutexLock lock(&amp;mutex_);\n      ThreadIdToThreadLocals* const thread_to_thread_locals =\n          GetThreadLocalsMapLocked();\n      for (ThreadIdToThreadLocals::iterator it =\n               thread_to_thread_locals-&gt;begin();\n           it != thread_to_thread_locals-&gt;end(); ++it) {\n        ThreadLocalValues&amp; thread_local_values = it-&gt;second;\n        ThreadLocalValues::iterator value_pos =\n            thread_local_values.find(thread_local_instance);\n        if (value_pos != thread_local_values.end()) {\n          value_holders.push_back(value_pos-&gt;second);\n          thread_local_values.erase(value_pos);\n          // This &#x27;if&#x27; can only be successful at most once, so theoretically we\n          // could break out of the loop here, but we don&#x27;t bother doing so.\n        }\n      }\n    }\n    // Outside the lock, let the destructor for &#x27;value_holders&#x27; deallocate the\n    // ThreadLocalValueHolderBases.\n  }\n\n  static void OnThreadExit(DWORD thread_id) {\n    GTEST_CHECK_(thread_id != 0) &lt;&lt; ::GetLastError();\n    std::vector&lt;std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt; value_holders;\n    // Clean up the ThreadIdToThreadLocals data structure while holding the\n    // lock, but defer the destruction of the ThreadLocalValueHolderBases.\n    {\n      MutexLock lock(&amp;mutex_);\n      ThreadIdToThreadLocals* const thread_to_thread_locals =\n          GetThreadLocalsMapLocked();\n      ThreadIdToThreadLocals::iterator thread_local_pos =\n          thread_to_thread_locals-&gt;find(thread_id);\n      if (thread_local_pos != thread_to_thread_locals-&gt;end()) {\n        ThreadLocalValues&amp; thread_local_values = thread_local_pos-&gt;second;\n        for (ThreadLocalValues::iterator value_pos =\n                 thread_local_values.begin();\n             value_pos != thread_local_values.end(); ++value_pos) {\n          value_holders.push_back(value_pos-&gt;second);\n        }\n        thread_to_thread_locals-&gt;erase(thread_local_pos);\n      }\n    }\n    // Outside the lock, let the destructor for &#x27;value_holders&#x27; deallocate the\n    // ThreadLocalValueHolderBases.\n  }\n\n private:\n  // In a particular thread, maps a ThreadLocal object to its value.\n  typedef std::map&lt;const ThreadLocalBase*,\n                   std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt;\n      ThreadLocalValues;\n  // Stores all ThreadIdToThreadLocals having values in a thread, indexed by\n  // thread&#x27;s ID.\n  typedef std::map&lt;DWORD, ThreadLocalValues&gt; ThreadIdToThreadLocals;\n\n  // Holds the thread id and thread handle that we pass from\n  // StartWatcherThreadFor to WatcherThreadFunc.\n  typedef std::pair&lt;DWORD, HANDLE&gt; ThreadIdAndHandle;\n\n  static void StartWatcherThreadFor(DWORD thread_id) {\n    // The returned handle will be kept in thread_map and closed by\n    // watcher_thread in WatcherThreadFunc.\n    HANDLE thread =\n        ::OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION, FALSE, thread_id);\n    GTEST_CHECK_(thread != nullptr);\n    // We need to pass a valid thread ID pointer into CreateThread for it\n    // to work correctly under Win98.\n    DWORD watcher_thread_id;\n    HANDLE watcher_thread = ::CreateThread(\n        nullptr,  // Default security.\n        0,        // Default stack size\n        &amp;ThreadLocalRegistryImpl::WatcherThreadFunc,\n        reinterpret_cast&lt;LPVOID&gt;(new ThreadIdAndHandle(thread_id, thread)),\n        CREATE_SUSPENDED, &amp;watcher_thread_id);\n    GTEST_CHECK_(watcher_thread != nullptr)\n        &lt;&lt; &quot;CreateThread failed with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n    // Give the watcher thread the same priority as ours to avoid being\n    // blocked by it.\n    ::SetThreadPriority(watcher_thread,\n                        ::GetThreadPriority(::GetCurrentThread()));\n    ::ResumeThread(watcher_thread);\n    ::CloseHandle(watcher_thread);\n  }\n\n  // Monitors exit from a given thread and notifies those\n  // ThreadIdToThreadLocals about thread termination.\n  static DWORD WINAPI WatcherThreadFunc(LPVOID param) {\n    const ThreadIdAndHandle* tah =\n        reinterpret_cast&lt;const ThreadIdAndHandle*&gt;(param);\n    GTEST_CHECK_(::WaitForSingleObject(tah-&gt;second, INFINITE) == WAIT_OBJECT_0);\n    OnThreadExit(tah-&gt;first);\n    ::CloseHandle(tah-&gt;second);\n    delete tah;\n    return 0;\n  }\n\n  // Returns map of thread local instances.\n  static ThreadIdToThreadLocals* GetThreadLocalsMapLocked() {\n    mutex_.AssertHeld();\n#ifdef _MSC_VER\n    MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n    static ThreadIdToThreadLocals* map = new ThreadIdToThreadLocals();\n    return map;\n  }\n\n  // Protects access to GetThreadLocalsMapLocked() and its return value.\n  static Mutex mutex_;\n  // Protects access to GetThreadMapLocked() and its return value.\n  static Mutex thread_map_mutex_;\n};\n\nMutex ThreadLocalRegistryImpl::mutex_(Mutex::kStaticMutex);  // NOLINT\nMutex ThreadLocalRegistryImpl::thread_map_mutex_(\n    Mutex::kStaticMutex);  // NOLINT\n\nThreadLocalValueHolderBase* ThreadLocalRegistry::GetValueOnCurrentThread(\n    const ThreadLocalBase* thread_local_instance) {\n  return ThreadLocalRegistryImpl::GetValueOnCurrentThread(\n      thread_local_instance);\n}\n\nvoid ThreadLocalRegistry::OnThreadLocalDestroyed(\n    const ThreadLocalBase* thread_local_instance) {\n  ThreadLocalRegistryImpl::OnThreadLocalDestroyed(thread_local_instance);\n}\n\n#endif  // GTEST_IS_THREADSAFE &amp;&amp; GTEST_OS_WINDOWS\n\n#if GTEST_USES_POSIX_RE\n\n// Implements RE.  Currently only needed for death tests.\n\nRE::~RE() {\n  if (is_valid_) {\n    // regfree&#x27;ing an invalid regex might crash because the content\n    // of the regex is undefined. Since the regex&#x27;s are essentially\n    // the same, one cannot be valid (or invalid) without the other\n    // being so too.\n    regfree(&amp;partial_regex_);\n    regfree(&amp;full_regex_);\n  }\n  free(const_cast&lt;char*&gt;(pattern_));\n}\n\n// Returns true if and only if regular expression re matches the entire str.\nbool RE::FullMatch(const char* str, const RE&amp; re) {\n  if (!re.is_valid_) return false;\n\n  regmatch_t match;\n  return regexec(&amp;re.full_regex_, str, 1, &amp;match, 0) == 0;\n}\n\n// Returns true if and only if regular expression re matches a substring of\n// str (including str itself).\nbool RE::PartialMatch(const char* str, const RE&amp; re) {\n  if (!re.is_valid_) return false;\n\n  regmatch_t match;\n  return regexec(&amp;re.partial_regex_, str, 1, &amp;match, 0) == 0;\n}\n\n// Initializes an RE from its string representation.\nvoid RE::Init(const char* regex) {\n  pattern_ = posix::StrDup(regex);\n\n  // Reserves enough bytes to hold the regular expression used for a\n  // full match.\n  const size_t full_regex_len = strlen(regex) + 10;\n  char* const full_pattern = new char[full_regex_len];\n\n  snprintf(full_pattern, full_regex_len, &quot;^(%s)$&quot;, regex);\n  is_valid_ = regcomp(&amp;full_regex_, full_pattern, REG_EXTENDED) == 0;\n  // We want to call regcomp(&amp;partial_regex_, ...) even if the\n  // previous expression returns false.  Otherwise partial_regex_ may\n  // not be properly initialized can may cause trouble when it&#x27;s\n  // freed.\n  //\n  // Some implementation of POSIX regex (e.g. on at least some\n  // versions of Cygwin) doesn&#x27;t accept the empty string as a valid\n  // regex.  We change it to an equivalent form &quot;()&quot; to be safe.\n  if (is_valid_) {\n    const char* const partial_regex = (*regex == &#x27;\\0&#x27;) ? &quot;()&quot; : regex;\n    is_valid_ = regcomp(&amp;partial_regex_, partial_regex, REG_EXTENDED) == 0;\n  }\n  EXPECT_TRUE(is_valid_)\n      &lt;&lt; &quot;Regular expression \\&quot;&quot; &lt;&lt; regex\n      &lt;&lt; &quot;\\&quot; is not a valid POSIX Extended regular expression.&quot;;\n\n  delete[] full_pattern;\n}\n\n#elif GTEST_USES_SIMPLE_RE\n\n// Returns true if and only if ch appears anywhere in str (excluding the\n// terminating &#x27;\\0&#x27; character).\nbool IsInSet(char ch, const char* str) {\n  return ch != &#x27;\\0&#x27; &amp;&amp; strchr(str, ch) != nullptr;\n}\n\n// Returns true if and only if ch belongs to the given classification.\n// Unlike similar functions in &lt;ctype.h&gt;, these aren&#x27;t affected by the\n// current locale.\nbool IsAsciiDigit(char ch) { return &#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;; }\nbool IsAsciiPunct(char ch) {\n  return IsInSet(ch, &quot;^-!\\&quot;#$%&amp;&#x27;()*+,./:;&lt;=&gt;?@[\\\\]_`{|}~&quot;);\n}\nbool IsRepeat(char ch) { return IsInSet(ch, &quot;?*+&quot;); }\nbool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, &quot; \\f\\n\\r\\t\\v&quot;); }\nbool IsAsciiWordChar(char ch) {\n  return (&#x27;a&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;z&#x27;) || (&#x27;A&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;Z&#x27;) ||\n         (&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;) || ch == &#x27;_&#x27;;\n}\n\n// Returns true if and only if &quot;\\\\c&quot; is a supported escape sequence.\nbool IsValidEscape(char c) {\n  return (IsAsciiPunct(c) || IsInSet(c, &quot;dDfnrsStvwW&quot;));\n}\n\n// Returns true if and only if the given atom (specified by escaped and\n// pattern) matches ch.  The result is undefined if the atom is invalid.\nbool AtomMatchesChar(bool escaped, char pattern_char, char ch) {\n  if (escaped) {  // &quot;\\\\p&quot; where p is pattern_char.\n    switch (pattern_char) {\n      case &#x27;d&#x27;:\n        return IsAsciiDigit(ch);\n      case &#x27;D&#x27;:\n        return !IsAsciiDigit(ch);\n      case &#x27;f&#x27;:\n        return ch == &#x27;\\f&#x27;;\n      case &#x27;n&#x27;:\n        return ch == &#x27;\\n&#x27;;\n      case &#x27;r&#x27;:\n        return ch == &#x27;\\r&#x27;;\n      case &#x27;s&#x27;:\n        return IsAsciiWhiteSpace(ch);\n      case &#x27;S&#x27;:\n        return !IsAsciiWhiteSpace(ch);\n      case &#x27;t&#x27;:\n        return ch == &#x27;\\t&#x27;;\n      case &#x27;v&#x27;:\n        return ch == &#x27;\\v&#x27;;\n      case &#x27;w&#x27;:\n        return IsAsciiWordChar(ch);\n      case &#x27;W&#x27;:\n        return !IsAsciiWordChar(ch);\n    }\n    return IsAsciiPunct(pattern_char) &amp;&amp; pattern_char == ch;\n  }\n\n  return (pattern_char == &#x27;.&#x27; &amp;&amp; ch != &#x27;\\n&#x27;) || pattern_char == ch;\n}\n\n// Helper function used by ValidateRegex() to format error messages.\nstatic std::string FormatRegexSyntaxError(const char* regex, int index) {\n  return (Message() &lt;&lt; &quot;Syntax error at index &quot; &lt;&lt; index\n                    &lt;&lt; &quot; in simple regular expression \\&quot;&quot; &lt;&lt; regex &lt;&lt; &quot;\\&quot;: &quot;)\n      .GetString();\n}\n\n// Generates non-fatal failures and returns false if regex is invalid;\n// otherwise returns true.\nbool ValidateRegex(const char* regex) {\n  if (regex == nullptr) {\n    ADD_FAILURE() &lt;&lt; &quot;NULL is not a valid simple regular expression.&quot;;\n    return false;\n  }\n\n  bool is_valid = true;\n\n  // True if and only if ?, *, or + can follow the previous atom.\n  bool prev_repeatable = false;\n  for (int i = 0; regex[i]; i++) {\n    if (regex[i] == &#x27;\\\\&#x27;) {  // An escape sequence\n      i++;\n      if (regex[i] == &#x27;\\0&#x27;) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)\n                      &lt;&lt; &quot;&#x27;\\\\&#x27; cannot appear at the end.&quot;;\n        return false;\n      }\n\n      if (!IsValidEscape(regex[i])) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)\n                      &lt;&lt; &quot;invalid escape sequence \\&quot;\\\\&quot; &lt;&lt; regex[i] &lt;&lt; &quot;\\&quot;.&quot;;\n        is_valid = false;\n      }\n      prev_repeatable = true;\n    } else {  // Not an escape sequence.\n      const char ch = regex[i];\n\n      if (ch == &#x27;^&#x27; &amp;&amp; i &gt; 0) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)\n                      &lt;&lt; &quot;&#x27;^&#x27; can only appear at the beginning.&quot;;\n        is_valid = false;\n      } else if (ch == &#x27;$&#x27; &amp;&amp; regex[i + 1] != &#x27;\\0&#x27;) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)\n                      &lt;&lt; &quot;&#x27;$&#x27; can only appear at the end.&quot;;\n        is_valid = false;\n      } else if (IsInSet(ch, &quot;()[]{}|&quot;)) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i) &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch\n                      &lt;&lt; &quot;&#x27; is unsupported.&quot;;\n        is_valid = false;\n      } else if (IsRepeat(ch) &amp;&amp; !prev_repeatable) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i) &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch\n                      &lt;&lt; &quot;&#x27; can only follow a repeatable token.&quot;;\n        is_valid = false;\n      }\n\n      prev_repeatable = !IsInSet(ch, &quot;^$?*+&quot;);\n    }\n  }\n\n  return is_valid;\n}\n\n// Matches a repeated regex atom followed by a valid simple regular\n// expression.  The regex atom is defined as c if escaped is false,\n// or \\c otherwise.  repeat is the repetition meta character (?, *,\n// or +).  The behavior is undefined if str contains too many\n// characters to be indexable by size_t, in which case the test will\n// probably time out anyway.  We are fine with this limitation as\n// std::string has it too.\nbool MatchRepetitionAndRegexAtHead(bool escaped, char c, char repeat,\n                                   const char* regex, const char* str) {\n  const size_t min_count = (repeat == &#x27;+&#x27;) ? 1 : 0;\n  const size_t max_count = (repeat == &#x27;?&#x27;) ? 1 : static_cast&lt;size_t&gt;(-1) - 1;\n  // We cannot call numeric_limits::max() as it conflicts with the\n  // max() macro on Windows.\n\n  for (size_t i = 0; i &lt;= max_count; ++i) {\n    // We know that the atom matches each of the first i characters in str.\n    if (i &gt;= min_count &amp;&amp; MatchRegexAtHead(regex, str + i)) {\n      // We have enough matches at the head, and the tail matches too.\n      // Since we only care about *whether* the pattern matches str\n      // (as opposed to *how* it matches), there is no need to find a\n      // greedy match.\n      return true;\n    }\n    if (str[i] == &#x27;\\0&#x27; || !AtomMatchesChar(escaped, c, str[i])) return false;\n  }\n  return false;\n}\n\n// Returns true if and only if regex matches a prefix of str. regex must\n// be a valid simple regular expression and not start with &quot;^&quot;, or the\n// result is undefined.\nbool MatchRegexAtHead(const char* regex, const char* str) {\n  if (*regex == &#x27;\\0&#x27;)  // An empty regex matches a prefix of anything.\n    return true;\n\n  // &quot;$&quot; only matches the end of a string.  Note that regex being\n  // valid guarantees that there&#x27;s nothing after &quot;$&quot; in it.\n  if (*regex == &#x27;$&#x27;) return *str == &#x27;\\0&#x27;;\n\n  // Is the first thing in regex an escape sequence?\n  const bool escaped = *regex == &#x27;\\\\&#x27;;\n  if (escaped) ++regex;\n  if (IsRepeat(regex[1])) {\n    // MatchRepetitionAndRegexAtHead() calls MatchRegexAtHead(), so\n    // here&#x27;s an indirect recursion.  It terminates as the regex gets\n    // shorter in each recursion.\n    return MatchRepetitionAndRegexAtHead(escaped, regex[0], regex[1], regex + 2,\n                                         str);\n  } else {\n    // regex isn&#x27;t empty, isn&#x27;t &quot;$&quot;, and doesn&#x27;t start with a\n    // repetition.  We match the first atom of regex with the first\n    // character of str and recurse.\n    return (*str != &#x27;\\0&#x27;) &amp;&amp; AtomMatchesChar(escaped, *regex, *str) &amp;&amp;\n           MatchRegexAtHead(regex + 1, str + 1);\n  }\n}\n\n// Returns true if and only if regex matches any substring of str.  regex must\n// be a valid simple regular expression, or the result is undefined.\n//\n// The algorithm is recursive, but the recursion depth doesn&#x27;t exceed\n// the regex length, so we won&#x27;t need to worry about running out of\n// stack space normally.  In rare cases the time complexity can be\n// exponential with respect to the regex length + the string length,\n// but usually it&#x27;s must faster (often close to linear).\nbool MatchRegexAnywhere(const char* regex, const char* str) {\n  if (regex == nullptr || str == nullptr) return false;\n\n  if (*regex == &#x27;^&#x27;) return MatchRegexAtHead(regex + 1, str);\n\n  // A successful match can be anywhere in str.\n  do {\n    if (MatchRegexAtHead(regex, str)) return true;\n  } while (*str++ != &#x27;\\0&#x27;);\n  return false;\n}\n\n// Implements the RE class.\n\nRE::~RE() {\n  free(const_cast&lt;char*&gt;(pattern_));\n  free(const_cast&lt;char*&gt;(full_pattern_));\n}\n\n// Returns true if and only if regular expression re matches the entire str.\nbool RE::FullMatch(const char* str, const RE&amp; re) {\n  return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.full_pattern_, str);\n}\n\n// Returns true if and only if regular expression re matches a substring of\n// str (including str itself).\nbool RE::PartialMatch(const char* str, const RE&amp; re) {\n  return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.pattern_, str);\n}\n\n// Initializes an RE from its string representation.\nvoid RE::Init(const char* regex) {\n  pattern_ = full_pattern_ = nullptr;\n  if (regex != nullptr) {\n    pattern_ = posix::StrDup(regex);\n  }\n\n  is_valid_ = ValidateRegex(regex);\n  if (!is_valid_) {\n    // No need to calculate the full pattern when the regex is invalid.\n    return;\n  }\n\n  const size_t len = strlen(regex);\n  // Reserves enough bytes to hold the regular expression used for a\n  // full match: we need space to prepend a &#x27;^&#x27;, append a &#x27;$&#x27;, and\n  // terminate the string with &#x27;\\0&#x27;.\n  char* buffer = static_cast&lt;char*&gt;(malloc(len + 3));\n  full_pattern_ = buffer;\n\n  if (*regex != &#x27;^&#x27;)\n    *buffer++ = &#x27;^&#x27;;  // Makes sure full_pattern_ starts with &#x27;^&#x27;.\n\n  // We don&#x27;t use snprintf or strncpy, as they trigger a warning when\n  // compiled with VC++ 8.0.\n  memcpy(buffer, regex, len);\n  buffer += len;\n\n  if (len == 0 || regex[len - 1] != &#x27;$&#x27;)\n    *buffer++ = &#x27;$&#x27;;  // Makes sure full_pattern_ ends with &#x27;$&#x27;.\n\n  *buffer = &#x27;\\0&#x27;;\n}\n\n#endif  // GTEST_USES_POSIX_RE\n\nconst char kUnknownFile[] = &quot;unknown file&quot;;\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {\n  const std::string file_name(file == nullptr ? kUnknownFile : file);\n\n  if (line &lt; 0) {\n    return file_name + &quot;:&quot;;\n  }\n#ifdef _MSC_VER\n  return file_name + &quot;(&quot; + StreamableToString(line) + &quot;):&quot;;\n#else\n  return file_name + &quot;:&quot; + StreamableToString(line) + &quot;:&quot;;\n#endif  // _MSC_VER\n}\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\n// Note that FormatCompilerIndependentFileLocation() does NOT append colon\n// to the file location it produces, unlike FormatFileLocation().\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line) {\n  const std::string file_name(file == nullptr ? kUnknownFile : file);\n\n  if (line &lt; 0)\n    return file_name;\n  else\n    return file_name + &quot;:&quot; + StreamableToString(line);\n}\n\nGTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)\n    : severity_(severity) {\n  const char* const marker = severity == GTEST_INFO      ? &quot;[  INFO ]&quot;\n                             : severity == GTEST_WARNING ? &quot;[WARNING]&quot;\n                             : severity == GTEST_ERROR   ? &quot;[ ERROR ]&quot;\n                                                         : &quot;[ FATAL ]&quot;;\n  GetStream() &lt;&lt; ::std::endl\n              &lt;&lt; marker &lt;&lt; &quot; &quot; &lt;&lt; FormatFileLocation(file, line).c_str()\n              &lt;&lt; &quot;: &quot;;\n}\n\n// Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\nGTestLog::~GTestLog() {\n  GetStream() &lt;&lt; ::std::endl;\n  if (severity_ == GTEST_FATAL) {\n    fflush(stderr);\n    posix::Abort();\n  }\n}\n\n// Disable Microsoft deprecation warnings for POSIX functions called from\n// this class (creat, dup, dup2, and close)\nGTEST_DISABLE_MSC_DEPRECATED_PUSH_()\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Object that captures an output stream (stdout/stderr).\nclass CapturedStream {\n public:\n  // The ctor redirects the stream to a temporary file.\n  explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {\n#if GTEST_OS_WINDOWS\n    char temp_dir_path[MAX_PATH + 1] = {&#x27;\\0&#x27;};   // NOLINT\n    char temp_file_path[MAX_PATH + 1] = {&#x27;\\0&#x27;};  // NOLINT\n\n    ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);\n    const UINT success = ::GetTempFileNameA(temp_dir_path, &quot;gtest_redir&quot;,\n                                            0,  // Generate unique file name.\n                                            temp_file_path);\n    GTEST_CHECK_(success != 0)\n        &lt;&lt; &quot;Unable to create a temporary file in &quot; &lt;&lt; temp_dir_path;\n    const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);\n    GTEST_CHECK_(captured_fd != -1)\n        &lt;&lt; &quot;Unable to open temporary file &quot; &lt;&lt; temp_file_path;\n    filename_ = temp_file_path;\n#else\n    // There&#x27;s no guarantee that a test has write access to the current\n    // directory, so we create the temporary file in a temporary directory.\n    std::string name_template;\n\n#if GTEST_OS_LINUX_ANDROID\n    // Note: Android applications are expected to call the framework&#x27;s\n    // Context.getExternalStorageDirectory() method through JNI to get\n    // the location of the world-writable SD Card directory. However,\n    // this requires a Context handle, which cannot be retrieved\n    // globally from native code. Doing so also precludes running the\n    // code as part of a regular standalone executable, which doesn&#x27;t\n    // run in a Dalvik process (e.g. when running it through &#x27;adb shell&#x27;).\n    //\n    // The location /data/local/tmp is directly accessible from native code.\n    // &#x27;/sdcard&#x27; and other variants cannot be relied on, as they are not\n    // guaranteed to be mounted, or may have a delay in mounting.\n    name_template = &quot;/data/local/tmp/&quot;;\n#elif GTEST_OS_IOS\n    char user_temp_dir[PATH_MAX + 1];\n\n    // Documented alternative to NSTemporaryDirectory() (for obtaining creating\n    // a temporary directory) at\n    // https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10\n    //\n    // _CS_DARWIN_USER_TEMP_DIR (as well as _CS_DARWIN_USER_CACHE_DIR) is not\n    // documented in the confstr() man page at\n    // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/confstr.3.html#//apple_ref/doc/man/3/confstr\n    // but are still available, according to the WebKit patches at\n    // https://trac.webkit.org/changeset/262004/webkit\n    // https://trac.webkit.org/changeset/263705/webkit\n    //\n    // The confstr() implementation falls back to getenv(&quot;TMPDIR&quot;). See\n    // https://opensource.apple.com/source/Libc/Libc-1439.100.3/gen/confstr.c.auto.html\n    ::confstr(_CS_DARWIN_USER_TEMP_DIR, user_temp_dir, sizeof(user_temp_dir));\n\n    name_template = user_temp_dir;\n    if (name_template.back() != GTEST_PATH_SEP_[0])\n      name_template.push_back(GTEST_PATH_SEP_[0]);\n#else\n    name_template = &quot;/tmp/&quot;;\n#endif\n    name_template.append(&quot;gtest_captured_stream.XXXXXX&quot;);\n\n    // mkstemp() modifies the string bytes in place, and does not go beyond the\n    // string&#x27;s length. This results in well-defined behavior in C++17.\n    //\n    // The const_cast is needed below C++17. The constraints on std::string\n    // implementations in C++11 and above make assumption behind the const_cast\n    // fairly safe.\n    const int captured_fd = ::mkstemp(const_cast&lt;char*&gt;(name_template.data()));\n    if (captured_fd == -1) {\n      GTEST_LOG_(WARNING)\n          &lt;&lt; &quot;Failed to create tmp file &quot; &lt;&lt; name_template\n          &lt;&lt; &quot; for test; does the test have access to the /tmp directory?&quot;;\n    }\n    filename_ = std::move(name_template);\n#endif  // GTEST_OS_WINDOWS\n    fflush(nullptr);\n    dup2(captured_fd, fd_);\n    close(captured_fd);\n  }\n\n  ~CapturedStream() { remove(filename_.c_str()); }\n\n  std::string GetCapturedString() {\n    if (uncaptured_fd_ != -1) {\n      // Restores the original stream.\n      fflush(nullptr);\n      dup2(uncaptured_fd_, fd_);\n      close(uncaptured_fd_);\n      uncaptured_fd_ = -1;\n    }\n\n    FILE* const file = posix::FOpen(filename_.c_str(), &quot;r&quot;);\n    if (file == nullptr) {\n      GTEST_LOG_(FATAL) &lt;&lt; &quot;Failed to open tmp file &quot; &lt;&lt; filename_\n                        &lt;&lt; &quot; for capturing stream.&quot;;\n    }\n    const std::string content = ReadEntireFile(file);\n    posix::FClose(file);\n    return content;\n  }\n\n private:\n  const int fd_;  // A stream to capture.\n  int uncaptured_fd_;\n  // Name of the temporary file holding the stderr output.\n  ::std::string filename_;\n\n  CapturedStream(const CapturedStream&amp;) = delete;\n  CapturedStream&amp; operator=(const CapturedStream&amp;) = delete;\n};\n\nGTEST_DISABLE_MSC_DEPRECATED_POP_()\n\nstatic CapturedStream* g_captured_stderr = nullptr;\nstatic CapturedStream* g_captured_stdout = nullptr;\n\n// Starts capturing an output stream (stdout/stderr).\nstatic void CaptureStream(int fd, const char* stream_name,\n                          CapturedStream** stream) {\n  if (*stream != nullptr) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Only one &quot; &lt;&lt; stream_name\n                      &lt;&lt; &quot; capturer can exist at a time.&quot;;\n  }\n  *stream = new CapturedStream(fd);\n}\n\n// Stops capturing the output stream and returns the captured string.\nstatic std::string GetCapturedStream(CapturedStream** captured_stream) {\n  const std::string content = (*captured_stream)-&gt;GetCapturedString();\n\n  delete *captured_stream;\n  *captured_stream = nullptr;\n\n  return content;\n}\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC and C++Builder do not provide a definition of STDERR_FILENO.\nconst int kStdOutFileno = 1;\nconst int kStdErrFileno = 2;\n#else\nconst int kStdOutFileno = STDOUT_FILENO;\nconst int kStdErrFileno = STDERR_FILENO;\n#endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n\n// Starts capturing stdout.\nvoid CaptureStdout() {\n  CaptureStream(kStdOutFileno, &quot;stdout&quot;, &amp;g_captured_stdout);\n}\n\n// Starts capturing stderr.\nvoid CaptureStderr() {\n  CaptureStream(kStdErrFileno, &quot;stderr&quot;, &amp;g_captured_stderr);\n}\n\n// Stops capturing stdout and returns the captured string.\nstd::string GetCapturedStdout() {\n  return GetCapturedStream(&amp;g_captured_stdout);\n}\n\n// Stops capturing stderr and returns the captured string.\nstd::string GetCapturedStderr() {\n  return GetCapturedStream(&amp;g_captured_stderr);\n}\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\nsize_t GetFileSize(FILE* file) {\n  fseek(file, 0, SEEK_END);\n  return static_cast&lt;size_t&gt;(ftell(file));\n}\n\nstd::string ReadEntireFile(FILE* file) {\n  const size_t file_size = GetFileSize(file);\n  char* const buffer = new char[file_size];\n\n  size_t bytes_last_read = 0;  // # of bytes read in the last fread()\n  size_t bytes_read = 0;       // # of bytes read so far\n\n  fseek(file, 0, SEEK_SET);\n\n  // Keeps reading the file until we cannot read further or the\n  // pre-determined file size is reached.\n  do {\n    bytes_last_read =\n        fread(buffer + bytes_read, 1, file_size - bytes_read, file);\n    bytes_read += bytes_last_read;\n  } while (bytes_last_read &gt; 0 &amp;&amp; bytes_read &lt; file_size);\n\n  const std::string content(buffer, bytes_read);\n  delete[] buffer;\n\n  return content;\n}\n\n#if GTEST_HAS_DEATH_TEST\nstatic const std::vector&lt;std::string&gt;* g_injected_test_argvs =\n    nullptr;  // Owned.\n\nstd::vector&lt;std::string&gt; GetInjectableArgvs() {\n  if (g_injected_test_argvs != nullptr) {\n    return *g_injected_test_argvs;\n  }\n  return GetArgvs();\n}\n\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;* new_argvs) {\n  if (g_injected_test_argvs != new_argvs) delete g_injected_test_argvs;\n  g_injected_test_argvs = new_argvs;\n}\n\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;&amp; new_argvs) {\n  SetInjectableArgvs(\n      new std::vector&lt;std::string&gt;(new_argvs.begin(), new_argvs.end()));\n}\n\nvoid ClearInjectableArgvs() {\n  delete g_injected_test_argvs;\n  g_injected_test_argvs = nullptr;\n}\n#endif  // GTEST_HAS_DEATH_TEST\n\n#if GTEST_OS_WINDOWS_MOBILE\nnamespace posix {\nvoid Abort() {\n  DebugBreak();\n  TerminateProcess(GetCurrentProcess(), 1);\n}\n}  // namespace posix\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n// Returns the name of the environment variable corresponding to the\n// given flag.  For example, FlagToEnvVar(&quot;foo&quot;) will return\n// &quot;GTEST_FOO&quot; in the open-source version.\nstatic std::string FlagToEnvVar(const char* flag) {\n  const std::string full_flag =\n      (Message() &lt;&lt; GTEST_FLAG_PREFIX_ &lt;&lt; flag).GetString();\n\n  Message env_var;\n  for (size_t i = 0; i != full_flag.length(); i++) {\n    env_var &lt;&lt; ToUpper(full_flag.c_str()[i]);\n  }\n\n  return env_var.GetString();\n}\n\n// Parses &#x27;str&#x27; for a 32-bit signed integer.  If successful, writes\n// the result to *value and returns true; otherwise leaves *value\n// unchanged and returns false.\nbool ParseInt32(const Message&amp; src_text, const char* str, int32_t* value) {\n  // Parses the environment variable as a decimal integer.\n  char* end = nullptr;\n  const long long_value = strtol(str, &amp;end, 10);  // NOLINT\n\n  // Has strtol() consumed all characters in the string?\n  if (*end != &#x27;\\0&#x27;) {\n    // No - an invalid character was encountered.\n    Message msg;\n    msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text\n        &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot;\n        &lt;&lt; &quot; has value \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;.\\n&quot;;\n    printf(&quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    return false;\n  }\n\n  // Is the parsed value in the range of an int32_t?\n  const auto result = static_cast&lt;int32_t&gt;(long_value);\n  if (long_value == LONG_MAX || long_value == LONG_MIN ||\n      // The parsed value overflows as a long.  (strtol() returns\n      // LONG_MAX or LONG_MIN when the input overflows.)\n      result != long_value\n      // The parsed value overflows as an int32_t.\n  ) {\n    Message msg;\n    msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text\n        &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot;\n        &lt;&lt; &quot; has value &quot; &lt;&lt; str &lt;&lt; &quot;, which overflows.\\n&quot;;\n    printf(&quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    return false;\n  }\n\n  *value = result;\n  return true;\n}\n\n// Reads and returns the Boolean environment variable corresponding to\n// the given flag; if it&#x27;s not set, returns default_value.\n//\n// The value is considered true if and only if it&#x27;s not &quot;0&quot;.\nbool BoolFromGTestEnv(const char* flag, bool default_value) {\n#if defined(GTEST_GET_BOOL_FROM_ENV_)\n  return GTEST_GET_BOOL_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const string_value = posix::GetEnv(env_var.c_str());\n  return string_value == nullptr ? default_value\n                                 : strcmp(string_value, &quot;0&quot;) != 0;\n#endif  // defined(GTEST_GET_BOOL_FROM_ENV_)\n}\n\n// Reads and returns a 32-bit integer stored in the environment\n// variable corresponding to the given flag; if it isn&#x27;t set or\n// doesn&#x27;t represent a valid 32-bit integer, returns default_value.\nint32_t Int32FromGTestEnv(const char* flag, int32_t default_value) {\n#if defined(GTEST_GET_INT32_FROM_ENV_)\n  return GTEST_GET_INT32_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const string_value = posix::GetEnv(env_var.c_str());\n  if (string_value == nullptr) {\n    // The environment variable is not set.\n    return default_value;\n  }\n\n  int32_t result = default_value;\n  if (!ParseInt32(Message() &lt;&lt; &quot;Environment variable &quot; &lt;&lt; env_var, string_value,\n                  &amp;result)) {\n    printf(&quot;The default value %s is used.\\n&quot;,\n           (Message() &lt;&lt; default_value).GetString().c_str());\n    fflush(stdout);\n    return default_value;\n  }\n\n  return result;\n#endif  // defined(GTEST_GET_INT32_FROM_ENV_)\n}\n\n// As a special case for the &#x27;output&#x27; flag, if GTEST_OUTPUT is not\n// set, we look for XML_OUTPUT_FILE, which is set by the Bazel build\n// system.  The value of XML_OUTPUT_FILE is a filename without the\n// &quot;xml:&quot; prefix of GTEST_OUTPUT.\n// Note that this is meant to be called at the call site so it does\n// not check that the flag is &#x27;output&#x27;\n// In essence this checks an env variable called XML_OUTPUT_FILE\n// and if it is set we prepend &quot;xml:&quot; to its value, if it not set we return &quot;&quot;\nstd::string OutputFlagAlsoCheckEnvVar() {\n  std::string default_value_for_output_flag = &quot;&quot;;\n  const char* xml_output_file_env = posix::GetEnv(&quot;XML_OUTPUT_FILE&quot;);\n  if (nullptr != xml_output_file_env) {\n    default_value_for_output_flag = std::string(&quot;xml:&quot;) + xml_output_file_env;\n  }\n  return default_value_for_output_flag;\n}\n\n// Reads and returns the string environment variable corresponding to\n// the given flag; if it&#x27;s not set, returns default_value.\nconst char* StringFromGTestEnv(const char* flag, const char* default_value) {\n#if defined(GTEST_GET_STRING_FROM_ENV_)\n  return GTEST_GET_STRING_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const value = posix::GetEnv(env_var.c_str());\n  return value == nullptr ? default_value : value;\n#endif  // defined(GTEST_GET_STRING_FROM_ENV_)\n}\n\n}  // namespace internal\n}  // namespace testing\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Test - The Google C++ Testing and Mocking Framework\n//\n// This file implements a universal value printer that can print a\n// value of any type T:\n//\n//   void ::testing::internal::UniversalPrinter&lt;T&gt;::Print(value, ostream_ptr);\n//\n// It uses the &lt;&lt; operator when possible, and prints the bytes in the\n// object otherwise.  A user can override its behavior for a class\n// type Foo by defining either operator&lt;&lt;(::std::ostream&amp;, const Foo&amp;)\n// or void PrintTo(const Foo&amp;, ::std::ostream*) in the namespace that\n// defines Foo.\n\n#include &quot;gtest/gtest-printers.h&quot;\n\n#include &lt;stdio.h&gt;\n\n#include &lt;cctype&gt;\n#include &lt;cstdint&gt;\n#include &lt;cwchar&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n#include &quot;src/gtest-internal-inl.h&quot;\n\nnamespace testing {\n\nnamespace {\n\nusing ::std::ostream;\n\n// Prints a segment of bytes in the given object.\nGTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\nGTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\nvoid PrintByteSegmentInObjectTo(const unsigned char* obj_bytes, size_t start,\n                                size_t count, ostream* os) {\n  char text[5] = &quot;&quot;;\n  for (size_t i = 0; i != count; i++) {\n    const size_t j = start + i;\n    if (i != 0) {\n      // Organizes the bytes into groups of 2 for easy parsing by\n      // human.\n      if ((j % 2) == 0)\n        *os &lt;&lt; &#x27; &#x27;;\n      else\n        *os &lt;&lt; &#x27;-&#x27;;\n    }\n    GTEST_SNPRINTF_(text, sizeof(text), &quot;%02X&quot;, obj_bytes[j]);\n    *os &lt;&lt; text;\n  }\n}\n\n// Prints the bytes in the given value to the given ostream.\nvoid PrintBytesInObjectToImpl(const unsigned char* obj_bytes, size_t count,\n                              ostream* os) {\n  // Tells the user how big the object is.\n  *os &lt;&lt; count &lt;&lt; &quot;-byte object &lt;&quot;;\n\n  const size_t kThreshold = 132;\n  const size_t kChunkSize = 64;\n  // If the object size is bigger than kThreshold, we&#x27;ll have to omit\n  // some details by printing only the first and the last kChunkSize\n  // bytes.\n  if (count &lt; kThreshold) {\n    PrintByteSegmentInObjectTo(obj_bytes, 0, count, os);\n  } else {\n    PrintByteSegmentInObjectTo(obj_bytes, 0, kChunkSize, os);\n    *os &lt;&lt; &quot; ... &quot;;\n    // Rounds up to 2-byte boundary.\n    const size_t resume_pos = (count - kChunkSize + 1) / 2 * 2;\n    PrintByteSegmentInObjectTo(obj_bytes, resume_pos, count - resume_pos, os);\n  }\n  *os &lt;&lt; &quot;&gt;&quot;;\n}\n\n// Helpers for widening a character to char32_t. Since the standard does not\n// specify if char / wchar_t is signed or unsigned, it is important to first\n// convert it to the unsigned type of the same width before widening it to\n// char32_t.\ntemplate &lt;typename CharType&gt;\nchar32_t ToChar32(CharType in) {\n  return static_cast&lt;char32_t&gt;(\n      static_cast&lt;typename std::make_unsigned&lt;CharType&gt;::type&gt;(in));\n}\n\n}  // namespace\n\nnamespace internal {\n\n// Delegates to PrintBytesInObjectToImpl() to print the bytes in the\n// given object.  The delegation simplifies the implementation, which\n// uses the &lt;&lt; operator and thus is easier done outside of the\n// ::testing::internal namespace, which contains a &lt;&lt; operator that\n// sometimes conflicts with the one in STL.\nvoid PrintBytesInObjectTo(const unsigned char* obj_bytes, size_t count,\n                          ostream* os) {\n  PrintBytesInObjectToImpl(obj_bytes, count, os);\n}\n\n// Depending on the value of a char (or wchar_t), we print it in one\n// of three formats:\n//   - as is if it&#x27;s a printable ASCII (e.g. &#x27;a&#x27;, &#x27;2&#x27;, &#x27; &#x27;),\n//   - as a hexadecimal escape sequence (e.g. &#x27;\\x7F&#x27;), or\n//   - as a special escape sequence (e.g. &#x27;\\r&#x27;, &#x27;\\n&#x27;).\nenum CharFormat { kAsIs, kHexEscape, kSpecialEscape };\n\n// Returns true if c is a printable ASCII character.  We test the\n// value of c directly instead of calling isprint(), which is buggy on\n// Windows Mobile.\ninline bool IsPrintableAscii(char32_t c) { return 0x20 &lt;= c &amp;&amp; c &lt;= 0x7E; }\n\n// Prints c (of type char, char8_t, char16_t, char32_t, or wchar_t) as a\n// character literal without the quotes, escaping it when necessary; returns how\n// c was formatted.\ntemplate &lt;typename Char&gt;\nstatic CharFormat PrintAsCharLiteralTo(Char c, ostream* os) {\n  const char32_t u_c = ToChar32(c);\n  switch (u_c) {\n    case L&#x27;\\0&#x27;:\n      *os &lt;&lt; &quot;\\\\0&quot;;\n      break;\n    case L&#x27;\\&#x27;&#x27;:\n      *os &lt;&lt; &quot;\\\\&#x27;&quot;;\n      break;\n    case L&#x27;\\\\&#x27;:\n      *os &lt;&lt; &quot;\\\\\\\\&quot;;\n      break;\n    case L&#x27;\\a&#x27;:\n      *os &lt;&lt; &quot;\\\\a&quot;;\n      break;\n    case L&#x27;\\b&#x27;:\n      *os &lt;&lt; &quot;\\\\b&quot;;\n      break;\n    case L&#x27;\\f&#x27;:\n      *os &lt;&lt; &quot;\\\\f&quot;;\n      break;\n    case L&#x27;\\n&#x27;:\n      *os &lt;&lt; &quot;\\\\n&quot;;\n      break;\n    case L&#x27;\\r&#x27;:\n      *os &lt;&lt; &quot;\\\\r&quot;;\n      break;\n    case L&#x27;\\t&#x27;:\n      *os &lt;&lt; &quot;\\\\t&quot;;\n      break;\n    case L&#x27;\\v&#x27;:\n      *os &lt;&lt; &quot;\\\\v&quot;;\n      break;\n    default:\n      if (IsPrintableAscii(u_c)) {\n        *os &lt;&lt; static_cast&lt;char&gt;(c);\n        return kAsIs;\n      } else {\n        ostream::fmtflags flags = os-&gt;flags();\n        *os &lt;&lt; &quot;\\\\x&quot; &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(u_c);\n        os-&gt;flags(flags);\n        return kHexEscape;\n      }\n  }\n  return kSpecialEscape;\n}\n\n// Prints a char32_t c as if it&#x27;s part of a string literal, escaping it when\n// necessary; returns how c was formatted.\nstatic CharFormat PrintAsStringLiteralTo(char32_t c, ostream* os) {\n  switch (c) {\n    case L&#x27;\\&#x27;&#x27;:\n      *os &lt;&lt; &quot;&#x27;&quot;;\n      return kAsIs;\n    case L&#x27;&quot;&#x27;:\n      *os &lt;&lt; &quot;\\\\\\&quot;&quot;;\n      return kSpecialEscape;\n    default:\n      return PrintAsCharLiteralTo(c, os);\n  }\n}\n\nstatic const char* GetCharWidthPrefix(char) { return &quot;&quot;; }\n\nstatic const char* GetCharWidthPrefix(signed char) { return &quot;&quot;; }\n\nstatic const char* GetCharWidthPrefix(unsigned char) { return &quot;&quot;; }\n\n#ifdef __cpp_char8_t\nstatic const char* GetCharWidthPrefix(char8_t) { return &quot;u8&quot;; }\n#endif\n\nstatic const char* GetCharWidthPrefix(char16_t) { return &quot;u&quot;; }\n\nstatic const char* GetCharWidthPrefix(char32_t) { return &quot;U&quot;; }\n\nstatic const char* GetCharWidthPrefix(wchar_t) { return &quot;L&quot;; }\n\n// Prints a char c as if it&#x27;s part of a string literal, escaping it when\n// necessary; returns how c was formatted.\nstatic CharFormat PrintAsStringLiteralTo(char c, ostream* os) {\n  return PrintAsStringLiteralTo(ToChar32(c), os);\n}\n\n#ifdef __cpp_char8_t\nstatic CharFormat PrintAsStringLiteralTo(char8_t c, ostream* os) {\n  return PrintAsStringLiteralTo(ToChar32(c), os);\n}\n#endif\n\nstatic CharFormat PrintAsStringLiteralTo(char16_t c, ostream* os) {\n  return PrintAsStringLiteralTo(ToChar32(c), os);\n}\n\nstatic CharFormat PrintAsStringLiteralTo(wchar_t c, ostream* os) {\n  return PrintAsStringLiteralTo(ToChar32(c), os);\n}\n\n// Prints a character c (of type char, char8_t, char16_t, char32_t, or wchar_t)\n// and its code. &#x27;\\0&#x27; is printed as &quot;&#x27;\\\\0&#x27;&quot;, other unprintable characters are\n// also properly escaped using the standard C++ escape sequence.\ntemplate &lt;typename Char&gt;\nvoid PrintCharAndCodeTo(Char c, ostream* os) {\n  // First, print c as a literal in the most readable form we can find.\n  *os &lt;&lt; GetCharWidthPrefix(c) &lt;&lt; &quot;&#x27;&quot;;\n  const CharFormat format = PrintAsCharLiteralTo(c, os);\n  *os &lt;&lt; &quot;&#x27;&quot;;\n\n  // To aid user debugging, we also print c&#x27;s code in decimal, unless\n  // it&#x27;s 0 (in which case c was printed as &#x27;\\\\0&#x27;, making the code\n  // obvious).\n  if (c == 0) return;\n  *os &lt;&lt; &quot; (&quot; &lt;&lt; static_cast&lt;int&gt;(c);\n\n  // For more convenience, we print c&#x27;s code again in hexadecimal,\n  // unless c was already printed in the form &#x27;\\x##&#x27; or the code is in\n  // [1, 9].\n  if (format == kHexEscape || (1 &lt;= c &amp;&amp; c &lt;= 9)) {\n    // Do nothing.\n  } else {\n    *os &lt;&lt; &quot;, 0x&quot; &lt;&lt; String::FormatHexInt(static_cast&lt;int&gt;(c));\n  }\n  *os &lt;&lt; &quot;)&quot;;\n}\n\nvoid PrintTo(unsigned char c, ::std::ostream* os) { PrintCharAndCodeTo(c, os); }\nvoid PrintTo(signed char c, ::std::ostream* os) { PrintCharAndCodeTo(c, os); }\n\n// Prints a wchar_t as a symbol if it is printable or as its internal\n// code otherwise and also as its code.  L&#x27;\\0&#x27; is printed as &quot;L&#x27;\\\\0&#x27;&quot;.\nvoid PrintTo(wchar_t wc, ostream* os) { PrintCharAndCodeTo(wc, os); }\n\n// TODO(dcheng): Consider making this delegate to PrintCharAndCodeTo() as well.\nvoid PrintTo(char32_t c, ::std::ostream* os) {\n  *os &lt;&lt; std::hex &lt;&lt; &quot;U+&quot; &lt;&lt; std::uppercase &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(4)\n      &lt;&lt; static_cast&lt;uint32_t&gt;(c);\n}\n\n// gcc/clang __{u,}int128_t\n#if defined(__SIZEOF_INT128__)\nvoid PrintTo(__uint128_t v, ::std::ostream* os) {\n  if (v == 0) {\n    *os &lt;&lt; &quot;0&quot;;\n    return;\n  }\n\n  // Buffer large enough for ceil(log10(2^128))==39 and the null terminator\n  char buf[40];\n  char* p = buf + sizeof(buf);\n\n  // Some configurations have a __uint128_t, but no support for built in\n  // division. Do manual long division instead.\n\n  uint64_t high = static_cast&lt;uint64_t&gt;(v &gt;&gt; 64);\n  uint64_t low = static_cast&lt;uint64_t&gt;(v);\n\n  *--p = 0;\n  while (high != 0 || low != 0) {\n    uint64_t high_mod = high % 10;\n    high = high / 10;\n    // This is the long division algorithm specialized for a divisor of 10 and\n    // only two elements.\n    // Notable values:\n    //   2^64 / 10 == 1844674407370955161\n    //   2^64 % 10 == 6\n    const uint64_t carry = 6 * high_mod + low % 10;\n    low = low / 10 + high_mod * 1844674407370955161 + carry / 10;\n\n    char digit = static_cast&lt;char&gt;(carry % 10);\n    *--p = &#x27;0&#x27; + digit;\n  }\n  *os &lt;&lt; p;\n}\nvoid PrintTo(__int128_t v, ::std::ostream* os) {\n  __uint128_t uv = static_cast&lt;__uint128_t&gt;(v);\n  if (v &lt; 0) {\n    *os &lt;&lt; &quot;-&quot;;\n    uv = -uv;\n  }\n  PrintTo(uv, os);\n}\n#endif  // __SIZEOF_INT128__\n\n// Prints the given array of characters to the ostream.  CharType must be either\n// char, char8_t, char16_t, char32_t, or wchar_t.\n// The array starts at begin, the length is len, it may include &#x27;\\0&#x27; characters\n// and may not be NUL-terminated.\ntemplate &lt;typename CharType&gt;\nGTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n    GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n        GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ static CharFormat\n        PrintCharsAsStringTo(const CharType* begin, size_t len, ostream* os) {\n  const char* const quote_prefix = GetCharWidthPrefix(*begin);\n  *os &lt;&lt; quote_prefix &lt;&lt; &quot;\\&quot;&quot;;\n  bool is_previous_hex = false;\n  CharFormat print_format = kAsIs;\n  for (size_t index = 0; index &lt; len; ++index) {\n    const CharType cur = begin[index];\n    if (is_previous_hex &amp;&amp; IsXDigit(cur)) {\n      // Previous character is of &#x27;\\x..&#x27; form and this character can be\n      // interpreted as another hexadecimal digit in its number. Break string to\n      // disambiguate.\n      *os &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; quote_prefix &lt;&lt; &quot;\\&quot;&quot;;\n    }\n    is_previous_hex = PrintAsStringLiteralTo(cur, os) == kHexEscape;\n    // Remember if any characters required hex escaping.\n    if (is_previous_hex) {\n      print_format = kHexEscape;\n    }\n  }\n  *os &lt;&lt; &quot;\\&quot;&quot;;\n  return print_format;\n}\n\n// Prints a (const) char/wchar_t array of &#x27;len&#x27; elements, starting at address\n// &#x27;begin&#x27;.  CharType must be either char or wchar_t.\ntemplate &lt;typename CharType&gt;\nGTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n    GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n        GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ static void\n        UniversalPrintCharArray(const CharType* begin, size_t len,\n                                ostream* os) {\n  // The code\n  //   const char kFoo[] = &quot;foo&quot;;\n  // generates an array of 4, not 3, elements, with the last one being &#x27;\\0&#x27;.\n  //\n  // Therefore when printing a char array, we don&#x27;t print the last element if\n  // it&#x27;s &#x27;\\0&#x27;, such that the output matches the string literal as it&#x27;s\n  // written in the source code.\n  if (len &gt; 0 &amp;&amp; begin[len - 1] == &#x27;\\0&#x27;) {\n    PrintCharsAsStringTo(begin, len - 1, os);\n    return;\n  }\n\n  // If, however, the last element in the array is not &#x27;\\0&#x27;, e.g.\n  //    const char kFoo[] = { &#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27; };\n  // we must print the entire array.  We also print a message to indicate\n  // that the array is not NUL-terminated.\n  PrintCharsAsStringTo(begin, len, os);\n  *os &lt;&lt; &quot; (no terminating NUL)&quot;;\n}\n\n// Prints a (const) char array of &#x27;len&#x27; elements, starting at address &#x27;begin&#x27;.\nvoid UniversalPrintArray(const char* begin, size_t len, ostream* os) {\n  UniversalPrintCharArray(begin, len, os);\n}\n\n#ifdef __cpp_char8_t\n// Prints a (const) char8_t array of &#x27;len&#x27; elements, starting at address\n// &#x27;begin&#x27;.\nvoid UniversalPrintArray(const char8_t* begin, size_t len, ostream* os) {\n  UniversalPrintCharArray(begin, len, os);\n}\n#endif\n\n// Prints a (const) char16_t array of &#x27;len&#x27; elements, starting at address\n// &#x27;begin&#x27;.\nvoid UniversalPrintArray(const char16_t* begin, size_t len, ostream* os) {\n  UniversalPrintCharArray(begin, len, os);\n}\n\n// Prints a (const) char32_t array of &#x27;len&#x27; elements, starting at address\n// &#x27;begin&#x27;.\nvoid UniversalPrintArray(const char32_t* begin, size_t len, ostream* os) {\n  UniversalPrintCharArray(begin, len, os);\n}\n\n// Prints a (const) wchar_t array of &#x27;len&#x27; elements, starting at address\n// &#x27;begin&#x27;.\nvoid UniversalPrintArray(const wchar_t* begin, size_t len, ostream* os) {\n  UniversalPrintCharArray(begin, len, os);\n}\n\nnamespace {\n\n// Prints a null-terminated C-style string to the ostream.\ntemplate &lt;typename Char&gt;\nvoid PrintCStringTo(const Char* s, ostream* os) {\n  if (s == nullptr) {\n    *os &lt;&lt; &quot;NULL&quot;;\n  } else {\n    *os &lt;&lt; ImplicitCast_&lt;const void*&gt;(s) &lt;&lt; &quot; pointing to &quot;;\n    PrintCharsAsStringTo(s, std::char_traits&lt;Char&gt;::length(s), os);\n  }\n}\n\n}  // anonymous namespace\n\nvoid PrintTo(const char* s, ostream* os) { PrintCStringTo(s, os); }\n\n#ifdef __cpp_char8_t\nvoid PrintTo(const char8_t* s, ostream* os) { PrintCStringTo(s, os); }\n#endif\n\nvoid PrintTo(const char16_t* s, ostream* os) { PrintCStringTo(s, os); }\n\nvoid PrintTo(const char32_t* s, ostream* os) { PrintCStringTo(s, os); }\n\n// MSVC compiler can be configured to define whar_t as a typedef\n// of unsigned short. Defining an overload for const wchar_t* in that case\n// would cause pointers to unsigned shorts be printed as wide strings,\n// possibly accessing more memory than intended and causing invalid\n// memory accesses. MSVC defines _NATIVE_WCHAR_T_DEFINED symbol when\n// wchar_t is implemented as a native type.\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n// Prints the given wide C string to the ostream.\nvoid PrintTo(const wchar_t* s, ostream* os) { PrintCStringTo(s, os); }\n#endif  // wchar_t is native\n\nnamespace {\n\nbool ContainsUnprintableControlCodes(const char* str, size_t length) {\n  const unsigned char* s = reinterpret_cast&lt;const unsigned char*&gt;(str);\n\n  for (size_t i = 0; i &lt; length; i++) {\n    unsigned char ch = *s++;\n    if (std::iscntrl(ch)) {\n      switch (ch) {\n        case &#x27;\\t&#x27;:\n        case &#x27;\\n&#x27;:\n        case &#x27;\\r&#x27;:\n          break;\n        default:\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool IsUTF8TrailByte(unsigned char t) { return 0x80 &lt;= t &amp;&amp; t &lt;= 0xbf; }\n\nbool IsValidUTF8(const char* str, size_t length) {\n  const unsigned char* s = reinterpret_cast&lt;const unsigned char*&gt;(str);\n\n  for (size_t i = 0; i &lt; length;) {\n    unsigned char lead = s[i++];\n\n    if (lead &lt;= 0x7f) {\n      continue;  // single-byte character (ASCII) 0..7F\n    }\n    if (lead &lt; 0xc2) {\n      return false;  // trail byte or non-shortest form\n    } else if (lead &lt;= 0xdf &amp;&amp; (i + 1) &lt;= length &amp;&amp; IsUTF8TrailByte(s[i])) {\n      ++i;  // 2-byte character\n    } else if (0xe0 &lt;= lead &amp;&amp; lead &lt;= 0xef &amp;&amp; (i + 2) &lt;= length &amp;&amp;\n               IsUTF8TrailByte(s[i]) &amp;&amp; IsUTF8TrailByte(s[i + 1]) &amp;&amp;\n               // check for non-shortest form and surrogate\n               (lead != 0xe0 || s[i] &gt;= 0xa0) &amp;&amp;\n               (lead != 0xed || s[i] &lt; 0xa0)) {\n      i += 2;  // 3-byte character\n    } else if (0xf0 &lt;= lead &amp;&amp; lead &lt;= 0xf4 &amp;&amp; (i + 3) &lt;= length &amp;&amp;\n               IsUTF8TrailByte(s[i]) &amp;&amp; IsUTF8TrailByte(s[i + 1]) &amp;&amp;\n               IsUTF8TrailByte(s[i + 2]) &amp;&amp;\n               // check for non-shortest form\n               (lead != 0xf0 || s[i] &gt;= 0x90) &amp;&amp;\n               (lead != 0xf4 || s[i] &lt; 0x90)) {\n      i += 3;  // 4-byte character\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid ConditionalPrintAsText(const char* str, size_t length, ostream* os) {\n  if (!ContainsUnprintableControlCodes(str, length) &amp;&amp;\n      IsValidUTF8(str, length)) {\n    *os &lt;&lt; &quot;\\n    As Text: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;&quot;;\n  }\n}\n\n}  // anonymous namespace\n\nvoid PrintStringTo(const ::std::string&amp; s, ostream* os) {\n  if (PrintCharsAsStringTo(s.data(), s.size(), os) == kHexEscape) {\n    if (GTEST_FLAG_GET(print_utf8)) {\n      ConditionalPrintAsText(s.data(), s.size(), os);\n    }\n  }\n}\n\n#ifdef __cpp_char8_t\nvoid PrintU8StringTo(const ::std::u8string&amp; s, ostream* os) {\n  PrintCharsAsStringTo(s.data(), s.size(), os);\n}\n#endif\n\nvoid PrintU16StringTo(const ::std::u16string&amp; s, ostream* os) {\n  PrintCharsAsStringTo(s.data(), s.size(), os);\n}\n\nvoid PrintU32StringTo(const ::std::u32string&amp; s, ostream* os) {\n  PrintCharsAsStringTo(s.data(), s.size(), os);\n}\n\n#if GTEST_HAS_STD_WSTRING\nvoid PrintWideStringTo(const ::std::wstring&amp; s, ostream* os) {\n  PrintCharsAsStringTo(s.data(), s.size(), os);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n}  // namespace internal\n\n}  // namespace testing\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include &quot;gtest/gtest-typed-test.h&quot;\n\n#include &quot;gtest/gtest.h&quot;\n\nnamespace testing {\nnamespace internal {\n\n// Skips to the first non-space char in str. Returns an empty string if str\n// contains only whitespace characters.\nstatic const char* SkipSpaces(const char* str) {\n  while (IsSpace(*str)) str++;\n  return str;\n}\n\nstatic std::vector&lt;std::string&gt; SplitIntoTestNames(const char* src) {\n  std::vector&lt;std::string&gt; name_vec;\n  src = SkipSpaces(src);\n  for (; src != nullptr; src = SkipComma(src)) {\n    name_vec.push_back(StripTrailingSpaces(GetPrefixUntilComma(src)));\n  }\n  return name_vec;\n}\n\n// Verifies that registered_tests match the test names in\n// registered_tests_; returns registered_tests if successful, or\n// aborts the program otherwise.\nconst char* TypedTestSuitePState::VerifyRegisteredTestNames(\n    const char* test_suite_name, const char* file, int line,\n    const char* registered_tests) {\n  RegisterTypeParameterizedTestSuite(test_suite_name, CodeLocation(file, line));\n\n  typedef RegisteredTestsMap::const_iterator RegisteredTestIter;\n  registered_ = true;\n\n  std::vector&lt;std::string&gt; name_vec = SplitIntoTestNames(registered_tests);\n\n  Message errors;\n\n  std::set&lt;std::string&gt; tests;\n  for (std::vector&lt;std::string&gt;::const_iterator name_it = name_vec.begin();\n       name_it != name_vec.end(); ++name_it) {\n    const std::string&amp; name = *name_it;\n    if (tests.count(name) != 0) {\n      errors &lt;&lt; &quot;Test &quot; &lt;&lt; name &lt;&lt; &quot; is listed more than once.\\n&quot;;\n      continue;\n    }\n\n    if (registered_tests_.count(name) != 0) {\n      tests.insert(name);\n    } else {\n      errors &lt;&lt; &quot;No test named &quot; &lt;&lt; name\n             &lt;&lt; &quot; can be found in this test suite.\\n&quot;;\n    }\n  }\n\n  for (RegisteredTestIter it = registered_tests_.begin();\n       it != registered_tests_.end(); ++it) {\n    if (tests.count(it-&gt;first) == 0) {\n      errors &lt;&lt; &quot;You forgot to list test &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;.\\n&quot;;\n    }\n  }\n\n  const std::string&amp; errors_str = errors.GetString();\n  if (errors_str != &quot;&quot;) {\n    fprintf(stderr, &quot;%s %s&quot;, FormatFileLocation(file, line).c_str(),\n            errors_str.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n\n  return registered_tests;\n}\n\n}  // namespace internal\n}  // namespace testing\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n//\n// The Google C++ Testing and Mocking Framework (Google Test)\n\n#include &quot;gtest/gtest.h&quot;\n\n#include &lt;ctype.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;wchar.h&gt;\n#include &lt;wctype.h&gt;\n\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;  // NOLINT\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iomanip&gt;\n#include &lt;iterator&gt;\n#include &lt;limits&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;sstream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-assertion-result.h&quot;\n#include &quot;gtest/gtest-spi.h&quot;\n#include &quot;gtest/internal/custom/gtest.h&quot;\n\n#if GTEST_OS_LINUX\n\n#include &lt;fcntl.h&gt;   // NOLINT\n#include &lt;limits.h&gt;  // NOLINT\n#include &lt;sched.h&gt;   // NOLINT\n// Declares vsnprintf().  This header is not available on Windows.\n#include &lt;strings.h&gt;   // NOLINT\n#include &lt;sys/mman.h&gt;  // NOLINT\n#include &lt;sys/time.h&gt;  // NOLINT\n#include &lt;unistd.h&gt;    // NOLINT\n\n#include &lt;string&gt;\n\n#elif GTEST_OS_ZOS\n#include &lt;sys/time.h&gt;  // NOLINT\n\n// On z/OS we additionally need strings.h for strcasecmp.\n#include &lt;strings.h&gt;   // NOLINT\n\n#elif GTEST_OS_WINDOWS_MOBILE  // We are on Windows CE.\n\n#include &lt;windows.h&gt;  // NOLINT\n#undef min\n\n#elif GTEST_OS_WINDOWS  // We are on Windows proper.\n\n#include &lt;windows.h&gt;  // NOLINT\n#undef min\n\n#ifdef _MSC_VER\n#include &lt;crtdbg.h&gt;  // NOLINT\n#endif\n\n#include &lt;io.h&gt;         // NOLINT\n#include &lt;sys/stat.h&gt;   // NOLINT\n#include &lt;sys/timeb.h&gt;  // NOLINT\n#include &lt;sys/types.h&gt;  // NOLINT\n\n#if GTEST_OS_WINDOWS_MINGW\n#include &lt;sys/time.h&gt;  // NOLINT\n#endif                 // GTEST_OS_WINDOWS_MINGW\n\n#else\n\n// cpplint thinks that the header is already included, so we want to\n// silence it.\n#include &lt;sys/time.h&gt;  // NOLINT\n#include &lt;unistd.h&gt;    // NOLINT\n\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n#include &lt;stdexcept&gt;\n#endif\n\n#if GTEST_CAN_STREAM_RESULTS_\n#include &lt;arpa/inet.h&gt;   // NOLINT\n#include &lt;netdb.h&gt;       // NOLINT\n#include &lt;sys/socket.h&gt;  // NOLINT\n#include &lt;sys/types.h&gt;   // NOLINT\n#endif\n\n#include &quot;src/gtest-internal-inl.h&quot;\n\n#if GTEST_OS_WINDOWS\n#define vsnprintf _vsnprintf\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_MAC\n#ifndef GTEST_OS_IOS\n#include &lt;crt_externs.h&gt;\n#endif\n#endif\n\n#if GTEST_HAS_ABSL\n#include &quot;absl/debugging/failure_signal_handler.h&quot;\n#include &quot;absl/debugging/stacktrace.h&quot;\n#include &quot;absl/debugging/symbolize.h&quot;\n#include &quot;absl/flags/parse.h&quot;\n#include &quot;absl/flags/usage.h&quot;\n#include &quot;absl/strings/str_cat.h&quot;\n#include &quot;absl/strings/str_replace.h&quot;\n#endif  // GTEST_HAS_ABSL\n\nnamespace testing {\n\nusing internal::CountIf;\nusing internal::ForEach;\nusing internal::GetElementOr;\nusing internal::Shuffle;\n\n// Constants.\n\n// A test whose test suite name or test name matches this filter is\n// disabled and not run.\nstatic const char kDisableTestFilter[] = &quot;DISABLED_*:*/DISABLED_*&quot;;\n\n// A test suite whose name matches this filter is considered a death\n// test suite and will be run before test suites whose name doesn&#x27;t\n// match this filter.\nstatic const char kDeathTestSuiteFilter[] = &quot;*DeathTest:*DeathTest/*&quot;;\n\n// A test filter that matches everything.\nstatic const char kUniversalFilter[] = &quot;*&quot;;\n\n// The default output format.\nstatic const char kDefaultOutputFormat[] = &quot;xml&quot;;\n// The default output file.\nstatic const char kDefaultOutputFile[] = &quot;test_detail&quot;;\n\n// The environment variable name for the test shard index.\nstatic const char kTestShardIndex[] = &quot;GTEST_SHARD_INDEX&quot;;\n// The environment variable name for the total number of test shards.\nstatic const char kTestTotalShards[] = &quot;GTEST_TOTAL_SHARDS&quot;;\n// The environment variable name for the test shard status file.\nstatic const char kTestShardStatusFile[] = &quot;GTEST_SHARD_STATUS_FILE&quot;;\n\nnamespace internal {\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nconst char kStackTraceMarker[] = &quot;\\nStack trace:\\n&quot;;\n\n// g_help_flag is true if and only if the --help flag or an equivalent form\n// is specified on the command line.\nbool g_help_flag = false;\n\n// Utility function to Open File for Writing\nstatic FILE* OpenFileForWriting(const std::string&amp; output_file) {\n  FILE* fileout = nullptr;\n  FilePath output_file_path(output_file);\n  FilePath output_dir(output_file_path.RemoveFileName());\n\n  if (output_dir.CreateDirectoriesRecursively()) {\n    fileout = posix::FOpen(output_file.c_str(), &quot;w&quot;);\n  }\n  if (fileout == nullptr) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Unable to open file \\&quot;&quot; &lt;&lt; output_file &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return fileout;\n}\n\n}  // namespace internal\n\n// Bazel passes in the argument to &#x27;--test_filter&#x27; via the TESTBRIDGE_TEST_ONLY\n// environment variable.\nstatic const char* GetDefaultFilter() {\n  const char* const testbridge_test_only =\n      internal::posix::GetEnv(&quot;TESTBRIDGE_TEST_ONLY&quot;);\n  if (testbridge_test_only != nullptr) {\n    return testbridge_test_only;\n  }\n  return kUniversalFilter;\n}\n\n// Bazel passes in the argument to &#x27;--test_runner_fail_fast&#x27; via the\n// TESTBRIDGE_TEST_RUNNER_FAIL_FAST environment variable.\nstatic bool GetDefaultFailFast() {\n  const char* const testbridge_test_runner_fail_fast =\n      internal::posix::GetEnv(&quot;TESTBRIDGE_TEST_RUNNER_FAIL_FAST&quot;);\n  if (testbridge_test_runner_fail_fast != nullptr) {\n    return strcmp(testbridge_test_runner_fail_fast, &quot;1&quot;) == 0;\n  }\n  return false;\n}\n\n}  // namespace testing\n\nGTEST_DEFINE_bool_(\n    fail_fast,\n    testing::internal::BoolFromGTestEnv(&quot;fail_fast&quot;,\n                                        testing::GetDefaultFailFast()),\n    &quot;True if and only if a test failure should stop further test execution.&quot;);\n\nGTEST_DEFINE_bool_(\n    also_run_disabled_tests,\n    testing::internal::BoolFromGTestEnv(&quot;also_run_disabled_tests&quot;, false),\n    &quot;Run disabled tests too, in addition to the tests normally being run.&quot;);\n\nGTEST_DEFINE_bool_(\n    break_on_failure,\n    testing::internal::BoolFromGTestEnv(&quot;break_on_failure&quot;, false),\n    &quot;True if and only if a failed assertion should be a debugger &quot;\n    &quot;break-point.&quot;);\n\nGTEST_DEFINE_bool_(catch_exceptions,\n                   testing::internal::BoolFromGTestEnv(&quot;catch_exceptions&quot;,\n                                                       true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should catch exceptions and treat them as test failures.&quot;);\n\nGTEST_DEFINE_string_(\n    color, testing::internal::StringFromGTestEnv(&quot;color&quot;, &quot;auto&quot;),\n    &quot;Whether to use colors in the output.  Valid values: yes, no, &quot;\n    &quot;and auto.  &#x27;auto&#x27; means to use colors if the output is &quot;\n    &quot;being sent to a terminal and the TERM environment variable &quot;\n    &quot;is set to a terminal type that supports colors.&quot;);\n\nGTEST_DEFINE_string_(\n    filter,\n    testing::internal::StringFromGTestEnv(&quot;filter&quot;,\n                                          testing::GetDefaultFilter()),\n    &quot;A colon-separated list of glob (not regex) patterns &quot;\n    &quot;for filtering the tests to run, optionally followed by a &quot;\n    &quot;&#x27;-&#x27; and a : separated list of negative patterns (tests to &quot;\n    &quot;exclude).  A test is run if it matches one of the positive &quot;\n    &quot;patterns and does not match any of the negative patterns.&quot;);\n\nGTEST_DEFINE_bool_(\n    install_failure_signal_handler,\n    testing::internal::BoolFromGTestEnv(&quot;install_failure_signal_handler&quot;,\n                                        false),\n    &quot;If true and supported on the current platform, &quot; GTEST_NAME_\n    &quot; should &quot;\n    &quot;install a signal handler that dumps debugging information when fatal &quot;\n    &quot;signals are raised.&quot;);\n\nGTEST_DEFINE_bool_(list_tests, false, &quot;List all tests without running them.&quot;);\n\n// The net priority order after flag processing is thus:\n//   --gtest_output command line flag\n//   GTEST_OUTPUT environment variable\n//   XML_OUTPUT_FILE environment variable\n//   &#x27;&#x27;\nGTEST_DEFINE_string_(\n    output,\n    testing::internal::StringFromGTestEnv(\n        &quot;output&quot;, testing::internal::OutputFlagAlsoCheckEnvVar().c_str()),\n    &quot;A format (defaults to \\&quot;xml\\&quot; but can be specified to be \\&quot;json\\&quot;), &quot;\n    &quot;optionally followed by a colon and an output file name or directory. &quot;\n    &quot;A directory is indicated by a trailing pathname separator. &quot;\n    &quot;Examples: \\&quot;xml:filename.xml\\&quot;, \\&quot;xml::directoryname/\\&quot;. &quot;\n    &quot;If a directory is specified, output files will be created &quot;\n    &quot;within that directory, with file-names based on the test &quot;\n    &quot;executable&#x27;s name and, if necessary, made unique by adding &quot;\n    &quot;digits.&quot;);\n\nGTEST_DEFINE_bool_(\n    brief, testing::internal::BoolFromGTestEnv(&quot;brief&quot;, false),\n    &quot;True if only test failures should be displayed in text output.&quot;);\n\nGTEST_DEFINE_bool_(print_time,\n                   testing::internal::BoolFromGTestEnv(&quot;print_time&quot;, true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should display elapsed time in text output.&quot;);\n\nGTEST_DEFINE_bool_(print_utf8,\n                   testing::internal::BoolFromGTestEnv(&quot;print_utf8&quot;, true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; prints UTF8 characters as text.&quot;);\n\nGTEST_DEFINE_int32_(\n    random_seed, testing::internal::Int32FromGTestEnv(&quot;random_seed&quot;, 0),\n    &quot;Random number seed to use when shuffling test orders.  Must be in range &quot;\n    &quot;[1, 99999], or 0 to use a seed based on the current time.&quot;);\n\nGTEST_DEFINE_int32_(\n    repeat, testing::internal::Int32FromGTestEnv(&quot;repeat&quot;, 1),\n    &quot;How many times to repeat each test.  Specify a negative number &quot;\n    &quot;for repeating forever.  Useful for shaking out flaky tests.&quot;);\n\nGTEST_DEFINE_bool_(\n    recreate_environments_when_repeating,\n    testing::internal::BoolFromGTestEnv(&quot;recreate_environments_when_repeating&quot;,\n                                        false),\n    &quot;Controls whether global test environments are recreated for each repeat &quot;\n    &quot;of the tests. If set to false the global test environments are only set &quot;\n    &quot;up once, for the first iteration, and only torn down once, for the last. &quot;\n    &quot;Useful for shaking out flaky tests with stable, expensive test &quot;\n    &quot;environments. If --gtest_repeat is set to a negative number, meaning &quot;\n    &quot;there is no last run, the environments will always be recreated to avoid &quot;\n    &quot;leaks.&quot;);\n\nGTEST_DEFINE_bool_(show_internal_stack_frames, false,\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should include internal stack frames when &quot;\n                   &quot;printing test failure stack traces.&quot;);\n\nGTEST_DEFINE_bool_(shuffle,\n                   testing::internal::BoolFromGTestEnv(&quot;shuffle&quot;, false),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should randomize tests&#x27; order on every run.&quot;);\n\nGTEST_DEFINE_int32_(\n    stack_trace_depth,\n    testing::internal::Int32FromGTestEnv(&quot;stack_trace_depth&quot;,\n                                         testing::kMaxStackTraceDepth),\n    &quot;The maximum number of stack frames to print when an &quot;\n    &quot;assertion fails.  The valid range is 0 through 100, inclusive.&quot;);\n\nGTEST_DEFINE_string_(\n    stream_result_to,\n    testing::internal::StringFromGTestEnv(&quot;stream_result_to&quot;, &quot;&quot;),\n    &quot;This flag specifies the host name and the port number on which to stream &quot;\n    &quot;test results. Example: \\&quot;localhost:555\\&quot;. The flag is effective only on &quot;\n    &quot;Linux.&quot;);\n\nGTEST_DEFINE_bool_(\n    throw_on_failure,\n    testing::internal::BoolFromGTestEnv(&quot;throw_on_failure&quot;, false),\n    &quot;When this flag is specified, a failed assertion will throw an exception &quot;\n    &quot;if exceptions are enabled or exit the program with a non-zero code &quot;\n    &quot;otherwise. For use with an external test framework.&quot;);\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\nGTEST_DEFINE_string_(\n    flagfile, testing::internal::StringFromGTestEnv(&quot;flagfile&quot;, &quot;&quot;),\n    &quot;This flag specifies the flagfile to read command-line flags from.&quot;);\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n\nnamespace testing {\nnamespace internal {\n\n// Generates a random number from [0, range), using a Linear\n// Congruential Generator (LCG).  Crashes if &#x27;range&#x27; is 0 or greater\n// than kMaxRange.\nuint32_t Random::Generate(uint32_t range) {\n  // These constants are the same as are used in glibc&#x27;s rand(3).\n  // Use wider types than necessary to prevent unsigned overflow diagnostics.\n  state_ = static_cast&lt;uint32_t&gt;(1103515245ULL * state_ + 12345U) % kMaxRange;\n\n  GTEST_CHECK_(range &gt; 0) &lt;&lt; &quot;Cannot generate a number in the range [0, 0).&quot;;\n  GTEST_CHECK_(range &lt;= kMaxRange)\n      &lt;&lt; &quot;Generation of a number in [0, &quot; &lt;&lt; range &lt;&lt; &quot;) was requested, &quot;\n      &lt;&lt; &quot;but this can only generate numbers in [0, &quot; &lt;&lt; kMaxRange &lt;&lt; &quot;).&quot;;\n\n  // Converting via modulus introduces a bit of downward bias, but\n  // it&#x27;s simple, and a linear congruential generator isn&#x27;t too good\n  // to begin with.\n  return state_ % range;\n}\n\n// GTestIsInitialized() returns true if and only if the user has initialized\n// Google Test.  Useful for catching the user mistake of not initializing\n// Google Test before calling RUN_ALL_TESTS().\nstatic bool GTestIsInitialized() { return GetArgvs().size() &gt; 0; }\n\n// Iterates over a vector of TestSuites, keeping a running sum of the\n// results of calling a given int-returning method on each.\n// Returns the sum.\nstatic int SumOverTestSuiteList(const std::vector&lt;TestSuite*&gt;&amp; case_list,\n                                int (TestSuite::*method)() const) {\n  int sum = 0;\n  for (size_t i = 0; i &lt; case_list.size(); i++) {\n    sum += (case_list[i]-&gt;*method)();\n  }\n  return sum;\n}\n\n// Returns true if and only if the test suite passed.\nstatic bool TestSuitePassed(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Passed();\n}\n\n// Returns true if and only if the test suite failed.\nstatic bool TestSuiteFailed(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Failed();\n}\n\n// Returns true if and only if test_suite contains at least one test that\n// should run.\nstatic bool ShouldRunTestSuite(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run();\n}\n\n// AssertHelper constructor.\nAssertHelper::AssertHelper(TestPartResult::Type type, const char* file,\n                           int line, const char* message)\n    : data_(new AssertHelperData(type, file, line, message)) {}\n\nAssertHelper::~AssertHelper() { delete data_; }\n\n// Message assignment, for assertion streaming support.\nvoid AssertHelper::operator=(const Message&amp; message) const {\n  UnitTest::GetInstance()-&gt;AddTestPartResult(\n      data_-&gt;type, data_-&gt;file, data_-&gt;line,\n      AppendUserMessage(data_-&gt;message, message),\n      UnitTest::GetInstance()-&gt;impl()-&gt;CurrentOsStackTraceExceptTop(1)\n      // Skips the stack frame for this function itself.\n  );  // NOLINT\n}\n\nnamespace {\n\n// When TEST_P is found without a matching INSTANTIATE_TEST_SUITE_P\n// to creates test cases for it, a synthetic test case is\n// inserted to report ether an error or a log message.\n//\n// This configuration bit will likely be removed at some point.\nconstexpr bool kErrorOnUninstantiatedParameterizedTest = true;\nconstexpr bool kErrorOnUninstantiatedTypeParameterizedTest = true;\n\n// A test that fails at a given file/line location with a given message.\nclass FailureTest : public Test {\n public:\n  explicit FailureTest(const CodeLocation&amp; loc, std::string error_message,\n                       bool as_error)\n      : loc_(loc),\n        error_message_(std::move(error_message)),\n        as_error_(as_error) {}\n\n  void TestBody() override {\n    if (as_error_) {\n      AssertHelper(TestPartResult::kNonFatalFailure, loc_.file.c_str(),\n                   loc_.line, &quot;&quot;) = Message() &lt;&lt; error_message_;\n    } else {\n      std::cout &lt;&lt; error_message_ &lt;&lt; std::endl;\n    }\n  }\n\n private:\n  const CodeLocation loc_;\n  const std::string error_message_;\n  const bool as_error_;\n};\n\n}  // namespace\n\nstd::set&lt;std::string&gt;* GetIgnoredParameterizedTestSuites() {\n  return UnitTest::GetInstance()-&gt;impl()-&gt;ignored_parameterized_test_suites();\n}\n\n// Add a given test_suit to the list of them allow to go un-instantiated.\nMarkAsIgnored::MarkAsIgnored(const char* test_suite) {\n  GetIgnoredParameterizedTestSuites()-&gt;insert(test_suite);\n}\n\n// If this parameterized test suite has no instantiations (and that\n// has not been marked as okay), emit a test case reporting that.\nvoid InsertSyntheticTestCase(const std::string&amp; name, CodeLocation location,\n                             bool has_test_p) {\n  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();\n  if (ignored.find(name) != ignored.end()) return;\n\n  const char kMissingInstantiation[] =  //\n      &quot; is defined via TEST_P, but never instantiated. None of the test cases &quot;\n      &quot;will run. Either no INSTANTIATE_TEST_SUITE_P is provided or the only &quot;\n      &quot;ones provided expand to nothing.&quot;\n      &quot;\\n\\n&quot;\n      &quot;Ideally, TEST_P definitions should only ever be included as part of &quot;\n      &quot;binaries that intend to use them. (As opposed to, for example, being &quot;\n      &quot;placed in a library that may be linked in to get other utilities.)&quot;;\n\n  const char kMissingTestCase[] =  //\n      &quot; is instantiated via INSTANTIATE_TEST_SUITE_P, but no tests are &quot;\n      &quot;defined via TEST_P . No test cases will run.&quot;\n      &quot;\\n\\n&quot;\n      &quot;Ideally, INSTANTIATE_TEST_SUITE_P should only ever be invoked from &quot;\n      &quot;code that always depend on code that provides TEST_P. Failing to do &quot;\n      &quot;so is often an indication of dead code, e.g. the last TEST_P was &quot;\n      &quot;removed but the rest got left behind.&quot;;\n\n  std::string message =\n      &quot;Parameterized test suite &quot; + name +\n      (has_test_p ? kMissingInstantiation : kMissingTestCase) +\n      &quot;\\n\\n&quot;\n      &quot;To suppress this error for this test suite, insert the following line &quot;\n      &quot;(in a non-header) in the namespace it is defined in:&quot;\n      &quot;\\n\\n&quot;\n      &quot;GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(&quot; +\n      name + &quot;);&quot;;\n\n  std::string full_name = &quot;UninstantiatedParameterizedTestSuite&lt;&quot; + name + &quot;&gt;&quot;;\n  RegisterTest(  //\n      &quot;GoogleTestVerification&quot;, full_name.c_str(),\n      nullptr,  // No type parameter.\n      nullptr,  // No value parameter.\n      location.file.c_str(), location.line, [message, location] {\n        return new FailureTest(location, message,\n                               kErrorOnUninstantiatedParameterizedTest);\n      });\n}\n\nvoid RegisterTypeParameterizedTestSuite(const char* test_suite_name,\n                                        CodeLocation code_location) {\n  GetUnitTestImpl()-&gt;type_parameterized_test_registry().RegisterTestSuite(\n      test_suite_name, code_location);\n}\n\nvoid RegisterTypeParameterizedTestSuiteInstantiation(const char* case_name) {\n  GetUnitTestImpl()-&gt;type_parameterized_test_registry().RegisterInstantiation(\n      case_name);\n}\n\nvoid TypeParameterizedTestSuiteRegistry::RegisterTestSuite(\n    const char* test_suite_name, CodeLocation code_location) {\n  suites_.emplace(std::string(test_suite_name),\n                  TypeParameterizedTestSuiteInfo(code_location));\n}\n\nvoid TypeParameterizedTestSuiteRegistry::RegisterInstantiation(\n    const char* test_suite_name) {\n  auto it = suites_.find(std::string(test_suite_name));\n  if (it != suites_.end()) {\n    it-&gt;second.instantiated = true;\n  } else {\n    GTEST_LOG_(ERROR) &lt;&lt; &quot;Unknown type parameterized test suit &#x27;&quot;\n                      &lt;&lt; test_suite_name &lt;&lt; &quot;&#x27;&quot;;\n  }\n}\n\nvoid TypeParameterizedTestSuiteRegistry::CheckForInstantiations() {\n  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();\n  for (const auto&amp; testcase : suites_) {\n    if (testcase.second.instantiated) continue;\n    if (ignored.find(testcase.first) != ignored.end()) continue;\n\n    std::string message =\n        &quot;Type parameterized test suite &quot; + testcase.first +\n        &quot; is defined via REGISTER_TYPED_TEST_SUITE_P, but never instantiated &quot;\n        &quot;via INSTANTIATE_TYPED_TEST_SUITE_P. None of the test cases will run.&quot;\n        &quot;\\n\\n&quot;\n        &quot;Ideally, TYPED_TEST_P definitions should only ever be included as &quot;\n        &quot;part of binaries that intend to use them. (As opposed to, for &quot;\n        &quot;example, being placed in a library that may be linked in to get other &quot;\n        &quot;utilities.)&quot;\n        &quot;\\n\\n&quot;\n        &quot;To suppress this error for this test suite, insert the following line &quot;\n        &quot;(in a non-header) in the namespace it is defined in:&quot;\n        &quot;\\n\\n&quot;\n        &quot;GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(&quot; +\n        testcase.first + &quot;);&quot;;\n\n    std::string full_name =\n        &quot;UninstantiatedTypeParameterizedTestSuite&lt;&quot; + testcase.first + &quot;&gt;&quot;;\n    RegisterTest(  //\n        &quot;GoogleTestVerification&quot;, full_name.c_str(),\n        nullptr,  // No type parameter.\n        nullptr,  // No value parameter.\n        testcase.second.code_location.file.c_str(),\n        testcase.second.code_location.line, [message, testcase] {\n          return new FailureTest(testcase.second.code_location, message,\n                                 kErrorOnUninstantiatedTypeParameterizedTest);\n        });\n  }\n}\n\n// A copy of all command line arguments.  Set by InitGoogleTest().\nstatic ::std::vector&lt;std::string&gt; g_argvs;\n\n::std::vector&lt;std::string&gt; GetArgvs() {\n#if defined(GTEST_CUSTOM_GET_ARGVS_)\n  // GTEST_CUSTOM_GET_ARGVS_() may return a container of std::string or\n  // ::string. This code converts it to the appropriate type.\n  const auto&amp; custom = GTEST_CUSTOM_GET_ARGVS_();\n  return ::std::vector&lt;std::string&gt;(custom.begin(), custom.end());\n#else   // defined(GTEST_CUSTOM_GET_ARGVS_)\n  return g_argvs;\n#endif  // defined(GTEST_CUSTOM_GET_ARGVS_)\n}\n\n// Returns the current application&#x27;s name, removing directory path if that\n// is present.\nFilePath GetCurrentExecutableName() {\n  FilePath result;\n\n#if GTEST_OS_WINDOWS || GTEST_OS_OS2\n  result.Set(FilePath(GetArgvs()[0]).RemoveExtension(&quot;exe&quot;));\n#else\n  result.Set(FilePath(GetArgvs()[0]));\n#endif  // GTEST_OS_WINDOWS\n\n  return result.RemoveDirectoryName();\n}\n\n// Functions for processing the gtest_output flag.\n\n// Returns the output format, or &quot;&quot; for normal printed output.\nstd::string UnitTestOptions::GetOutputFormat() {\n  std::string s = GTEST_FLAG_GET(output);\n  const char* const gtest_output_flag = s.c_str();\n  const char* const colon = strchr(gtest_output_flag, &#x27;:&#x27;);\n  return (colon == nullptr)\n             ? std::string(gtest_output_flag)\n             : std::string(gtest_output_flag,\n                           static_cast&lt;size_t&gt;(colon - gtest_output_flag));\n}\n\n// Returns the name of the requested output file, or the default if none\n// was explicitly specified.\nstd::string UnitTestOptions::GetAbsolutePathToOutputFile() {\n  std::string s = GTEST_FLAG_GET(output);\n  const char* const gtest_output_flag = s.c_str();\n\n  std::string format = GetOutputFormat();\n  if (format.empty()) format = std::string(kDefaultOutputFormat);\n\n  const char* const colon = strchr(gtest_output_flag, &#x27;:&#x27;);\n  if (colon == nullptr)\n    return internal::FilePath::MakeFileName(\n               internal::FilePath(\n                   UnitTest::GetInstance()-&gt;original_working_dir()),\n               internal::FilePath(kDefaultOutputFile), 0, format.c_str())\n        .string();\n\n  internal::FilePath output_name(colon + 1);\n  if (!output_name.IsAbsolutePath())\n    output_name = internal::FilePath::ConcatPaths(\n        internal::FilePath(UnitTest::GetInstance()-&gt;original_working_dir()),\n        internal::FilePath(colon + 1));\n\n  if (!output_name.IsDirectory()) return output_name.string();\n\n  internal::FilePath result(internal::FilePath::GenerateUniqueFileName(\n      output_name, internal::GetCurrentExecutableName(),\n      GetOutputFormat().c_str()));\n  return result.string();\n}\n\n// Returns true if and only if the wildcard pattern matches the string. Each\n// pattern consists of regular characters, single-character wildcards (?), and\n// multi-character wildcards (*).\n//\n// This function implements a linear-time string globbing algorithm based on\n// https://research.swtch.com/glob.\nstatic bool PatternMatchesString(const std::string&amp; name_str,\n                                 const char* pattern, const char* pattern_end) {\n  const char* name = name_str.c_str();\n  const char* const name_begin = name;\n  const char* const name_end = name + name_str.size();\n\n  const char* pattern_next = pattern;\n  const char* name_next = name;\n\n  while (pattern &lt; pattern_end || name &lt; name_end) {\n    if (pattern &lt; pattern_end) {\n      switch (*pattern) {\n        default:  // Match an ordinary character.\n          if (name &lt; name_end &amp;&amp; *name == *pattern) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case &#x27;?&#x27;:  // Match any single character.\n          if (name &lt; name_end) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case &#x27;*&#x27;:\n          // Match zero or more characters. Start by skipping over the wildcard\n          // and matching zero characters from name. If that fails, restart and\n          // match one more character than the last attempt.\n          pattern_next = pattern;\n          name_next = name + 1;\n          ++pattern;\n          continue;\n      }\n    }\n    // Failed to match a character. Restart if possible.\n    if (name_begin &lt; name_next &amp;&amp; name_next &lt;= name_end) {\n      pattern = pattern_next;\n      name = name_next;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nnamespace {\n\nbool IsGlobPattern(const std::string&amp; pattern) {\n  return std::any_of(pattern.begin(), pattern.end(),\n                     [](const char c) { return c == &#x27;?&#x27; || c == &#x27;*&#x27;; });\n}\n\nclass UnitTestFilter {\n public:\n  UnitTestFilter() = default;\n\n  // Constructs a filter from a string of patterns separated by `:`.\n  explicit UnitTestFilter(const std::string&amp; filter) {\n    // By design &quot;&quot; filter matches &quot;&quot; string.\n    std::vector&lt;std::string&gt; all_patterns;\n    SplitString(filter, &#x27;:&#x27;, &amp;all_patterns);\n    const auto exact_match_patterns_begin = std::partition(\n        all_patterns.begin(), all_patterns.end(), &amp;IsGlobPattern);\n\n    glob_patterns_.reserve(static_cast&lt;size_t&gt;(\n        std::distance(all_patterns.begin(), exact_match_patterns_begin)));\n    std::move(all_patterns.begin(), exact_match_patterns_begin,\n              std::inserter(glob_patterns_, glob_patterns_.begin()));\n    std::move(\n        exact_match_patterns_begin, all_patterns.end(),\n        std::inserter(exact_match_patterns_, exact_match_patterns_.begin()));\n  }\n\n  // Returns true if and only if name matches at least one of the patterns in\n  // the filter.\n  bool MatchesName(const std::string&amp; name) const {\n    return exact_match_patterns_.count(name) &gt; 0 ||\n           std::any_of(glob_patterns_.begin(), glob_patterns_.end(),\n                       [&amp;name](const std::string&amp; pattern) {\n                         return PatternMatchesString(\n                             name, pattern.c_str(),\n                             pattern.c_str() + pattern.size());\n                       });\n  }\n\n private:\n  std::vector&lt;std::string&gt; glob_patterns_;\n  std::unordered_set&lt;std::string&gt; exact_match_patterns_;\n};\n\nclass PositiveAndNegativeUnitTestFilter {\n public:\n  // Constructs a positive and a negative filter from a string. The string\n  // contains a positive filter optionally followed by a &#x27;-&#x27; character and a\n  // negative filter. In case only a negative filter is provided the positive\n  // filter will be assumed &quot;*&quot;.\n  // A filter is a list of patterns separated by &#x27;:&#x27;.\n  explicit PositiveAndNegativeUnitTestFilter(const std::string&amp; filter) {\n    std::vector&lt;std::string&gt; positive_and_negative_filters;\n\n    // NOTE: `SplitString` always returns a non-empty container.\n    SplitString(filter, &#x27;-&#x27;, &amp;positive_and_negative_filters);\n    const auto&amp; positive_filter = positive_and_negative_filters.front();\n\n    if (positive_and_negative_filters.size() &gt; 1) {\n      positive_filter_ = UnitTestFilter(\n          positive_filter.empty() ? kUniversalFilter : positive_filter);\n\n      // TODO(b/214626361): Fail on multiple &#x27;-&#x27; characters\n      // For the moment to preserve old behavior we concatenate the rest of the\n      // string parts with `-` as separator to generate the negative filter.\n      auto negative_filter_string = positive_and_negative_filters[1];\n      for (std::size_t i = 2; i &lt; positive_and_negative_filters.size(); i++)\n        negative_filter_string =\n            negative_filter_string + &#x27;-&#x27; + positive_and_negative_filters[i];\n      negative_filter_ = UnitTestFilter(negative_filter_string);\n    } else {\n      // In case we don&#x27;t have a negative filter and positive filter is &quot;&quot;\n      // we do not use kUniversalFilter by design as opposed to when we have a\n      // negative filter.\n      positive_filter_ = UnitTestFilter(positive_filter);\n    }\n  }\n\n  // Returns true if and only if test name (this is generated by appending test\n  // suit name and test name via a &#x27;.&#x27; character) matches the positive filter\n  // and does not match the negative filter.\n  bool MatchesTest(const std::string&amp; test_suite_name,\n                   const std::string&amp; test_name) const {\n    return MatchesName(test_suite_name + &quot;.&quot; + test_name);\n  }\n\n  // Returns true if and only if name matches the positive filter and does not\n  // match the negative filter.\n  bool MatchesName(const std::string&amp; name) const {\n    return positive_filter_.MatchesName(name) &amp;&amp;\n           !negative_filter_.MatchesName(name);\n  }\n\n private:\n  UnitTestFilter positive_filter_;\n  UnitTestFilter negative_filter_;\n};\n}  // namespace\n\nbool UnitTestOptions::MatchesFilter(const std::string&amp; name_str,\n                                    const char* filter) {\n  return UnitTestFilter(filter).MatchesName(name_str);\n}\n\n// Returns true if and only if the user-specified filter matches the test\n// suite name and the test name.\nbool UnitTestOptions::FilterMatchesTest(const std::string&amp; test_suite_name,\n                                        const std::string&amp; test_name) {\n  // Split --gtest_filter at &#x27;-&#x27;, if there is one, to separate into\n  // positive filter and negative filter portions\n  return PositiveAndNegativeUnitTestFilter(GTEST_FLAG_GET(filter))\n      .MatchesTest(test_suite_name, test_name);\n}\n\n#if GTEST_HAS_SEH\n// Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the\n// given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.\n// This function is useful as an __except condition.\nint UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {\n  // Google Test should handle a SEH exception if:\n  //   1. the user wants it to, AND\n  //   2. this is not a breakpoint exception, AND\n  //   3. this is not a C++ exception (VC++ implements them via SEH,\n  //      apparently).\n  //\n  // SEH exception code for C++ exceptions.\n  // (see http://support.microsoft.com/kb/185294 for more information).\n  const DWORD kCxxExceptionCode = 0xe06d7363;\n\n  bool should_handle = true;\n\n  if (!GTEST_FLAG_GET(catch_exceptions))\n    should_handle = false;\n  else if (exception_code == EXCEPTION_BREAKPOINT)\n    should_handle = false;\n  else if (exception_code == kCxxExceptionCode)\n    should_handle = false;\n\n  return should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;\n}\n#endif  // GTEST_HAS_SEH\n\n}  // namespace internal\n\n// The c&#x27;tor sets this object as the test part result reporter used by\n// Google Test.  The &#x27;result&#x27; parameter specifies where to report the\n// results. Intercepts only failures from the current thread.\nScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\n    TestPartResultArray* result)\n    : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD), result_(result) {\n  Init();\n}\n\n// The c&#x27;tor sets this object as the test part result reporter used by\n// Google Test.  The &#x27;result&#x27; parameter specifies where to report the\n// results.\nScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\n    InterceptMode intercept_mode, TestPartResultArray* result)\n    : intercept_mode_(intercept_mode), result_(result) {\n  Init();\n}\n\nvoid ScopedFakeTestPartResultReporter::Init() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {\n    old_reporter_ = impl-&gt;GetGlobalTestPartResultReporter();\n    impl-&gt;SetGlobalTestPartResultReporter(this);\n  } else {\n    old_reporter_ = impl-&gt;GetTestPartResultReporterForCurrentThread();\n    impl-&gt;SetTestPartResultReporterForCurrentThread(this);\n  }\n}\n\n// The d&#x27;tor restores the test part result reporter used by Google Test\n// before.\nScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {\n    impl-&gt;SetGlobalTestPartResultReporter(old_reporter_);\n  } else {\n    impl-&gt;SetTestPartResultReporterForCurrentThread(old_reporter_);\n  }\n}\n\n// Increments the test part result count and remembers the result.\n// This method is from the TestPartResultReporterInterface interface.\nvoid ScopedFakeTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  result_-&gt;Append(result);\n}\n\nnamespace internal {\n\n// Returns the type ID of ::testing::Test.  We should always call this\n// instead of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of\n// testing::Test.  This is to work around a suspected linker bug when\n// using Google Test as a framework on Mac OS X.  The bug causes\n// GetTypeId&lt; ::testing::Test&gt;() to return different values depending\n// on whether the call is from the Google Test framework itself or\n// from user test code.  GetTestTypeId() is guaranteed to always\n// return the same value, as it always calls GetTypeId&lt;&gt;() from the\n// gtest.cc, which is within the Google Test framework.\nTypeId GetTestTypeId() { return GetTypeId&lt;Test&gt;(); }\n\n// The value of GetTestTypeId() as seen from within the Google Test\n// library.  This is solely for testing GetTestTypeId().\nextern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();\n\n// This predicate-formatter checks that &#x27;results&#x27; contains a test part\n// failure of the given type and that the failure message contains the\n// given substring.\nstatic AssertionResult HasOneFailure(const char* /* results_expr */,\n                                     const char* /* type_expr */,\n                                     const char* /* substr_expr */,\n                                     const TestPartResultArray&amp; results,\n                                     TestPartResult::Type type,\n                                     const std::string&amp; substr) {\n  const std::string expected(type == TestPartResult::kFatalFailure\n                                 ? &quot;1 fatal failure&quot;\n                                 : &quot;1 non-fatal failure&quot;);\n  Message msg;\n  if (results.size() != 1) {\n    msg &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot;\\n&quot;\n        &lt;&lt; &quot;  Actual: &quot; &lt;&lt; results.size() &lt;&lt; &quot; failures&quot;;\n    for (int i = 0; i &lt; results.size(); i++) {\n      msg &lt;&lt; &quot;\\n&quot; &lt;&lt; results.GetTestPartResult(i);\n    }\n    return AssertionFailure() &lt;&lt; msg;\n  }\n\n  const TestPartResult&amp; r = results.GetTestPartResult(0);\n  if (r.type() != type) {\n    return AssertionFailure() &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot;\\n&quot;\n                              &lt;&lt; &quot;  Actual:\\n&quot;\n                              &lt;&lt; r;\n  }\n\n  if (strstr(r.message(), substr.c_str()) == nullptr) {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot; containing \\&quot;&quot; &lt;&lt; substr &lt;&lt; &quot;\\&quot;\\n&quot;\n           &lt;&lt; &quot;  Actual:\\n&quot;\n           &lt;&lt; r;\n  }\n\n  return AssertionSuccess();\n}\n\n// The constructor of SingleFailureChecker remembers where to look up\n// test part results, what type of failure we expect, and what\n// substring the failure message should contain.\nSingleFailureChecker::SingleFailureChecker(const TestPartResultArray* results,\n                                           TestPartResult::Type type,\n                                           const std::string&amp; substr)\n    : results_(results), type_(type), substr_(substr) {}\n\n// The destructor of SingleFailureChecker verifies that the given\n// TestPartResultArray contains exactly one failure that has the given\n// type and contains the given substring.  If that&#x27;s not the case, a\n// non-fatal failure will be generated.\nSingleFailureChecker::~SingleFailureChecker() {\n  EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);\n}\n\nDefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(\n    UnitTestImpl* unit_test)\n    : unit_test_(unit_test) {}\n\nvoid DefaultGlobalTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  unit_test_-&gt;current_test_result()-&gt;AddTestPartResult(result);\n  unit_test_-&gt;listeners()-&gt;repeater()-&gt;OnTestPartResult(result);\n}\n\nDefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(\n    UnitTestImpl* unit_test)\n    : unit_test_(unit_test) {}\n\nvoid DefaultPerThreadTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  unit_test_-&gt;GetGlobalTestPartResultReporter()-&gt;ReportTestPartResult(result);\n}\n\n// Returns the global test part result reporter.\nTestPartResultReporterInterface*\nUnitTestImpl::GetGlobalTestPartResultReporter() {\n  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);\n  return global_test_part_result_repoter_;\n}\n\n// Sets the global test part result reporter.\nvoid UnitTestImpl::SetGlobalTestPartResultReporter(\n    TestPartResultReporterInterface* reporter) {\n  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);\n  global_test_part_result_repoter_ = reporter;\n}\n\n// Returns the test part result reporter for the current thread.\nTestPartResultReporterInterface*\nUnitTestImpl::GetTestPartResultReporterForCurrentThread() {\n  return per_thread_test_part_result_reporter_.get();\n}\n\n// Sets the test part result reporter for the current thread.\nvoid UnitTestImpl::SetTestPartResultReporterForCurrentThread(\n    TestPartResultReporterInterface* reporter) {\n  per_thread_test_part_result_reporter_.set(reporter);\n}\n\n// Gets the number of successful test suites.\nint UnitTestImpl::successful_test_suite_count() const {\n  return CountIf(test_suites_, TestSuitePassed);\n}\n\n// Gets the number of failed test suites.\nint UnitTestImpl::failed_test_suite_count() const {\n  return CountIf(test_suites_, TestSuiteFailed);\n}\n\n// Gets the number of all test suites.\nint UnitTestImpl::total_test_suite_count() const {\n  return static_cast&lt;int&gt;(test_suites_.size());\n}\n\n// Gets the number of all test suites that contain at least one test\n// that should run.\nint UnitTestImpl::test_suite_to_run_count() const {\n  return CountIf(test_suites_, ShouldRunTestSuite);\n}\n\n// Gets the number of successful tests.\nint UnitTestImpl::successful_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::successful_test_count);\n}\n\n// Gets the number of skipped tests.\nint UnitTestImpl::skipped_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::skipped_test_count);\n}\n\n// Gets the number of failed tests.\nint UnitTestImpl::failed_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::failed_test_count);\n}\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint UnitTestImpl::reportable_disabled_test_count() const {\n  return SumOverTestSuiteList(test_suites_,\n                              &amp;TestSuite::reportable_disabled_test_count);\n}\n\n// Gets the number of disabled tests.\nint UnitTestImpl::disabled_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::disabled_test_count);\n}\n\n// Gets the number of tests to be printed in the XML report.\nint UnitTestImpl::reportable_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::reportable_test_count);\n}\n\n// Gets the number of all tests.\nint UnitTestImpl::total_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::total_test_count);\n}\n\n// Gets the number of tests that should run.\nint UnitTestImpl::test_to_run_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::test_to_run_count);\n}\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// CurrentOsStackTraceExceptTop(1), Foo() will be included in the\n// trace but Bar() and CurrentOsStackTraceExceptTop() won&#x27;t.\nstd::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {\n  return os_stack_trace_getter()-&gt;CurrentStackTrace(\n      static_cast&lt;int&gt;(GTEST_FLAG_GET(stack_trace_depth)), skip_count + 1\n      // Skips the user-specified number of frames plus this function\n      // itself.\n  );  // NOLINT\n}\n\n// A helper class for measuring elapsed times.\nclass Timer {\n public:\n  Timer() : start_(std::chrono::steady_clock::now()) {}\n\n  // Return time elapsed in milliseconds since the timer was created.\n  TimeInMillis Elapsed() {\n    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n               std::chrono::steady_clock::now() - start_)\n        .count();\n  }\n\n private:\n  std::chrono::steady_clock::time_point start_;\n};\n\n// Returns a timestamp as milliseconds since the epoch. Note this time may jump\n// around subject to adjustments by the system, to measure elapsed time use\n// Timer instead.\nTimeInMillis GetTimeInMillis() {\n  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n             std::chrono::system_clock::now() -\n             std::chrono::system_clock::from_time_t(0))\n      .count();\n}\n\n// Utilities\n\n// class String.\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Creates a UTF-16 wide string from the given ANSI string, allocating\n// memory using new. The caller is responsible for deleting the return\n// value using delete[]. Returns the wide string, or NULL if the\n// input is NULL.\nLPCWSTR String::AnsiToUtf16(const char* ansi) {\n  if (!ansi) return nullptr;\n  const int length = strlen(ansi);\n  const int unicode_length =\n      MultiByteToWideChar(CP_ACP, 0, ansi, length, nullptr, 0);\n  WCHAR* unicode = new WCHAR[unicode_length + 1];\n  MultiByteToWideChar(CP_ACP, 0, ansi, length, unicode, unicode_length);\n  unicode[unicode_length] = 0;\n  return unicode;\n}\n\n// Creates an ANSI string from the given wide string, allocating\n// memory using new. The caller is responsible for deleting the return\n// value using delete[]. Returns the ANSI string, or NULL if the\n// input is NULL.\nconst char* String::Utf16ToAnsi(LPCWSTR utf16_str) {\n  if (!utf16_str) return nullptr;\n  const int ansi_length = WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, nullptr,\n                                              0, nullptr, nullptr);\n  char* ansi = new char[ansi_length + 1];\n  WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, ansi, ansi_length, nullptr,\n                      nullptr);\n  ansi[ansi_length] = 0;\n  return ansi;\n}\n\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n// Compares two C strings.  Returns true if and only if they have the same\n// content.\n//\n// Unlike strcmp(), this function can handle NULL argument(s).  A NULL\n// C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::CStringEquals(const char* lhs, const char* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n  return strcmp(lhs, rhs) == 0;\n}\n\n#if GTEST_HAS_STD_WSTRING\n\n// Converts an array of wide chars to a narrow string using the UTF-8\n// encoding, and streams the result to the given Message object.\nstatic void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,\n                                     Message* msg) {\n  for (size_t i = 0; i != length;) {  // NOLINT\n    if (wstr[i] != L&#x27;\\0&#x27;) {\n      *msg &lt;&lt; WideStringToUtf8(wstr + i, static_cast&lt;int&gt;(length - i));\n      while (i != length &amp;&amp; wstr[i] != L&#x27;\\0&#x27;) i++;\n    } else {\n      *msg &lt;&lt; &#x27;\\0&#x27;;\n      i++;\n    }\n  }\n}\n\n#endif  // GTEST_HAS_STD_WSTRING\n\nvoid SplitString(const ::std::string&amp; str, char delimiter,\n                 ::std::vector&lt; ::std::string&gt;* dest) {\n  ::std::vector&lt; ::std::string&gt; parsed;\n  ::std::string::size_type pos = 0;\n  while (::testing::internal::AlwaysTrue()) {\n    const ::std::string::size_type colon = str.find(delimiter, pos);\n    if (colon == ::std::string::npos) {\n      parsed.push_back(str.substr(pos));\n      break;\n    } else {\n      parsed.push_back(str.substr(pos, colon - pos));\n      pos = colon + 1;\n    }\n  }\n  dest-&gt;swap(parsed);\n}\n\n}  // namespace internal\n\n// Constructs an empty Message.\n// We allocate the stringstream separately because otherwise each use of\n// ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure&#x27;s\n// stack frame leading to huge stack frames in some cases; gcc does not reuse\n// the stack space.\nMessage::Message() : ss_(new ::std::stringstream) {\n  // By default, we want there to be enough precision when printing\n  // a double to a Message.\n  *ss_ &lt;&lt; std::setprecision(std::numeric_limits&lt;double&gt;::digits10 + 2);\n}\n\n// These two overloads allow streaming a wide C string to a Message\n// using the UTF-8 encoding.\nMessage&amp; Message::operator&lt;&lt;(const wchar_t* wide_c_str) {\n  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);\n}\nMessage&amp; Message::operator&lt;&lt;(wchar_t* wide_c_str) {\n  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);\n}\n\n#if GTEST_HAS_STD_WSTRING\n// Converts the given wide string to a narrow string using the UTF-8\n// encoding, and streams the result to this Message object.\nMessage&amp; Message::operator&lt;&lt;(const ::std::wstring&amp; wstr) {\n  internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);\n  return *this;\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n// Gets the text streamed to this object so far as an std::string.\n// Each &#x27;\\0&#x27; character in the buffer is replaced with &quot;\\\\0&quot;.\nstd::string Message::GetString() const {\n  return internal::StringStreamToString(ss_.get());\n}\n\nnamespace internal {\n\nnamespace edit_distance {\nstd::vector&lt;EditType&gt; CalculateOptimalEdits(const std::vector&lt;size_t&gt;&amp; left,\n                                            const std::vector&lt;size_t&gt;&amp; right) {\n  std::vector&lt;std::vector&lt;double&gt; &gt; costs(\n      left.size() + 1, std::vector&lt;double&gt;(right.size() + 1));\n  std::vector&lt;std::vector&lt;EditType&gt; &gt; best_move(\n      left.size() + 1, std::vector&lt;EditType&gt;(right.size() + 1));\n\n  // Populate for empty right.\n  for (size_t l_i = 0; l_i &lt; costs.size(); ++l_i) {\n    costs[l_i][0] = static_cast&lt;double&gt;(l_i);\n    best_move[l_i][0] = kRemove;\n  }\n  // Populate for empty left.\n  for (size_t r_i = 1; r_i &lt; costs[0].size(); ++r_i) {\n    costs[0][r_i] = static_cast&lt;double&gt;(r_i);\n    best_move[0][r_i] = kAdd;\n  }\n\n  for (size_t l_i = 0; l_i &lt; left.size(); ++l_i) {\n    for (size_t r_i = 0; r_i &lt; right.size(); ++r_i) {\n      if (left[l_i] == right[r_i]) {\n        // Found a match. Consume it.\n        costs[l_i + 1][r_i + 1] = costs[l_i][r_i];\n        best_move[l_i + 1][r_i + 1] = kMatch;\n        continue;\n      }\n\n      const double add = costs[l_i + 1][r_i];\n      const double remove = costs[l_i][r_i + 1];\n      const double replace = costs[l_i][r_i];\n      if (add &lt; remove &amp;&amp; add &lt; replace) {\n        costs[l_i + 1][r_i + 1] = add + 1;\n        best_move[l_i + 1][r_i + 1] = kAdd;\n      } else if (remove &lt; add &amp;&amp; remove &lt; replace) {\n        costs[l_i + 1][r_i + 1] = remove + 1;\n        best_move[l_i + 1][r_i + 1] = kRemove;\n      } else {\n        // We make replace a little more expensive than add/remove to lower\n        // their priority.\n        costs[l_i + 1][r_i + 1] = replace + 1.00001;\n        best_move[l_i + 1][r_i + 1] = kReplace;\n      }\n    }\n  }\n\n  // Reconstruct the best path. We do it in reverse order.\n  std::vector&lt;EditType&gt; best_path;\n  for (size_t l_i = left.size(), r_i = right.size(); l_i &gt; 0 || r_i &gt; 0;) {\n    EditType move = best_move[l_i][r_i];\n    best_path.push_back(move);\n    l_i -= move != kAdd;\n    r_i -= move != kRemove;\n  }\n  std::reverse(best_path.begin(), best_path.end());\n  return best_path;\n}\n\nnamespace {\n\n// Helper class to convert string into ids with deduplication.\nclass InternalStrings {\n public:\n  size_t GetId(const std::string&amp; str) {\n    IdMap::iterator it = ids_.find(str);\n    if (it != ids_.end()) return it-&gt;second;\n    size_t id = ids_.size();\n    return ids_[str] = id;\n  }\n\n private:\n  typedef std::map&lt;std::string, size_t&gt; IdMap;\n  IdMap ids_;\n};\n\n}  // namespace\n\nstd::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;std::string&gt;&amp; left,\n    const std::vector&lt;std::string&gt;&amp; right) {\n  std::vector&lt;size_t&gt; left_ids, right_ids;\n  {\n    InternalStrings intern_table;\n    for (size_t i = 0; i &lt; left.size(); ++i) {\n      left_ids.push_back(intern_table.GetId(left[i]));\n    }\n    for (size_t i = 0; i &lt; right.size(); ++i) {\n      right_ids.push_back(intern_table.GetId(right[i]));\n    }\n  }\n  return CalculateOptimalEdits(left_ids, right_ids);\n}\n\nnamespace {\n\n// Helper class that holds the state for one hunk and prints it out to the\n// stream.\n// It reorders adds/removes when possible to group all removes before all\n// adds. It also adds the hunk header before printint into the stream.\nclass Hunk {\n public:\n  Hunk(size_t left_start, size_t right_start)\n      : left_start_(left_start),\n        right_start_(right_start),\n        adds_(),\n        removes_(),\n        common_() {}\n\n  void PushLine(char edit, const char* line) {\n    switch (edit) {\n      case &#x27; &#x27;:\n        ++common_;\n        FlushEdits();\n        hunk_.push_back(std::make_pair(&#x27; &#x27;, line));\n        break;\n      case &#x27;-&#x27;:\n        ++removes_;\n        hunk_removes_.push_back(std::make_pair(&#x27;-&#x27;, line));\n        break;\n      case &#x27;+&#x27;:\n        ++adds_;\n        hunk_adds_.push_back(std::make_pair(&#x27;+&#x27;, line));\n        break;\n    }\n  }\n\n  void PrintTo(std::ostream* os) {\n    PrintHeader(os);\n    FlushEdits();\n    for (std::list&lt;std::pair&lt;char, const char*&gt; &gt;::const_iterator it =\n             hunk_.begin();\n         it != hunk_.end(); ++it) {\n      *os &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\n    }\n  }\n\n  bool has_edits() const { return adds_ || removes_; }\n\n private:\n  void FlushEdits() {\n    hunk_.splice(hunk_.end(), hunk_removes_);\n    hunk_.splice(hunk_.end(), hunk_adds_);\n  }\n\n  // Print a unified diff header for one hunk.\n  // The format is\n  //   &quot;@@ -&lt;left_start&gt;,&lt;left_length&gt; +&lt;right_start&gt;,&lt;right_length&gt; @@&quot;\n  // where the left/right parts are omitted if unnecessary.\n  void PrintHeader(std::ostream* ss) const {\n    *ss &lt;&lt; &quot;@@ &quot;;\n    if (removes_) {\n      *ss &lt;&lt; &quot;-&quot; &lt;&lt; left_start_ &lt;&lt; &quot;,&quot; &lt;&lt; (removes_ + common_);\n    }\n    if (removes_ &amp;&amp; adds_) {\n      *ss &lt;&lt; &quot; &quot;;\n    }\n    if (adds_) {\n      *ss &lt;&lt; &quot;+&quot; &lt;&lt; right_start_ &lt;&lt; &quot;,&quot; &lt;&lt; (adds_ + common_);\n    }\n    *ss &lt;&lt; &quot; @@\\n&quot;;\n  }\n\n  size_t left_start_, right_start_;\n  size_t adds_, removes_, common_;\n  std::list&lt;std::pair&lt;char, const char*&gt; &gt; hunk_, hunk_adds_, hunk_removes_;\n};\n\n}  // namespace\n\n// Create a list of diff hunks in Unified diff format.\n// Each hunk has a header generated by PrintHeader above plus a body with\n// lines prefixed with &#x27; &#x27; for no change, &#x27;-&#x27; for deletion and &#x27;+&#x27; for\n// addition.\n// &#x27;context&#x27; represents the desired unchanged prefix/suffix around the diff.\n// If two hunks are close enough that their contexts overlap, then they are\n// joined into one hunk.\nstd::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,\n                              const std::vector&lt;std::string&gt;&amp; right,\n                              size_t context) {\n  const std::vector&lt;EditType&gt; edits = CalculateOptimalEdits(left, right);\n\n  size_t l_i = 0, r_i = 0, edit_i = 0;\n  std::stringstream ss;\n  while (edit_i &lt; edits.size()) {\n    // Find first edit.\n    while (edit_i &lt; edits.size() &amp;&amp; edits[edit_i] == kMatch) {\n      ++l_i;\n      ++r_i;\n      ++edit_i;\n    }\n\n    // Find the first line to include in the hunk.\n    const size_t prefix_context = std::min(l_i, context);\n    Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);\n    for (size_t i = prefix_context; i &gt; 0; --i) {\n      hunk.PushLine(&#x27; &#x27;, left[l_i - i].c_str());\n    }\n\n    // Iterate the edits until we found enough suffix for the hunk or the input\n    // is over.\n    size_t n_suffix = 0;\n    for (; edit_i &lt; edits.size(); ++edit_i) {\n      if (n_suffix &gt;= context) {\n        // Continue only if the next hunk is very close.\n        auto it = edits.begin() + static_cast&lt;int&gt;(edit_i);\n        while (it != edits.end() &amp;&amp; *it == kMatch) ++it;\n        if (it == edits.end() ||\n            static_cast&lt;size_t&gt;(it - edits.begin()) - edit_i &gt;= context) {\n          // There is no next edit or it is too far away.\n          break;\n        }\n      }\n\n      EditType edit = edits[edit_i];\n      // Reset count when a non match is found.\n      n_suffix = edit == kMatch ? n_suffix + 1 : 0;\n\n      if (edit == kMatch || edit == kRemove || edit == kReplace) {\n        hunk.PushLine(edit == kMatch ? &#x27; &#x27; : &#x27;-&#x27;, left[l_i].c_str());\n      }\n      if (edit == kAdd || edit == kReplace) {\n        hunk.PushLine(&#x27;+&#x27;, right[r_i].c_str());\n      }\n\n      // Advance indices, depending on edit type.\n      l_i += edit != kAdd;\n      r_i += edit != kRemove;\n    }\n\n    if (!hunk.has_edits()) {\n      // We are done. We don&#x27;t want this hunk.\n      break;\n    }\n\n    hunk.PrintTo(&amp;ss);\n  }\n  return ss.str();\n}\n\n}  // namespace edit_distance\n\nnamespace {\n\n// The string representation of the values received in EqFailure() are already\n// escaped. Split them on escaped &#x27;\\n&#x27; boundaries. Leave all other escaped\n// characters the same.\nstd::vector&lt;std::string&gt; SplitEscapedString(const std::string&amp; str) {\n  std::vector&lt;std::string&gt; lines;\n  size_t start = 0, end = str.size();\n  if (end &gt; 2 &amp;&amp; str[0] == &#x27;&quot;&#x27; &amp;&amp; str[end - 1] == &#x27;&quot;&#x27;) {\n    ++start;\n    --end;\n  }\n  bool escaped = false;\n  for (size_t i = start; i + 1 &lt; end; ++i) {\n    if (escaped) {\n      escaped = false;\n      if (str[i] == &#x27;n&#x27;) {\n        lines.push_back(str.substr(start, i - start - 1));\n        start = i + 1;\n      }\n    } else {\n      escaped = str[i] == &#x27;\\\\&#x27;;\n    }\n  }\n  lines.push_back(str.substr(start, end - start));\n  return lines;\n}\n\n}  // namespace\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   lhs_expression: &quot;foo&quot;\n//   rhs_expression: &quot;bar&quot;\n//   lhs_value:      &quot;5&quot;\n//   rhs_value:      &quot;6&quot;\n//\n// The ignoring_case parameter is true if and only if the assertion is a\n// *_STRCASEEQ*.  When it&#x27;s true, the string &quot;Ignoring case&quot; will\n// be inserted into the message.\nAssertionResult EqFailure(const char* lhs_expression,\n                          const char* rhs_expression,\n                          const std::string&amp; lhs_value,\n                          const std::string&amp; rhs_value, bool ignoring_case) {\n  Message msg;\n  msg &lt;&lt; &quot;Expected equality of these values:&quot;;\n  msg &lt;&lt; &quot;\\n  &quot; &lt;&lt; lhs_expression;\n  if (lhs_value != lhs_expression) {\n    msg &lt;&lt; &quot;\\n    Which is: &quot; &lt;&lt; lhs_value;\n  }\n  msg &lt;&lt; &quot;\\n  &quot; &lt;&lt; rhs_expression;\n  if (rhs_value != rhs_expression) {\n    msg &lt;&lt; &quot;\\n    Which is: &quot; &lt;&lt; rhs_value;\n  }\n\n  if (ignoring_case) {\n    msg &lt;&lt; &quot;\\nIgnoring case&quot;;\n  }\n\n  if (!lhs_value.empty() &amp;&amp; !rhs_value.empty()) {\n    const std::vector&lt;std::string&gt; lhs_lines = SplitEscapedString(lhs_value);\n    const std::vector&lt;std::string&gt; rhs_lines = SplitEscapedString(rhs_value);\n    if (lhs_lines.size() &gt; 1 || rhs_lines.size() &gt; 1) {\n      msg &lt;&lt; &quot;\\nWith diff:\\n&quot;\n          &lt;&lt; edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\n    }\n  }\n\n  return AssertionFailure() &lt;&lt; msg;\n}\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nstd::string GetBoolAssertionFailureMessage(\n    const AssertionResult&amp; assertion_result, const char* expression_text,\n    const char* actual_predicate_value, const char* expected_predicate_value) {\n  const char* actual_message = assertion_result.message();\n  Message msg;\n  msg &lt;&lt; &quot;Value of: &quot; &lt;&lt; expression_text\n      &lt;&lt; &quot;\\n  Actual: &quot; &lt;&lt; actual_predicate_value;\n  if (actual_message[0] != &#x27;\\0&#x27;) msg &lt;&lt; &quot; (&quot; &lt;&lt; actual_message &lt;&lt; &quot;)&quot;;\n  msg &lt;&lt; &quot;\\nExpected: &quot; &lt;&lt; expected_predicate_value;\n  return msg.GetString();\n}\n\n// Helper function for implementing ASSERT_NEAR.\nAssertionResult DoubleNearPredFormat(const char* expr1, const char* expr2,\n                                     const char* abs_error_expr, double val1,\n                                     double val2, double abs_error) {\n  const double diff = fabs(val1 - val2);\n  if (diff &lt;= abs_error) return AssertionSuccess();\n\n  // Find the value which is closest to zero.\n  const double min_abs = std::min(fabs(val1), fabs(val2));\n  // Find the distance to the next double from that value.\n  const double epsilon =\n      nextafter(min_abs, std::numeric_limits&lt;double&gt;::infinity()) - min_abs;\n  // Detect the case where abs_error is so small that EXPECT_NEAR is\n  // effectively the same as EXPECT_EQUAL, and give an informative error\n  // message so that the situation can be more easily understood without\n  // requiring exotic floating-point knowledge.\n  // Don&#x27;t do an epsilon check if abs_error is zero because that implies\n  // that an equality check was actually intended.\n  if (!(std::isnan)(val1) &amp;&amp; !(std::isnan)(val2) &amp;&amp; abs_error &gt; 0 &amp;&amp;\n      abs_error &lt; epsilon) {\n    return AssertionFailure()\n           &lt;&lt; &quot;The difference between &quot; &lt;&lt; expr1 &lt;&lt; &quot; and &quot; &lt;&lt; expr2 &lt;&lt; &quot; is &quot;\n           &lt;&lt; diff &lt;&lt; &quot;, where\\n&quot;\n           &lt;&lt; expr1 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val1 &lt;&lt; &quot;,\\n&quot;\n           &lt;&lt; expr2 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val2 &lt;&lt; &quot;.\\nThe abs_error parameter &quot;\n           &lt;&lt; abs_error_expr &lt;&lt; &quot; evaluates to &quot; &lt;&lt; abs_error\n           &lt;&lt; &quot; which is smaller than the minimum distance between doubles for &quot;\n              &quot;numbers of this magnitude which is &quot;\n           &lt;&lt; epsilon\n           &lt;&lt; &quot;, thus making this EXPECT_NEAR check equivalent to &quot;\n              &quot;EXPECT_EQUAL. Consider using EXPECT_DOUBLE_EQ instead.&quot;;\n  }\n  return AssertionFailure()\n         &lt;&lt; &quot;The difference between &quot; &lt;&lt; expr1 &lt;&lt; &quot; and &quot; &lt;&lt; expr2 &lt;&lt; &quot; is &quot;\n         &lt;&lt; diff &lt;&lt; &quot;, which exceeds &quot; &lt;&lt; abs_error_expr &lt;&lt; &quot;, where\\n&quot;\n         &lt;&lt; expr1 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val1 &lt;&lt; &quot;,\\n&quot;\n         &lt;&lt; expr2 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val2 &lt;&lt; &quot;, and\\n&quot;\n         &lt;&lt; abs_error_expr &lt;&lt; &quot; evaluates to &quot; &lt;&lt; abs_error &lt;&lt; &quot;.&quot;;\n}\n\n// Helper template for implementing FloatLE() and DoubleLE().\ntemplate &lt;typename RawType&gt;\nAssertionResult FloatingPointLE(const char* expr1, const char* expr2,\n                                RawType val1, RawType val2) {\n  // Returns success if val1 is less than val2,\n  if (val1 &lt; val2) {\n    return AssertionSuccess();\n  }\n\n  // or if val1 is almost equal to val2.\n  const FloatingPoint&lt;RawType&gt; lhs(val1), rhs(val2);\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  // Note that the above two checks will both fail if either val1 or\n  // val2 is NaN, as the IEEE floating-point standard requires that\n  // any predicate involving a NaN must return false.\n\n  ::std::stringstream val1_ss;\n  val1_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n          &lt;&lt; val1;\n\n  ::std::stringstream val2_ss;\n  val2_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n          &lt;&lt; val2;\n\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; expr1 &lt;&lt; &quot;) &lt;= (&quot; &lt;&lt; expr2 &lt;&lt; &quot;)\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; StringStreamToString(&amp;val1_ss) &lt;&lt; &quot; vs &quot;\n         &lt;&lt; StringStreamToString(&amp;val2_ss);\n}\n\n}  // namespace internal\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nAssertionResult FloatLE(const char* expr1, const char* expr2, float val1,\n                        float val2) {\n  return internal::FloatingPointLE&lt;float&gt;(expr1, expr2, val1, val2);\n}\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nAssertionResult DoubleLE(const char* expr1, const char* expr2, double val1,\n                         double val2) {\n  return internal::FloatingPointLE&lt;double&gt;(expr1, expr2, val1, val2);\n}\n\nnamespace internal {\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\nAssertionResult CmpHelperSTREQ(const char* lhs_expression,\n                               const char* rhs_expression, const char* lhs,\n                               const char* rhs) {\n  if (String::CStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), false);\n}\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\nAssertionResult CmpHelperSTRCASEEQ(const char* lhs_expression,\n                                   const char* rhs_expression, const char* lhs,\n                                   const char* rhs) {\n  if (String::CaseInsensitiveCStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), true);\n}\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\nAssertionResult CmpHelperSTRNE(const char* s1_expression,\n                               const char* s2_expression, const char* s1,\n                               const char* s2) {\n  if (!String::CStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  } else {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n           &lt;&lt; &quot;), actual: \\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; vs \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot;;\n  }\n}\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\nAssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                   const char* s2_expression, const char* s1,\n                                   const char* s2) {\n  if (!String::CaseInsensitiveCStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  } else {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n           &lt;&lt; &quot;) (ignoring case), actual: \\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; vs \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot;;\n  }\n}\n\n}  // namespace internal\n\nnamespace {\n\n// Helper functions for implementing IsSubString() and IsNotSubstring().\n\n// This group of overloaded functions return true if and only if needle\n// is a substring of haystack.  NULL is considered a substring of\n// itself only.\n\nbool IsSubstringPred(const char* needle, const char* haystack) {\n  if (needle == nullptr || haystack == nullptr) return needle == haystack;\n\n  return strstr(haystack, needle) != nullptr;\n}\n\nbool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {\n  if (needle == nullptr || haystack == nullptr) return needle == haystack;\n\n  return wcsstr(haystack, needle) != nullptr;\n}\n\n// StringType here can be either ::std::string or ::std::wstring.\ntemplate &lt;typename StringType&gt;\nbool IsSubstringPred(const StringType&amp; needle, const StringType&amp; haystack) {\n  return haystack.find(needle) != StringType::npos;\n}\n\n// This function implements either IsSubstring() or IsNotSubstring(),\n// depending on the value of the expected_to_be_substring parameter.\n// StringType here can be const char*, const wchar_t*, ::std::string,\n// or ::std::wstring.\ntemplate &lt;typename StringType&gt;\nAssertionResult IsSubstringImpl(bool expected_to_be_substring,\n                                const char* needle_expr,\n                                const char* haystack_expr,\n                                const StringType&amp; needle,\n                                const StringType&amp; haystack) {\n  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)\n    return AssertionSuccess();\n\n  const bool is_wide_string = sizeof(needle[0]) &gt; 1;\n  const char* const begin_string_quote = is_wide_string ? &quot;L\\&quot;&quot; : &quot;\\&quot;&quot;;\n  return AssertionFailure()\n         &lt;&lt; &quot;Value of: &quot; &lt;&lt; needle_expr &lt;&lt; &quot;\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; begin_string_quote &lt;&lt; needle &lt;&lt; &quot;\\&quot;\\n&quot;\n         &lt;&lt; &quot;Expected: &quot; &lt;&lt; (expected_to_be_substring ? &quot;&quot; : &quot;not &quot;)\n         &lt;&lt; &quot;a substring of &quot; &lt;&lt; haystack_expr &lt;&lt; &quot;\\n&quot;\n         &lt;&lt; &quot;Which is: &quot; &lt;&lt; begin_string_quote &lt;&lt; haystack &lt;&lt; &quot;\\&quot;&quot;;\n}\n\n}  // namespace\n\n// IsSubstring() and IsNotSubstring() check whether needle is a\n// substring of haystack (NULL is considered a substring of itself\n// only), and return an appropriate error message when they fail.\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const char* needle, const char* haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const wchar_t* needle, const wchar_t* haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr, const char* needle,\n                               const char* haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr, const wchar_t* needle,\n                               const wchar_t* haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const ::std::string&amp; needle,\n                            const ::std::string&amp; haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr,\n                               const ::std::string&amp; needle,\n                               const ::std::string&amp; haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\n#if GTEST_HAS_STD_WSTRING\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const ::std::wstring&amp; needle,\n                            const ::std::wstring&amp; haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr,\n                               const ::std::wstring&amp; needle,\n                               const ::std::wstring&amp; haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n#if GTEST_OS_WINDOWS\n\nnamespace {\n\n// Helper function for IsHRESULT{SuccessFailure} predicates\nAssertionResult HRESULTFailureHelper(const char* expr, const char* expected,\n                                     long hr) {  // NOLINT\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_TV_TITLE\n\n  // Windows CE doesn&#x27;t support FormatMessage.\n  const char error_text[] = &quot;&quot;;\n\n#else\n\n  // Looks up the human-readable system message for the HRESULT code\n  // and since we&#x27;re not passing any params to FormatMessage, we don&#x27;t\n  // want inserts expanded.\n  const DWORD kFlags =\n      FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;\n  const DWORD kBufSize = 4096;\n  // Gets the system&#x27;s human readable message string for this HRESULT.\n  char error_text[kBufSize] = {&#x27;\\0&#x27;};\n  DWORD message_length = ::FormatMessageA(kFlags,\n                                          0,  // no source, we&#x27;re asking system\n                                          static_cast&lt;DWORD&gt;(hr),  // the error\n                                          0,  // no line width restrictions\n                                          error_text,  // output buffer\n                                          kBufSize,    // buf size\n                                          nullptr);  // no arguments for inserts\n  // Trims tailing white space (FormatMessage leaves a trailing CR-LF)\n  for (; message_length &amp;&amp; IsSpace(error_text[message_length - 1]);\n       --message_length) {\n    error_text[message_length - 1] = &#x27;\\0&#x27;;\n  }\n\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n  const std::string error_hex(&quot;0x&quot; + String::FormatHexInt(hr));\n  return ::testing::AssertionFailure()\n         &lt;&lt; &quot;Expected: &quot; &lt;&lt; expr &lt;&lt; &quot; &quot; &lt;&lt; expected &lt;&lt; &quot;.\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; error_hex &lt;&lt; &quot; &quot; &lt;&lt; error_text &lt;&lt; &quot;\\n&quot;;\n}\n\n}  // namespace\n\nAssertionResult IsHRESULTSuccess(const char* expr, long hr) {  // NOLINT\n  if (SUCCEEDED(hr)) {\n    return AssertionSuccess();\n  }\n  return HRESULTFailureHelper(expr, &quot;succeeds&quot;, hr);\n}\n\nAssertionResult IsHRESULTFailure(const char* expr, long hr) {  // NOLINT\n  if (FAILED(hr)) {\n    return AssertionSuccess();\n  }\n  return HRESULTFailureHelper(expr, &quot;fails&quot;, hr);\n}\n\n#endif  // GTEST_OS_WINDOWS\n\n// Utility functions for encoding Unicode text (wide strings) in\n// UTF-8.\n\n// A Unicode code-point can have up to 21 bits, and is encoded in UTF-8\n// like this:\n//\n// Code-point length   Encoding\n//   0 -  7 bits       0xxxxxxx\n//   8 - 11 bits       110xxxxx 10xxxxxx\n//  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx\n//  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n// The maximum code-point a one-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint1 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; 7) - 1;\n\n// The maximum code-point a two-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint2 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (5 + 6)) - 1;\n\n// The maximum code-point a three-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint3 =\n    (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (4 + 2 * 6)) - 1;\n\n// The maximum code-point a four-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint4 =\n    (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (3 + 3 * 6)) - 1;\n\n// Chops off the n lowest bits from a bit pattern.  Returns the n\n// lowest bits.  As a side effect, the original bit pattern will be\n// shifted to the right by n bits.\ninline uint32_t ChopLowBits(uint32_t* bits, int n) {\n  const uint32_t low_bits = *bits &amp; ((static_cast&lt;uint32_t&gt;(1) &lt;&lt; n) - 1);\n  *bits &gt;&gt;= n;\n  return low_bits;\n}\n\n// Converts a Unicode code point to a narrow string in UTF-8 encoding.\n// code_point parameter is of type uint32_t because wchar_t may not be\n// wide enough to contain a code point.\n// If the code_point is not a valid Unicode code point\n// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted\n// to &quot;(Invalid Unicode 0xXXXXXXXX)&quot;.\nstd::string CodePointToUtf8(uint32_t code_point) {\n  if (code_point &gt; kMaxCodePoint4) {\n    return &quot;(Invalid Unicode 0x&quot; + String::FormatHexUInt32(code_point) + &quot;)&quot;;\n  }\n\n  char str[5];  // Big enough for the largest valid code point.\n  if (code_point &lt;= kMaxCodePoint1) {\n    str[1] = &#x27;\\0&#x27;;\n    str[0] = static_cast&lt;char&gt;(code_point);  // 0xxxxxxx\n  } else if (code_point &lt;= kMaxCodePoint2) {\n    str[2] = &#x27;\\0&#x27;;\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xC0 | code_point);                   // 110xxxxx\n  } else if (code_point &lt;= kMaxCodePoint3) {\n    str[3] = &#x27;\\0&#x27;;\n    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xE0 | code_point);                   // 1110xxxx\n  } else {  // code_point &lt;= kMaxCodePoint4\n    str[4] = &#x27;\\0&#x27;;\n    str[3] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xF0 | code_point);                   // 11110xxx\n  }\n  return str;\n}\n\n// The following two functions only make sense if the system\n// uses UTF-16 for wide string encoding. All supported systems\n// with 16 bit wchar_t (Windows, Cygwin) do use UTF-16.\n\n// Determines if the arguments constitute UTF-16 surrogate pair\n// and thus should be combined into a single Unicode code point\n// using CreateCodePointFromUtf16SurrogatePair.\ninline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {\n  return sizeof(wchar_t) == 2 &amp;&amp; (first &amp; 0xFC00) == 0xD800 &amp;&amp;\n         (second &amp; 0xFC00) == 0xDC00;\n}\n\n// Creates a Unicode code point from UTF16 surrogate pair.\ninline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,\n                                                      wchar_t second) {\n  const auto first_u = static_cast&lt;uint32_t&gt;(first);\n  const auto second_u = static_cast&lt;uint32_t&gt;(second);\n  const uint32_t mask = (1 &lt;&lt; 10) - 1;\n  return (sizeof(wchar_t) == 2)\n             ? (((first_u &amp; mask) &lt;&lt; 10) | (second_u &amp; mask)) + 0x10000\n             :\n             // This function should not be called when the condition is\n             // false, but we provide a sensible default in case it is.\n             first_u;\n}\n\n// Converts a wide string to a narrow string in UTF-8 encoding.\n// The wide string is assumed to have the following encoding:\n//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)\n//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)\n// Parameter str points to a null-terminated wide string.\n// Parameter num_chars may additionally limit the number\n// of wchar_t characters processed. -1 is used when the entire string\n// should be processed.\n// If the string contains code points that are not valid Unicode code points\n// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output\n// as &#x27;(Invalid Unicode 0xXXXXXXXX)&#x27;. If the string is in UTF16 encoding\n// and contains invalid UTF-16 surrogate pairs, values in those pairs\n// will be encoded as individual Unicode characters from Basic Normal Plane.\nstd::string WideStringToUtf8(const wchar_t* str, int num_chars) {\n  if (num_chars == -1) num_chars = static_cast&lt;int&gt;(wcslen(str));\n\n  ::std::stringstream stream;\n  for (int i = 0; i &lt; num_chars; ++i) {\n    uint32_t unicode_code_point;\n\n    if (str[i] == L&#x27;\\0&#x27;) {\n      break;\n    } else if (i + 1 &lt; num_chars &amp;&amp; IsUtf16SurrogatePair(str[i], str[i + 1])) {\n      unicode_code_point =\n          CreateCodePointFromUtf16SurrogatePair(str[i], str[i + 1]);\n      i++;\n    } else {\n      unicode_code_point = static_cast&lt;uint32_t&gt;(str[i]);\n    }\n\n    stream &lt;&lt; CodePointToUtf8(unicode_code_point);\n  }\n  return StringStreamToString(&amp;stream);\n}\n\n// Converts a wide C string to an std::string using the UTF-8 encoding.\n// NULL will be converted to &quot;(null)&quot;.\nstd::string String::ShowWideCString(const wchar_t* wide_c_str) {\n  if (wide_c_str == nullptr) return &quot;(null)&quot;;\n\n  return internal::WideStringToUtf8(wide_c_str, -1);\n}\n\n// Compares two wide C strings.  Returns true if and only if they have the\n// same content.\n//\n// Unlike wcscmp(), this function can handle NULL argument(s).  A NULL\n// C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n  return wcscmp(lhs, rhs) == 0;\n}\n\n// Helper function for *_STREQ on wide strings.\nAssertionResult CmpHelperSTREQ(const char* lhs_expression,\n                               const char* rhs_expression, const wchar_t* lhs,\n                               const wchar_t* rhs) {\n  if (String::WideCStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), false);\n}\n\n// Helper function for *_STRNE on wide strings.\nAssertionResult CmpHelperSTRNE(const char* s1_expression,\n                               const char* s2_expression, const wchar_t* s1,\n                               const wchar_t* s2) {\n  if (!String::WideCStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  }\n\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n         &lt;&lt; &quot;), actual: &quot; &lt;&lt; PrintToString(s1) &lt;&lt; &quot; vs &quot; &lt;&lt; PrintToString(s2);\n}\n\n// Compares two C strings, ignoring case.  Returns true if and only if they have\n// the same content.\n//\n// Unlike strcasecmp(), this function can handle NULL argument(s).  A\n// NULL C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n  if (rhs == nullptr) return false;\n  return posix::StrCaseCmp(lhs, rhs) == 0;\n}\n\n// Compares two wide C strings, ignoring case.  Returns true if and only if they\n// have the same content.\n//\n// Unlike wcscasecmp(), this function can handle NULL argument(s).\n// A NULL C string is considered different to any non-NULL wide C string,\n// including the empty string.\n// NB: The implementations on different platforms slightly differ.\n// On windows, this method uses _wcsicmp which compares according to LC_CTYPE\n// environment variable. On GNU platform this method uses wcscasecmp\n// which compares according to LC_CTYPE category of the current locale.\n// On MacOS X, it uses towlower, which also uses LC_CTYPE category of the\n// current locale.\nbool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,\n                                              const wchar_t* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n#if GTEST_OS_WINDOWS\n  return _wcsicmp(lhs, rhs) == 0;\n#elif GTEST_OS_LINUX &amp;&amp; !GTEST_OS_LINUX_ANDROID\n  return wcscasecmp(lhs, rhs) == 0;\n#else\n  // Android, Mac OS X and Cygwin don&#x27;t define wcscasecmp.\n  // Other unknown OSes may not define it either.\n  wint_t left, right;\n  do {\n    left = towlower(static_cast&lt;wint_t&gt;(*lhs++));\n    right = towlower(static_cast&lt;wint_t&gt;(*rhs++));\n  } while (left &amp;&amp; left == right);\n  return left == right;\n#endif  // OS selector\n}\n\n// Returns true if and only if str ends with the given suffix, ignoring case.\n// Any string is considered to end with an empty suffix.\nbool String::EndsWithCaseInsensitive(const std::string&amp; str,\n                                     const std::string&amp; suffix) {\n  const size_t str_len = str.length();\n  const size_t suffix_len = suffix.length();\n  return (str_len &gt;= suffix_len) &amp;&amp;\n         CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,\n                                      suffix.c_str());\n}\n\n// Formats an int value as &quot;%02d&quot;.\nstd::string String::FormatIntWidth2(int value) {\n  return FormatIntWidthN(value, 2);\n}\n\n// Formats an int value to given width with leading zeros.\nstd::string String::FormatIntWidthN(int value, int width) {\n  std::stringstream ss;\n  ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(width) &lt;&lt; value;\n  return ss.str();\n}\n\n// Formats an int value as &quot;%X&quot;.\nstd::string String::FormatHexUInt32(uint32_t value) {\n  std::stringstream ss;\n  ss &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; value;\n  return ss.str();\n}\n\n// Formats an int value as &quot;%X&quot;.\nstd::string String::FormatHexInt(int value) {\n  return FormatHexUInt32(static_cast&lt;uint32_t&gt;(value));\n}\n\n// Formats a byte as &quot;%02X&quot;.\nstd::string String::FormatByte(unsigned char value) {\n  std::stringstream ss;\n  ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; std::uppercase\n     &lt;&lt; static_cast&lt;unsigned int&gt;(value);\n  return ss.str();\n}\n\n// Converts the buffer in a stringstream to an std::string, converting NUL\n// bytes to &quot;\\\\0&quot; along the way.\nstd::string StringStreamToString(::std::stringstream* ss) {\n  const ::std::string&amp; str = ss-&gt;str();\n  const char* const start = str.c_str();\n  const char* const end = start + str.length();\n\n  std::string result;\n  result.reserve(static_cast&lt;size_t&gt;(2 * (end - start)));\n  for (const char* ch = start; ch != end; ++ch) {\n    if (*ch == &#x27;\\0&#x27;) {\n      result += &quot;\\\\0&quot;;  // Replaces NUL with &quot;\\\\0&quot;;\n    } else {\n      result += *ch;\n    }\n  }\n\n  return result;\n}\n\n// Appends the user-supplied message to the Google-Test-generated message.\nstd::string AppendUserMessage(const std::string&amp; gtest_msg,\n                              const Message&amp; user_msg) {\n  // Appends the user message if it&#x27;s non-empty.\n  const std::string user_msg_string = user_msg.GetString();\n  if (user_msg_string.empty()) {\n    return gtest_msg;\n  }\n  if (gtest_msg.empty()) {\n    return user_msg_string;\n  }\n  return gtest_msg + &quot;\\n&quot; + user_msg_string;\n}\n\n}  // namespace internal\n\n// class TestResult\n\n// Creates an empty TestResult.\nTestResult::TestResult()\n    : death_test_count_(0), start_timestamp_(0), elapsed_time_(0) {}\n\n// D&#x27;tor.\nTestResult::~TestResult() {}\n\n// Returns the i-th test part result among all the results. i can\n// range from 0 to total_part_count() - 1. If i is not in that range,\n// aborts the program.\nconst TestPartResult&amp; TestResult::GetTestPartResult(int i) const {\n  if (i &lt; 0 || i &gt;= total_part_count()) internal::posix::Abort();\n  return test_part_results_.at(static_cast&lt;size_t&gt;(i));\n}\n\n// Returns the i-th test property. i can range from 0 to\n// test_property_count() - 1. If i is not in that range, aborts the\n// program.\nconst TestProperty&amp; TestResult::GetTestProperty(int i) const {\n  if (i &lt; 0 || i &gt;= test_property_count()) internal::posix::Abort();\n  return test_properties_.at(static_cast&lt;size_t&gt;(i));\n}\n\n// Clears the test part results.\nvoid TestResult::ClearTestPartResults() { test_part_results_.clear(); }\n\n// Adds a test part result to the list.\nvoid TestResult::AddTestPartResult(const TestPartResult&amp; test_part_result) {\n  test_part_results_.push_back(test_part_result);\n}\n\n// Adds a test property to the list. If a property with the same key as the\n// supplied property is already represented, the value of this test_property\n// replaces the old value for that key.\nvoid TestResult::RecordProperty(const std::string&amp; xml_element,\n                                const TestProperty&amp; test_property) {\n  if (!ValidateTestProperty(xml_element, test_property)) {\n    return;\n  }\n  internal::MutexLock lock(&amp;test_properties_mutex_);\n  const std::vector&lt;TestProperty&gt;::iterator property_with_matching_key =\n      std::find_if(test_properties_.begin(), test_properties_.end(),\n                   internal::TestPropertyKeyIs(test_property.key()));\n  if (property_with_matching_key == test_properties_.end()) {\n    test_properties_.push_back(test_property);\n    return;\n  }\n  property_with_matching_key-&gt;SetValue(test_property.value());\n}\n\n// The list of reserved attributes used in the &lt;testsuites&gt; element of XML\n// output.\nstatic const char* const kReservedTestSuitesAttributes[] = {\n    &quot;disabled&quot;,    &quot;errors&quot;, &quot;failures&quot;, &quot;name&quot;,\n    &quot;random_seed&quot;, &quot;tests&quot;,  &quot;time&quot;,     &quot;timestamp&quot;};\n\n// The list of reserved attributes used in the &lt;testsuite&gt; element of XML\n// output.\nstatic const char* const kReservedTestSuiteAttributes[] = {\n    &quot;disabled&quot;, &quot;errors&quot;, &quot;failures&quot;,  &quot;name&quot;,\n    &quot;tests&quot;,    &quot;time&quot;,   &quot;timestamp&quot;, &quot;skipped&quot;};\n\n// The list of reserved attributes used in the &lt;testcase&gt; element of XML output.\nstatic const char* const kReservedTestCaseAttributes[] = {\n    &quot;classname&quot;,  &quot;name&quot;,        &quot;status&quot;, &quot;time&quot;,\n    &quot;type_param&quot;, &quot;value_param&quot;, &quot;file&quot;,   &quot;line&quot;};\n\n// Use a slightly different set for allowed output to ensure existing tests can\n// still RecordProperty(&quot;result&quot;) or &quot;RecordProperty(timestamp&quot;)\nstatic const char* const kReservedOutputTestCaseAttributes[] = {\n    &quot;classname&quot;,   &quot;name&quot;, &quot;status&quot;, &quot;time&quot;,   &quot;type_param&quot;,\n    &quot;value_param&quot;, &quot;file&quot;, &quot;line&quot;,   &quot;result&quot;, &quot;timestamp&quot;};\n\ntemplate &lt;size_t kSize&gt;\nstd::vector&lt;std::string&gt; ArrayAsVector(const char* const (&amp;array)[kSize]) {\n  return std::vector&lt;std::string&gt;(array, array + kSize);\n}\n\nstatic std::vector&lt;std::string&gt; GetReservedAttributesForElement(\n    const std::string&amp; xml_element) {\n  if (xml_element == &quot;testsuites&quot;) {\n    return ArrayAsVector(kReservedTestSuitesAttributes);\n  } else if (xml_element == &quot;testsuite&quot;) {\n    return ArrayAsVector(kReservedTestSuiteAttributes);\n  } else if (xml_element == &quot;testcase&quot;) {\n    return ArrayAsVector(kReservedTestCaseAttributes);\n  } else {\n    GTEST_CHECK_(false) &lt;&lt; &quot;Unrecognized xml_element provided: &quot; &lt;&lt; xml_element;\n  }\n  // This code is unreachable but some compilers may not realizes that.\n  return std::vector&lt;std::string&gt;();\n}\n\n// TODO(jdesprez): Merge the two getReserved attributes once skip is improved\nstatic std::vector&lt;std::string&gt; GetReservedOutputAttributesForElement(\n    const std::string&amp; xml_element) {\n  if (xml_element == &quot;testsuites&quot;) {\n    return ArrayAsVector(kReservedTestSuitesAttributes);\n  } else if (xml_element == &quot;testsuite&quot;) {\n    return ArrayAsVector(kReservedTestSuiteAttributes);\n  } else if (xml_element == &quot;testcase&quot;) {\n    return ArrayAsVector(kReservedOutputTestCaseAttributes);\n  } else {\n    GTEST_CHECK_(false) &lt;&lt; &quot;Unrecognized xml_element provided: &quot; &lt;&lt; xml_element;\n  }\n  // This code is unreachable but some compilers may not realizes that.\n  return std::vector&lt;std::string&gt;();\n}\n\nstatic std::string FormatWordList(const std::vector&lt;std::string&gt;&amp; words) {\n  Message word_list;\n  for (size_t i = 0; i &lt; words.size(); ++i) {\n    if (i &gt; 0 &amp;&amp; words.size() &gt; 2) {\n      word_list &lt;&lt; &quot;, &quot;;\n    }\n    if (i == words.size() - 1) {\n      word_list &lt;&lt; &quot;and &quot;;\n    }\n    word_list &lt;&lt; &quot;&#x27;&quot; &lt;&lt; words[i] &lt;&lt; &quot;&#x27;&quot;;\n  }\n  return word_list.GetString();\n}\n\nstatic bool ValidateTestPropertyName(\n    const std::string&amp; property_name,\n    const std::vector&lt;std::string&gt;&amp; reserved_names) {\n  if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=\n      reserved_names.end()) {\n    ADD_FAILURE() &lt;&lt; &quot;Reserved key used in RecordProperty(): &quot; &lt;&lt; property_name\n                  &lt;&lt; &quot; (&quot; &lt;&lt; FormatWordList(reserved_names)\n                  &lt;&lt; &quot; are reserved by &quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot;)&quot;;\n    return false;\n  }\n  return true;\n}\n\n// Adds a failure if the key is a reserved attribute of the element named\n// xml_element.  Returns true if the property is valid.\nbool TestResult::ValidateTestProperty(const std::string&amp; xml_element,\n                                      const TestProperty&amp; test_property) {\n  return ValidateTestPropertyName(test_property.key(),\n                                  GetReservedAttributesForElement(xml_element));\n}\n\n// Clears the object.\nvoid TestResult::Clear() {\n  test_part_results_.clear();\n  test_properties_.clear();\n  death_test_count_ = 0;\n  elapsed_time_ = 0;\n}\n\n// Returns true off the test part was skipped.\nstatic bool TestPartSkipped(const TestPartResult&amp; result) {\n  return result.skipped();\n}\n\n// Returns true if and only if the test was skipped.\nbool TestResult::Skipped() const {\n  return !Failed() &amp;&amp; CountIf(test_part_results_, TestPartSkipped) &gt; 0;\n}\n\n// Returns true if and only if the test failed.\nbool TestResult::Failed() const {\n  for (int i = 0; i &lt; total_part_count(); ++i) {\n    if (GetTestPartResult(i).failed()) return true;\n  }\n  return false;\n}\n\n// Returns true if and only if the test part fatally failed.\nstatic bool TestPartFatallyFailed(const TestPartResult&amp; result) {\n  return result.fatally_failed();\n}\n\n// Returns true if and only if the test fatally failed.\nbool TestResult::HasFatalFailure() const {\n  return CountIf(test_part_results_, TestPartFatallyFailed) &gt; 0;\n}\n\n// Returns true if and only if the test part non-fatally failed.\nstatic bool TestPartNonfatallyFailed(const TestPartResult&amp; result) {\n  return result.nonfatally_failed();\n}\n\n// Returns true if and only if the test has a non-fatal failure.\nbool TestResult::HasNonfatalFailure() const {\n  return CountIf(test_part_results_, TestPartNonfatallyFailed) &gt; 0;\n}\n\n// Gets the number of all test parts.  This is the sum of the number\n// of successful test parts and the number of failed test parts.\nint TestResult::total_part_count() const {\n  return static_cast&lt;int&gt;(test_part_results_.size());\n}\n\n// Returns the number of the test properties.\nint TestResult::test_property_count() const {\n  return static_cast&lt;int&gt;(test_properties_.size());\n}\n\n// class Test\n\n// Creates a Test object.\n\n// The c&#x27;tor saves the states of all flags.\nTest::Test() : gtest_flag_saver_(new GTEST_FLAG_SAVER_) {}\n\n// The d&#x27;tor restores the states of all flags.  The actual work is\n// done by the d&#x27;tor of the gtest_flag_saver_ field, and thus not\n// visible here.\nTest::~Test() {}\n\n// Sets up the test fixture.\n//\n// A sub-class may override this.\nvoid Test::SetUp() {}\n\n// Tears down the test fixture.\n//\n// A sub-class may override this.\nvoid Test::TearDown() {}\n\n// Allows user supplied key value pairs to be recorded for later output.\nvoid Test::RecordProperty(const std::string&amp; key, const std::string&amp; value) {\n  UnitTest::GetInstance()-&gt;RecordProperty(key, value);\n}\n\n// Allows user supplied key value pairs to be recorded for later output.\nvoid Test::RecordProperty(const std::string&amp; key, int value) {\n  Message value_message;\n  value_message &lt;&lt; value;\n  RecordProperty(key, value_message.GetString().c_str());\n}\n\nnamespace internal {\n\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string&amp; message) {\n  // This function is a friend of UnitTest and as such has access to\n  // AddTestPartResult.\n  UnitTest::GetInstance()-&gt;AddTestPartResult(\n      result_type,\n      nullptr,  // No info about the source file where the exception occurred.\n      -1,       // We have no info on which line caused the exception.\n      message,\n      &quot;&quot;);  // No stack trace, either.\n}\n\n}  // namespace internal\n\n// Google Test requires all tests in the same test suite to use the same test\n// fixture class.  This function checks if the current test has the\n// same fixture class as the first test in the current test suite.  If\n// yes, it returns true; otherwise it generates a Google Test failure and\n// returns false.\nbool Test::HasSameFixtureClass() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  const TestSuite* const test_suite = impl-&gt;current_test_suite();\n\n  // Info about the first test in the current test suite.\n  const TestInfo* const first_test_info = test_suite-&gt;test_info_list()[0];\n  const internal::TypeId first_fixture_id = first_test_info-&gt;fixture_class_id_;\n  const char* const first_test_name = first_test_info-&gt;name();\n\n  // Info about the current test.\n  const TestInfo* const this_test_info = impl-&gt;current_test_info();\n  const internal::TypeId this_fixture_id = this_test_info-&gt;fixture_class_id_;\n  const char* const this_test_name = this_test_info-&gt;name();\n\n  if (this_fixture_id != first_fixture_id) {\n    // Is the first test defined using TEST?\n    const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();\n    // Is this test defined using TEST?\n    const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();\n\n    if (first_is_TEST || this_is_TEST) {\n      // Both TEST and TEST_F appear in same test suite, which is incorrect.\n      // Tell the user how to fix this.\n\n      // Gets the name of the TEST and the name of the TEST_F.  Note\n      // that first_is_TEST and this_is_TEST cannot both be true, as\n      // the fixture IDs are different for the two tests.\n      const char* const TEST_name =\n          first_is_TEST ? first_test_name : this_test_name;\n      const char* const TEST_F_name =\n          first_is_TEST ? this_test_name : first_test_name;\n\n      ADD_FAILURE()\n          &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n          &lt;&lt; &quot;class, so mixing TEST_F and TEST in the same test suite is\\n&quot;\n          &lt;&lt; &quot;illegal.  In test suite &quot; &lt;&lt; this_test_info-&gt;test_suite_name()\n          &lt;&lt; &quot;,\\n&quot;\n          &lt;&lt; &quot;test &quot; &lt;&lt; TEST_F_name &lt;&lt; &quot; is defined using TEST_F but\\n&quot;\n          &lt;&lt; &quot;test &quot; &lt;&lt; TEST_name &lt;&lt; &quot; is defined using TEST.  You probably\\n&quot;\n          &lt;&lt; &quot;want to change the TEST to TEST_F or move it to another test\\n&quot;\n          &lt;&lt; &quot;case.&quot;;\n    } else {\n      // Two fixture classes with the same name appear in two different\n      // namespaces, which is not allowed. Tell the user how to fix this.\n      ADD_FAILURE()\n          &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n          &lt;&lt; &quot;class.  However, in test suite &quot;\n          &lt;&lt; this_test_info-&gt;test_suite_name() &lt;&lt; &quot;,\\n&quot;\n          &lt;&lt; &quot;you defined test &quot; &lt;&lt; first_test_name &lt;&lt; &quot; and test &quot;\n          &lt;&lt; this_test_name &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; &quot;using two different test fixture classes.  This can happen if\\n&quot;\n          &lt;&lt; &quot;the two classes are from different namespaces or translation\\n&quot;\n          &lt;&lt; &quot;units and have the same name.  You should probably rename one\\n&quot;\n          &lt;&lt; &quot;of the classes to put the tests into different test suites.&quot;;\n    }\n    return false;\n  }\n\n  return true;\n}\n\n#if GTEST_HAS_SEH\n\n// Adds an &quot;exception thrown&quot; fatal failure to the current test.  This\n// function returns its result via an output parameter pointer because VC++\n// prohibits creation of objects with destructors on stack in functions\n// using __try (see error C2712).\nstatic std::string* FormatSehExceptionMessage(DWORD exception_code,\n                                              const char* location) {\n  Message message;\n  message &lt;&lt; &quot;SEH exception with code 0x&quot; &lt;&lt; std::setbase(16) &lt;&lt; exception_code\n          &lt;&lt; std::setbase(10) &lt;&lt; &quot; thrown in &quot; &lt;&lt; location &lt;&lt; &quot;.&quot;;\n\n  return new std::string(message.GetString());\n}\n\n#endif  // GTEST_HAS_SEH\n\nnamespace internal {\n\n#if GTEST_HAS_EXCEPTIONS\n\n// Adds an &quot;exception thrown&quot; fatal failure to the current test.\nstatic std::string FormatCxxExceptionMessage(const char* description,\n                                             const char* location) {\n  Message message;\n  if (description != nullptr) {\n    message &lt;&lt; &quot;C++ exception with description \\&quot;&quot; &lt;&lt; description &lt;&lt; &quot;\\&quot;&quot;;\n  } else {\n    message &lt;&lt; &quot;Unknown C++ exception&quot;;\n  }\n  message &lt;&lt; &quot; thrown in &quot; &lt;&lt; location &lt;&lt; &quot;.&quot;;\n\n  return message.GetString();\n}\n\nstatic std::string PrintTestPartResultToString(\n    const TestPartResult&amp; test_part_result);\n\nGoogleTestFailureException::GoogleTestFailureException(\n    const TestPartResult&amp; failure)\n    : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// We put these helper functions in the internal namespace as IBM&#x27;s xlC\n// compiler rejects the code if they were declared static.\n\n// Runs the given method and handles SEH exceptions it throws, when\n// SEH is supported; returns the 0-value for type Result in case of an\n// SEH exception.  (Microsoft compilers cannot handle SEH and C++\n// exceptions in the same function.  Therefore, we provide a separate\n// wrapper function for handling SEH exceptions.)\ntemplate &lt;class T, typename Result&gt;\nResult HandleSehExceptionsInMethodIfSupported(T* object, Result (T::*method)(),\n                                              const char* location) {\n#if GTEST_HAS_SEH\n  __try {\n    return (object-&gt;*method)();\n  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT\n      GetExceptionCode())) {\n    // We create the exception message on the heap because VC++ prohibits\n    // creation of objects with destructors on stack in functions using __try\n    // (see error C2712).\n    std::string* exception_message =\n        FormatSehExceptionMessage(GetExceptionCode(), location);\n    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,\n                                             *exception_message);\n    delete exception_message;\n    return static_cast&lt;Result&gt;(0);\n  }\n#else\n  (void)location;\n  return (object-&gt;*method)();\n#endif  // GTEST_HAS_SEH\n}\n\n// Runs the given method and catches and reports C++ and/or SEH-style\n// exceptions, if they are supported; returns the 0-value for type\n// Result in case of an SEH exception.\ntemplate &lt;class T, typename Result&gt;\nResult HandleExceptionsInMethodIfSupported(T* object, Result (T::*method)(),\n                                           const char* location) {\n  // NOTE: The user code can affect the way in which Google Test handles\n  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before\n  // RUN_ALL_TESTS() starts. It is technically possible to check the flag\n  // after the exception is caught and either report or re-throw the\n  // exception based on the flag&#x27;s value:\n  //\n  // try {\n  //   // Perform the test method.\n  // } catch (...) {\n  //   if (GTEST_FLAG_GET(catch_exceptions))\n  //     // Report the exception as failure.\n  //   else\n  //     throw;  // Re-throws the original exception.\n  // }\n  //\n  // However, the purpose of this flag is to allow the program to drop into\n  // the debugger when the exception is thrown. On most platforms, once the\n  // control enters the catch block, the exception origin information is\n  // lost and the debugger will stop the program at the point of the\n  // re-throw in this function -- instead of at the point of the original\n  // throw statement in the code under test.  For this reason, we perform\n  // the check early, sacrificing the ability to affect Google Test&#x27;s\n  // exception handling in the method where the exception is thrown.\n  if (internal::GetUnitTestImpl()-&gt;catch_exceptions()) {\n#if GTEST_HAS_EXCEPTIONS\n    try {\n      return HandleSehExceptionsInMethodIfSupported(object, method, location);\n    } catch (const AssertionException&amp;) {  // NOLINT\n      // This failure was reported already.\n    } catch (const internal::GoogleTestFailureException&amp;) {  // NOLINT\n      // This exception type can only be thrown by a failed Google\n      // Test assertion with the intention of letting another testing\n      // framework catch it.  Therefore we just re-throw it.\n      throw;\n    } catch (const std::exception&amp; e) {  // NOLINT\n      internal::ReportFailureInUnknownLocation(\n          TestPartResult::kFatalFailure,\n          FormatCxxExceptionMessage(e.what(), location));\n    } catch (...) {  // NOLINT\n      internal::ReportFailureInUnknownLocation(\n          TestPartResult::kFatalFailure,\n          FormatCxxExceptionMessage(nullptr, location));\n    }\n    return static_cast&lt;Result&gt;(0);\n#else\n    return HandleSehExceptionsInMethodIfSupported(object, method, location);\n#endif  // GTEST_HAS_EXCEPTIONS\n  } else {\n    return (object-&gt;*method)();\n  }\n}\n\n}  // namespace internal\n\n// Runs the test and updates the test result.\nvoid Test::Run() {\n  if (!HasSameFixtureClass()) return;\n\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::SetUp, &quot;SetUp()&quot;);\n  // We will run the test only if SetUp() was successful and didn&#x27;t call\n  // GTEST_SKIP().\n  if (!HasFatalFailure() &amp;&amp; !IsSkipped()) {\n    impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n    internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::TestBody,\n                                                  &quot;the test body&quot;);\n  }\n\n  // However, we want to clean up as much as possible.  Hence we will\n  // always call TearDown(), even if SetUp() or the test body has\n  // failed.\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::TearDown,\n                                                &quot;TearDown()&quot;);\n}\n\n// Returns true if and only if the current test has a fatal failure.\nbool Test::HasFatalFailure() {\n  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;HasFatalFailure();\n}\n\n// Returns true if and only if the current test has a non-fatal failure.\nbool Test::HasNonfatalFailure() {\n  return internal::GetUnitTestImpl()\n      -&gt;current_test_result()\n      -&gt;HasNonfatalFailure();\n}\n\n// Returns true if and only if the current test was skipped.\nbool Test::IsSkipped() {\n  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;Skipped();\n}\n\n// class TestInfo\n\n// Constructs a TestInfo object. It assumes ownership of the test factory\n// object.\nTestInfo::TestInfo(const std::string&amp; a_test_suite_name,\n                   const std::string&amp; a_name, const char* a_type_param,\n                   const char* a_value_param,\n                   internal::CodeLocation a_code_location,\n                   internal::TypeId fixture_class_id,\n                   internal::TestFactoryBase* factory)\n    : test_suite_name_(a_test_suite_name),\n      name_(a_name),\n      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),\n      value_param_(a_value_param ? new std::string(a_value_param) : nullptr),\n      location_(a_code_location),\n      fixture_class_id_(fixture_class_id),\n      should_run_(false),\n      is_disabled_(false),\n      matches_filter_(false),\n      is_in_another_shard_(false),\n      factory_(factory),\n      result_() {}\n\n// Destructs a TestInfo object.\nTestInfo::~TestInfo() { delete factory_; }\n\nnamespace internal {\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_suite_name:  name of the test suite\n//   name:             name of the test\n//   type_param:       the name of the test&#x27;s type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param:      text representation of the test&#x27;s value parameter,\n//                     or NULL if this is not a value-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test suite\n//   tear_down_tc:     pointer to the function that tears down the test suite\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nTestInfo* MakeAndRegisterTestInfo(\n    const char* test_suite_name, const char* name, const char* type_param,\n    const char* value_param, CodeLocation code_location,\n    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,\n    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory) {\n  TestInfo* const test_info =\n      new TestInfo(test_suite_name, name, type_param, value_param,\n                   code_location, fixture_class_id, factory);\n  GetUnitTestImpl()-&gt;AddTestInfo(set_up_tc, tear_down_tc, test_info);\n  return test_info;\n}\n\nvoid ReportInvalidTestSuiteType(const char* test_suite_name,\n                                CodeLocation code_location) {\n  Message errors;\n  errors\n      &lt;&lt; &quot;Attempted redefinition of test suite &quot; &lt;&lt; test_suite_name &lt;&lt; &quot;.\\n&quot;\n      &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n      &lt;&lt; &quot;class.  However, in test suite &quot; &lt;&lt; test_suite_name &lt;&lt; &quot;, you tried\\n&quot;\n      &lt;&lt; &quot;to define a test using a fixture class different from the one\\n&quot;\n      &lt;&lt; &quot;used earlier. This can happen if the two fixture classes are\\n&quot;\n      &lt;&lt; &quot;from different namespaces and have the same name. You should\\n&quot;\n      &lt;&lt; &quot;probably rename one of the classes to put the tests into different\\n&quot;\n      &lt;&lt; &quot;test suites.&quot;;\n\n  GTEST_LOG_(ERROR) &lt;&lt; FormatFileLocation(code_location.file.c_str(),\n                                          code_location.line)\n                    &lt;&lt; &quot; &quot; &lt;&lt; errors.GetString();\n}\n}  // namespace internal\n\nnamespace {\n\n// A predicate that checks the test name of a TestInfo against a known\n// value.\n//\n// This is used for implementation of the TestSuite class only.  We put\n// it in the anonymous namespace to prevent polluting the outer\n// namespace.\n//\n// TestNameIs is copyable.\nclass TestNameIs {\n public:\n  // Constructor.\n  //\n  // TestNameIs has NO default constructor.\n  explicit TestNameIs(const char* name) : name_(name) {}\n\n  // Returns true if and only if the test name of test_info matches name_.\n  bool operator()(const TestInfo* test_info) const {\n    return test_info &amp;&amp; test_info-&gt;name() == name_;\n  }\n\n private:\n  std::string name_;\n};\n\n}  // namespace\n\nnamespace internal {\n\n// This method expands all parameterized tests registered with macros TEST_P\n// and INSTANTIATE_TEST_SUITE_P into regular tests and registers those.\n// This will be done just once during the program runtime.\nvoid UnitTestImpl::RegisterParameterizedTests() {\n  if (!parameterized_tests_registered_) {\n    parameterized_test_registry_.RegisterTests();\n    type_parameterized_test_registry_.CheckForInstantiations();\n    parameterized_tests_registered_ = true;\n  }\n}\n\n}  // namespace internal\n\n// Creates the test object, runs it, records its result, and then\n// deletes it.\nvoid TestInfo::Run() {\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n  if (!should_run_) {\n    if (is_disabled_ &amp;&amp; matches_filter_) repeater-&gt;OnTestDisabled(*this);\n    return;\n  }\n\n  // Tells UnitTest where to store test result.\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;set_current_test_info(this);\n\n  // Notifies the unit test event listeners that a test is about to start.\n  repeater-&gt;OnTestStart(*this);\n  result_.set_start_timestamp(internal::GetTimeInMillis());\n  internal::Timer timer;\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n\n  // Creates the test object.\n  Test* const test = internal::HandleExceptionsInMethodIfSupported(\n      factory_, &amp;internal::TestFactoryBase::CreateTest,\n      &quot;the test fixture&#x27;s constructor&quot;);\n\n  // Runs the test if the constructor didn&#x27;t generate a fatal failure or invoke\n  // GTEST_SKIP().\n  // Note that the object will not be null\n  if (!Test::HasFatalFailure() &amp;&amp; !Test::IsSkipped()) {\n    // This doesn&#x27;t throw as all user code that can throw are wrapped into\n    // exception handling code.\n    test-&gt;Run();\n  }\n\n  if (test != nullptr) {\n    // Deletes the test object.\n    impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n    internal::HandleExceptionsInMethodIfSupported(\n        test, &amp;Test::DeleteSelf_, &quot;the test fixture&#x27;s destructor&quot;);\n  }\n\n  result_.set_elapsed_time(timer.Elapsed());\n\n  // Notifies the unit test event listener that a test has just finished.\n  repeater-&gt;OnTestEnd(*this);\n\n  // Tells UnitTest to stop associating assertion results to this\n  // test.\n  impl-&gt;set_current_test_info(nullptr);\n}\n\n// Skip and records a skipped test result for this object.\nvoid TestInfo::Skip() {\n  if (!should_run_) return;\n\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;set_current_test_info(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Notifies the unit test event listeners that a test is about to start.\n  repeater-&gt;OnTestStart(*this);\n\n  const TestPartResult test_part_result =\n      TestPartResult(TestPartResult::kSkip, this-&gt;file(), this-&gt;line(), &quot;&quot;);\n  impl-&gt;GetTestPartResultReporterForCurrentThread()-&gt;ReportTestPartResult(\n      test_part_result);\n\n  // Notifies the unit test event listener that a test has just finished.\n  repeater-&gt;OnTestEnd(*this);\n  impl-&gt;set_current_test_info(nullptr);\n}\n\n// class TestSuite\n\n// Gets the number of successful tests in this test suite.\nint TestSuite::successful_test_count() const {\n  return CountIf(test_info_list_, TestPassed);\n}\n\n// Gets the number of successful tests in this test suite.\nint TestSuite::skipped_test_count() const {\n  return CountIf(test_info_list_, TestSkipped);\n}\n\n// Gets the number of failed tests in this test suite.\nint TestSuite::failed_test_count() const {\n  return CountIf(test_info_list_, TestFailed);\n}\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint TestSuite::reportable_disabled_test_count() const {\n  return CountIf(test_info_list_, TestReportableDisabled);\n}\n\n// Gets the number of disabled tests in this test suite.\nint TestSuite::disabled_test_count() const {\n  return CountIf(test_info_list_, TestDisabled);\n}\n\n// Gets the number of tests to be printed in the XML report.\nint TestSuite::reportable_test_count() const {\n  return CountIf(test_info_list_, TestReportable);\n}\n\n// Get the number of tests in this test suite that should run.\nint TestSuite::test_to_run_count() const {\n  return CountIf(test_info_list_, ShouldRunTest);\n}\n\n// Gets the number of all tests.\nint TestSuite::total_test_count() const {\n  return static_cast&lt;int&gt;(test_info_list_.size());\n}\n\n// Creates a TestSuite with the given name.\n//\n// Arguments:\n//\n//   a_name:       name of the test suite\n//   a_type_param: the name of the test suite&#x27;s type parameter, or NULL if\n//                 this is not a typed or a type-parameterized test suite.\n//   set_up_tc:    pointer to the function that sets up the test suite\n//   tear_down_tc: pointer to the function that tears down the test suite\nTestSuite::TestSuite(const char* a_name, const char* a_type_param,\n                     internal::SetUpTestSuiteFunc set_up_tc,\n                     internal::TearDownTestSuiteFunc tear_down_tc)\n    : name_(a_name),\n      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),\n      set_up_tc_(set_up_tc),\n      tear_down_tc_(tear_down_tc),\n      should_run_(false),\n      start_timestamp_(0),\n      elapsed_time_(0) {}\n\n// Destructor of TestSuite.\nTestSuite::~TestSuite() {\n  // Deletes every Test in the collection.\n  ForEach(test_info_list_, internal::Delete&lt;TestInfo&gt;);\n}\n\n// Returns the i-th test among all the tests. i can range from 0 to\n// total_test_count() - 1. If i is not in that range, returns NULL.\nconst TestInfo* TestSuite::GetTestInfo(int i) const {\n  const int index = GetElementOr(test_indices_, i, -1);\n  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];\n}\n\n// Returns the i-th test among all the tests. i can range from 0 to\n// total_test_count() - 1. If i is not in that range, returns NULL.\nTestInfo* TestSuite::GetMutableTestInfo(int i) {\n  const int index = GetElementOr(test_indices_, i, -1);\n  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];\n}\n\n// Adds a test to this test suite.  Will delete the test upon\n// destruction of the TestSuite object.\nvoid TestSuite::AddTestInfo(TestInfo* test_info) {\n  test_info_list_.push_back(test_info);\n  test_indices_.push_back(static_cast&lt;int&gt;(test_indices_.size()));\n}\n\n// Runs every test in this TestSuite.\nvoid TestSuite::Run() {\n  if (!should_run_) return;\n\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;set_current_test_suite(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteStart(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseStart(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(\n      this, &amp;TestSuite::RunSetUpTestSuite, &quot;SetUpTestSuite()&quot;);\n\n  const bool skip_all = ad_hoc_test_result().Failed();\n\n  start_timestamp_ = internal::GetTimeInMillis();\n  internal::Timer timer;\n  for (int i = 0; i &lt; total_test_count(); i++) {\n    if (skip_all) {\n      GetMutableTestInfo(i)-&gt;Skip();\n    } else {\n      GetMutableTestInfo(i)-&gt;Run();\n    }\n    if (GTEST_FLAG_GET(fail_fast) &amp;&amp;\n        GetMutableTestInfo(i)-&gt;result()-&gt;Failed()) {\n      for (int j = i + 1; j &lt; total_test_count(); j++) {\n        GetMutableTestInfo(j)-&gt;Skip();\n      }\n      break;\n    }\n  }\n  elapsed_time_ = timer.Elapsed();\n\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(\n      this, &amp;TestSuite::RunTearDownTestSuite, &quot;TearDownTestSuite()&quot;);\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteEnd(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseEnd(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  impl-&gt;set_current_test_suite(nullptr);\n}\n\n// Skips all tests under this TestSuite.\nvoid TestSuite::Skip() {\n  if (!should_run_) return;\n\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;set_current_test_suite(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteStart(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseStart(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  for (int i = 0; i &lt; total_test_count(); i++) {\n    GetMutableTestInfo(i)-&gt;Skip();\n  }\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteEnd(*this);\n  // Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseEnd(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  impl-&gt;set_current_test_suite(nullptr);\n}\n\n// Clears the results of all tests in this test suite.\nvoid TestSuite::ClearResult() {\n  ad_hoc_test_result_.Clear();\n  ForEach(test_info_list_, TestInfo::ClearTestResult);\n}\n\n// Shuffles the tests in this test suite.\nvoid TestSuite::ShuffleTests(internal::Random* random) {\n  Shuffle(random, &amp;test_indices_);\n}\n\n// Restores the test order to before the first shuffle.\nvoid TestSuite::UnshuffleTests() {\n  for (size_t i = 0; i &lt; test_indices_.size(); i++) {\n    test_indices_[i] = static_cast&lt;int&gt;(i);\n  }\n}\n\n// Formats a countable noun.  Depending on its quantity, either the\n// singular form or the plural form is used. e.g.\n//\n// FormatCountableNoun(1, &quot;formula&quot;, &quot;formuli&quot;) returns &quot;1 formula&quot;.\n// FormatCountableNoun(5, &quot;book&quot;, &quot;books&quot;) returns &quot;5 books&quot;.\nstatic std::string FormatCountableNoun(int count, const char* singular_form,\n                                       const char* plural_form) {\n  return internal::StreamableToString(count) + &quot; &quot; +\n         (count == 1 ? singular_form : plural_form);\n}\n\n// Formats the count of tests.\nstatic std::string FormatTestCount(int test_count) {\n  return FormatCountableNoun(test_count, &quot;test&quot;, &quot;tests&quot;);\n}\n\n// Formats the count of test suites.\nstatic std::string FormatTestSuiteCount(int test_suite_count) {\n  return FormatCountableNoun(test_suite_count, &quot;test suite&quot;, &quot;test suites&quot;);\n}\n\n// Converts a TestPartResult::Type enum to human-friendly string\n// representation.  Both kNonFatalFailure and kFatalFailure are translated\n// to &quot;Failure&quot;, as the user usually doesn&#x27;t care about the difference\n// between the two when viewing the test result.\nstatic const char* TestPartResultTypeToString(TestPartResult::Type type) {\n  switch (type) {\n    case TestPartResult::kSkip:\n      return &quot;Skipped\\n&quot;;\n    case TestPartResult::kSuccess:\n      return &quot;Success&quot;;\n\n    case TestPartResult::kNonFatalFailure:\n    case TestPartResult::kFatalFailure:\n#ifdef _MSC_VER\n      return &quot;error: &quot;;\n#else\n      return &quot;Failure\\n&quot;;\n#endif\n    default:\n      return &quot;Unknown result type&quot;;\n  }\n}\n\nnamespace internal {\nnamespace {\nenum class GTestColor { kDefault, kRed, kGreen, kYellow };\n}  // namespace\n\n// Prints a TestPartResult to an std::string.\nstatic std::string PrintTestPartResultToString(\n    const TestPartResult&amp; test_part_result) {\n  return (Message() &lt;&lt; internal::FormatFileLocation(\n                           test_part_result.file_name(),\n                           test_part_result.line_number())\n                    &lt;&lt; &quot; &quot;\n                    &lt;&lt; TestPartResultTypeToString(test_part_result.type())\n                    &lt;&lt; test_part_result.message())\n      .GetString();\n}\n\n// Prints a TestPartResult.\nstatic void PrintTestPartResult(const TestPartResult&amp; test_part_result) {\n  const std::string&amp; result = PrintTestPartResultToString(test_part_result);\n  printf(&quot;%s\\n&quot;, result.c_str());\n  fflush(stdout);\n  // If the test program runs in Visual Studio or a debugger, the\n  // following statements add the test part result message to the Output\n  // window such that the user can double-click on it to jump to the\n  // corresponding source code location; otherwise they do nothing.\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n  // We don&#x27;t call OutputDebugString*() on Windows Mobile, as printing\n  // to stdout is done by OutputDebugString() there already - we don&#x27;t\n  // want the same message printed twice.\n  ::OutputDebugStringA(result.c_str());\n  ::OutputDebugStringA(&quot;\\n&quot;);\n#endif\n}\n\n// class PrettyUnitTestResultPrinter\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; \\\n    !GTEST_OS_WINDOWS_RT &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n\n// Returns the character attribute for the given color.\nstatic WORD GetColorAttribute(GTestColor color) {\n  switch (color) {\n    case GTestColor::kRed:\n      return FOREGROUND_RED;\n    case GTestColor::kGreen:\n      return FOREGROUND_GREEN;\n    case GTestColor::kYellow:\n      return FOREGROUND_RED | FOREGROUND_GREEN;\n    default:\n      return 0;\n  }\n}\n\nstatic int GetBitOffset(WORD color_mask) {\n  if (color_mask == 0) return 0;\n\n  int bitOffset = 0;\n  while ((color_mask &amp; 1) == 0) {\n    color_mask &gt;&gt;= 1;\n    ++bitOffset;\n  }\n  return bitOffset;\n}\n\nstatic WORD GetNewColor(GTestColor color, WORD old_color_attrs) {\n  // Let&#x27;s reuse the BG\n  static const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN |\n                                      BACKGROUND_RED | BACKGROUND_INTENSITY;\n  static const WORD foreground_mask = FOREGROUND_BLUE | FOREGROUND_GREEN |\n                                      FOREGROUND_RED | FOREGROUND_INTENSITY;\n  const WORD existing_bg = old_color_attrs &amp; background_mask;\n\n  WORD new_color =\n      GetColorAttribute(color) | existing_bg | FOREGROUND_INTENSITY;\n  static const int bg_bitOffset = GetBitOffset(background_mask);\n  static const int fg_bitOffset = GetBitOffset(foreground_mask);\n\n  if (((new_color &amp; background_mask) &gt;&gt; bg_bitOffset) ==\n      ((new_color &amp; foreground_mask) &gt;&gt; fg_bitOffset)) {\n    new_color ^= FOREGROUND_INTENSITY;  // invert intensity\n  }\n  return new_color;\n}\n\n#else\n\n// Returns the ANSI color code for the given color. GTestColor::kDefault is\n// an invalid input.\nstatic const char* GetAnsiColorCode(GTestColor color) {\n  switch (color) {\n    case GTestColor::kRed:\n      return &quot;1&quot;;\n    case GTestColor::kGreen:\n      return &quot;2&quot;;\n    case GTestColor::kYellow:\n      return &quot;3&quot;;\n    default:\n      return nullptr;\n  }\n}\n\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n\n// Returns true if and only if Google Test should use colors in the output.\nbool ShouldUseColor(bool stdout_is_tty) {\n  std::string c = GTEST_FLAG_GET(color);\n  const char* const gtest_color = c.c_str();\n\n  if (String::CaseInsensitiveCStringEquals(gtest_color, &quot;auto&quot;)) {\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n    // On Windows the TERM variable is usually not set, but the\n    // console there does support colors.\n    return stdout_is_tty;\n#else\n    // On non-Windows platforms, we rely on the TERM variable.\n    const char* const term = posix::GetEnv(&quot;TERM&quot;);\n    const bool term_supports_color =\n        String::CStringEquals(term, &quot;xterm&quot;) ||\n        String::CStringEquals(term, &quot;xterm-color&quot;) ||\n        String::CStringEquals(term, &quot;xterm-256color&quot;) ||\n        String::CStringEquals(term, &quot;screen&quot;) ||\n        String::CStringEquals(term, &quot;screen-256color&quot;) ||\n        String::CStringEquals(term, &quot;tmux&quot;) ||\n        String::CStringEquals(term, &quot;tmux-256color&quot;) ||\n        String::CStringEquals(term, &quot;rxvt-unicode&quot;) ||\n        String::CStringEquals(term, &quot;rxvt-unicode-256color&quot;) ||\n        String::CStringEquals(term, &quot;linux&quot;) ||\n        String::CStringEquals(term, &quot;cygwin&quot;);\n    return stdout_is_tty &amp;&amp; term_supports_color;\n#endif  // GTEST_OS_WINDOWS\n  }\n\n  return String::CaseInsensitiveCStringEquals(gtest_color, &quot;yes&quot;) ||\n         String::CaseInsensitiveCStringEquals(gtest_color, &quot;true&quot;) ||\n         String::CaseInsensitiveCStringEquals(gtest_color, &quot;t&quot;) ||\n         String::CStringEquals(gtest_color, &quot;1&quot;);\n  // We take &quot;yes&quot;, &quot;true&quot;, &quot;t&quot;, and &quot;1&quot; as meaning &quot;yes&quot;.  If the\n  // value is neither one of these nor &quot;auto&quot;, we treat it as &quot;no&quot; to\n  // be conservative.\n}\n\n// Helpers for printing colored strings to stdout. Note that on Windows, we\n// cannot simply emit special characters and have the terminal change colors.\n// This routine must actually emit the characters rather than return a string\n// that would be colored when printed, as can be done on Linux.\n\nGTEST_ATTRIBUTE_PRINTF_(2, 3)\nstatic void ColoredPrintf(GTestColor color, const char* fmt, ...) {\n  va_list args;\n  va_start(args, fmt);\n\n  static const bool in_color_mode =\n      ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);\n  const bool use_color = in_color_mode &amp;&amp; (color != GTestColor::kDefault);\n\n  if (!use_color) {\n    vprintf(fmt, args);\n    va_end(args);\n    return;\n  }\n\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; \\\n    !GTEST_OS_WINDOWS_RT &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n  const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);\n\n  // Gets the current text color.\n  CONSOLE_SCREEN_BUFFER_INFO buffer_info;\n  GetConsoleScreenBufferInfo(stdout_handle, &amp;buffer_info);\n  const WORD old_color_attrs = buffer_info.wAttributes;\n  const WORD new_color = GetNewColor(color, old_color_attrs);\n\n  // We need to flush the stream buffers into the console before each\n  // SetConsoleTextAttribute call lest it affect the text that is already\n  // printed but has not yet reached the console.\n  fflush(stdout);\n  SetConsoleTextAttribute(stdout_handle, new_color);\n\n  vprintf(fmt, args);\n\n  fflush(stdout);\n  // Restores the text color.\n  SetConsoleTextAttribute(stdout_handle, old_color_attrs);\n#else\n  printf(&quot;\\033[0;3%sm&quot;, GetAnsiColorCode(color));\n  vprintf(fmt, args);\n  printf(&quot;\\033[m&quot;);  // Resets the terminal to default.\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n  va_end(args);\n}\n\n// Text printed in Google Test&#x27;s text output and --gtest_list_tests\n// output to label the type parameter and value parameter for a test.\nstatic const char kTypeParamLabel[] = &quot;TypeParam&quot;;\nstatic const char kValueParamLabel[] = &quot;GetParam()&quot;;\n\nstatic void PrintFullTestCommentIfPresent(const TestInfo&amp; test_info) {\n  const char* const type_param = test_info.type_param();\n  const char* const value_param = test_info.value_param();\n\n  if (type_param != nullptr || value_param != nullptr) {\n    printf(&quot;, where &quot;);\n    if (type_param != nullptr) {\n      printf(&quot;%s = %s&quot;, kTypeParamLabel, type_param);\n      if (value_param != nullptr) printf(&quot; and &quot;);\n    }\n    if (value_param != nullptr) {\n      printf(&quot;%s = %s&quot;, kValueParamLabel, value_param);\n    }\n  }\n}\n\n// This class implements the TestEventListener interface.\n//\n// Class PrettyUnitTestResultPrinter is copyable.\nclass PrettyUnitTestResultPrinter : public TestEventListener {\n public:\n  PrettyUnitTestResultPrinter() {}\n  static void PrintTestName(const char* test_suite, const char* test) {\n    printf(&quot;%s.%s&quot;, test_suite, test);\n  }\n\n  // The following methods override what&#x27;s in the TestEventListener class.\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; test_case) override;\n#else\n  void OnTestSuiteStart(const TestSuite&amp; test_suite) override;\n#endif  // OnTestCaseStart\n\n  void OnTestStart(const TestInfo&amp; test_info) override;\n  void OnTestDisabled(const TestInfo&amp; test_info) override;\n\n  void OnTestPartResult(const TestPartResult&amp; result) override;\n  void OnTestEnd(const TestInfo&amp; test_info) override;\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; test_case) override;\n#else\n  void OnTestSuiteEnd(const TestSuite&amp; test_suite) override;\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n\n private:\n  static void PrintFailedTests(const UnitTest&amp; unit_test);\n  static void PrintFailedTestSuites(const UnitTest&amp; unit_test);\n  static void PrintSkippedTests(const UnitTest&amp; unit_test);\n};\n\n// Fired before each iteration of tests starts.\nvoid PrettyUnitTestResultPrinter::OnTestIterationStart(\n    const UnitTest&amp; unit_test, int iteration) {\n  if (GTEST_FLAG_GET(repeat) != 1)\n    printf(&quot;\\nRepeating all tests (iteration %d) . . .\\n\\n&quot;, iteration + 1);\n\n  std::string f = GTEST_FLAG_GET(filter);\n  const char* const filter = f.c_str();\n\n  // Prints the filter if it&#x27;s not *.  This reminds the user that some\n  // tests may be skipped.\n  if (!String::CStringEquals(filter, kUniversalFilter)) {\n    ColoredPrintf(GTestColor::kYellow, &quot;Note: %s filter = %s\\n&quot;, GTEST_NAME_,\n                  filter);\n  }\n\n  if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {\n    const int32_t shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);\n    ColoredPrintf(GTestColor::kYellow, &quot;Note: This is test shard %d of %s.\\n&quot;,\n                  static_cast&lt;int&gt;(shard_index) + 1,\n                  internal::posix::GetEnv(kTestTotalShards));\n  }\n\n  if (GTEST_FLAG_GET(shuffle)) {\n    ColoredPrintf(GTestColor::kYellow,\n                  &quot;Note: Randomizing tests&#x27; orders with a seed of %d .\\n&quot;,\n                  unit_test.random_seed());\n  }\n\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;Running %s from %s.\\n&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  fflush(stdout);\n}\n\nvoid PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(\n    const UnitTest&amp; /*unit_test*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;Global test environment set-up.\\n&quot;);\n  fflush(stdout);\n}\n\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nvoid PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase&amp; test_case) {\n  const std::string counts =\n      FormatCountableNoun(test_case.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s&quot;, counts.c_str(), test_case.name());\n  if (test_case.type_param() == nullptr) {\n    printf(&quot;\\n&quot;);\n  } else {\n    printf(&quot;, where %s = %s\\n&quot;, kTypeParamLabel, test_case.type_param());\n  }\n  fflush(stdout);\n}\n#else\nvoid PrettyUnitTestResultPrinter::OnTestSuiteStart(\n    const TestSuite&amp; test_suite) {\n  const std::string counts =\n      FormatCountableNoun(test_suite.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s&quot;, counts.c_str(), test_suite.name());\n  if (test_suite.type_param() == nullptr) {\n    printf(&quot;\\n&quot;);\n  } else {\n    printf(&quot;, where %s = %s\\n&quot;, kTypeParamLabel, test_suite.type_param());\n  }\n  fflush(stdout);\n}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nvoid PrettyUnitTestResultPrinter::OnTestStart(const TestInfo&amp; test_info) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[ RUN      ] &quot;);\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  printf(&quot;\\n&quot;);\n  fflush(stdout);\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestDisabled(const TestInfo&amp; test_info) {\n  ColoredPrintf(GTestColor::kYellow, &quot;[ DISABLED ] &quot;);\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  printf(&quot;\\n&quot;);\n  fflush(stdout);\n}\n\n// Called after an assertion failure.\nvoid PrettyUnitTestResultPrinter::OnTestPartResult(\n    const TestPartResult&amp; result) {\n  switch (result.type()) {\n    // If the test part succeeded, we don&#x27;t need to do anything.\n    case TestPartResult::kSuccess:\n      return;\n    default:\n      // Print failure message from the assertion\n      // (e.g. expected this and got that).\n      PrintTestPartResult(result);\n      fflush(stdout);\n  }\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {\n  if (test_info.result()-&gt;Passed()) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[       OK ] &quot;);\n  } else if (test_info.result()-&gt;Skipped()) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n  } else {\n    ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n  }\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  if (test_info.result()-&gt;Failed()) PrintFullTestCommentIfPresent(test_info);\n\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms)\\n&quot;,\n           internal::StreamableToString(test_info.result()-&gt;elapsed_time())\n               .c_str());\n  } else {\n    printf(&quot;\\n&quot;);\n  }\n  fflush(stdout);\n}\n\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nvoid PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase&amp; test_case) {\n  if (!GTEST_FLAG_GET(print_time)) return;\n\n  const std::string counts =\n      FormatCountableNoun(test_case.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s (%s ms total)\\n\\n&quot;, counts.c_str(), test_case.name(),\n         internal::StreamableToString(test_case.elapsed_time()).c_str());\n  fflush(stdout);\n}\n#else\nvoid PrettyUnitTestResultPrinter::OnTestSuiteEnd(const TestSuite&amp; test_suite) {\n  if (!GTEST_FLAG_GET(print_time)) return;\n\n  const std::string counts =\n      FormatCountableNoun(test_suite.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s (%s ms total)\\n\\n&quot;, counts.c_str(), test_suite.name(),\n         internal::StreamableToString(test_suite.elapsed_time()).c_str());\n  fflush(stdout);\n}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nvoid PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(\n    const UnitTest&amp; /*unit_test*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;Global test environment tear-down\\n&quot;);\n  fflush(stdout);\n}\n\n// Internal helper for printing the list of failed tests.\nvoid PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest&amp; unit_test) {\n  const int failed_test_count = unit_test.failed_test_count();\n  ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n  printf(&quot;%s, listed below:\\n&quot;, FormatTestCount(failed_test_count).c_str());\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run() || (test_suite.failed_test_count() == 0)) {\n      continue;\n    }\n    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {\n      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);\n      if (!test_info.should_run() || !test_info.result()-&gt;Failed()) {\n        continue;\n      }\n      ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n      printf(&quot;%s.%s&quot;, test_suite.name(), test_info.name());\n      PrintFullTestCommentIfPresent(test_info);\n      printf(&quot;\\n&quot;);\n    }\n  }\n  printf(&quot;\\n%2d FAILED %s\\n&quot;, failed_test_count,\n         failed_test_count == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n}\n\n// Internal helper for printing the list of test suite failures not covered by\n// PrintFailedTests.\nvoid PrettyUnitTestResultPrinter::PrintFailedTestSuites(\n    const UnitTest&amp; unit_test) {\n  int suite_failure_count = 0;\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run()) {\n      continue;\n    }\n    if (test_suite.ad_hoc_test_result().Failed()) {\n      ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n      printf(&quot;%s: SetUpTestSuite or TearDownTestSuite\\n&quot;, test_suite.name());\n      ++suite_failure_count;\n    }\n  }\n  if (suite_failure_count &gt; 0) {\n    printf(&quot;\\n%2d FAILED TEST %s\\n&quot;, suite_failure_count,\n           suite_failure_count == 1 ? &quot;SUITE&quot; : &quot;SUITES&quot;);\n  }\n}\n\n// Internal helper for printing the list of skipped tests.\nvoid PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest&amp; unit_test) {\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count == 0) {\n    return;\n  }\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run() || (test_suite.skipped_test_count() == 0)) {\n      continue;\n    }\n    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {\n      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);\n      if (!test_info.should_run() || !test_info.result()-&gt;Skipped()) {\n        continue;\n      }\n      ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n      printf(&quot;%s.%s&quot;, test_suite.name(), test_info.name());\n      printf(&quot;\\n&quot;);\n    }\n  }\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                     int /*iteration*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;%s from %s ran.&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms total)&quot;,\n           internal::StreamableToString(unit_test.elapsed_time()).c_str());\n  }\n  printf(&quot;\\n&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[  PASSED  ] &quot;);\n  printf(&quot;%s.\\n&quot;, FormatTestCount(unit_test.successful_test_count()).c_str());\n\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count &gt; 0) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n    printf(&quot;%s, listed below:\\n&quot;, FormatTestCount(skipped_test_count).c_str());\n    PrintSkippedTests(unit_test);\n  }\n\n  if (!unit_test.Passed()) {\n    PrintFailedTests(unit_test);\n    PrintFailedTestSuites(unit_test);\n  }\n\n  int num_disabled = unit_test.reportable_disabled_test_count();\n  if (num_disabled &amp;&amp; !GTEST_FLAG_GET(also_run_disabled_tests)) {\n    if (unit_test.Passed()) {\n      printf(&quot;\\n&quot;);  // Add a spacer if no FAILURE banner is displayed.\n    }\n    ColoredPrintf(GTestColor::kYellow, &quot;  YOU HAVE %d DISABLED %s\\n\\n&quot;,\n                  num_disabled, num_disabled == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n  }\n  // Ensure that Google Test output is printed before, e.g., heapchecker output.\n  fflush(stdout);\n}\n\n// End PrettyUnitTestResultPrinter\n\n// This class implements the TestEventListener interface.\n//\n// Class BriefUnitTestResultPrinter is copyable.\nclass BriefUnitTestResultPrinter : public TestEventListener {\n public:\n  BriefUnitTestResultPrinter() {}\n  static void PrintTestName(const char* test_suite, const char* test) {\n    printf(&quot;%s.%s&quot;, test_suite, test);\n  }\n\n  // The following methods override what&#x27;s in the TestEventListener class.\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; /*unit_test*/,\n                            int /*iteration*/) override {}\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; /*test_case*/) override {}\n#else\n  void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override {}\n#endif  // OnTestCaseStart\n\n  void OnTestStart(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestDisabled(const TestInfo&amp; /*test_info*/) override {}\n\n  void OnTestPartResult(const TestPartResult&amp; result) override;\n  void OnTestEnd(const TestInfo&amp; test_info) override;\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; /*test_case*/) override {}\n#else\n  void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override {}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n};\n\n// Called after an assertion failure.\nvoid BriefUnitTestResultPrinter::OnTestPartResult(\n    const TestPartResult&amp; result) {\n  switch (result.type()) {\n    // If the test part succeeded, we don&#x27;t need to do anything.\n    case TestPartResult::kSuccess:\n      return;\n    default:\n      // Print failure message from the assertion\n      // (e.g. expected this and got that).\n      PrintTestPartResult(result);\n      fflush(stdout);\n  }\n}\n\nvoid BriefUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {\n  if (test_info.result()-&gt;Failed()) {\n    ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n    PrintTestName(test_info.test_suite_name(), test_info.name());\n    PrintFullTestCommentIfPresent(test_info);\n\n    if (GTEST_FLAG_GET(print_time)) {\n      printf(&quot; (%s ms)\\n&quot;,\n             internal::StreamableToString(test_info.result()-&gt;elapsed_time())\n                 .c_str());\n    } else {\n      printf(&quot;\\n&quot;);\n    }\n    fflush(stdout);\n  }\n}\n\nvoid BriefUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                    int /*iteration*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;%s from %s ran.&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms total)&quot;,\n           internal::StreamableToString(unit_test.elapsed_time()).c_str());\n  }\n  printf(&quot;\\n&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[  PASSED  ] &quot;);\n  printf(&quot;%s.\\n&quot;, FormatTestCount(unit_test.successful_test_count()).c_str());\n\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count &gt; 0) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n    printf(&quot;%s.\\n&quot;, FormatTestCount(skipped_test_count).c_str());\n  }\n\n  int num_disabled = unit_test.reportable_disabled_test_count();\n  if (num_disabled &amp;&amp; !GTEST_FLAG_GET(also_run_disabled_tests)) {\n    if (unit_test.Passed()) {\n      printf(&quot;\\n&quot;);  // Add a spacer if no FAILURE banner is displayed.\n    }\n    ColoredPrintf(GTestColor::kYellow, &quot;  YOU HAVE %d DISABLED %s\\n\\n&quot;,\n                  num_disabled, num_disabled == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n  }\n  // Ensure that Google Test output is printed before, e.g., heapchecker output.\n  fflush(stdout);\n}\n\n// End BriefUnitTestResultPrinter\n\n// class TestEventRepeater\n//\n// This class forwards events to other event listeners.\nclass TestEventRepeater : public TestEventListener {\n public:\n  TestEventRepeater() : forwarding_enabled_(true) {}\n  ~TestEventRepeater() override;\n  void Append(TestEventListener* listener);\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Controls whether events will be forwarded to listeners_. Set to false\n  // in death test child processes.\n  bool forwarding_enabled() const { return forwarding_enabled_; }\n  void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }\n\n  void OnTestProgramStart(const UnitTest&amp; unit_test) override;\n  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; unit_test) override;\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestSuite&amp; parameter) override;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestSuiteStart(const TestSuite&amp; parameter) override;\n  void OnTestStart(const TestInfo&amp; test_info) override;\n  void OnTestDisabled(const TestInfo&amp; test_info) override;\n  void OnTestPartResult(const TestPartResult&amp; result) override;\n  void OnTestEnd(const TestInfo&amp; test_info) override;\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; parameter) override;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestSuiteEnd(const TestSuite&amp; parameter) override;\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; unit_test) override;\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; unit_test) override;\n\n private:\n  // Controls whether events will be forwarded to listeners_. Set to false\n  // in death test child processes.\n  bool forwarding_enabled_;\n  // The list of listeners that receive events.\n  std::vector&lt;TestEventListener*&gt; listeners_;\n\n  TestEventRepeater(const TestEventRepeater&amp;) = delete;\n  TestEventRepeater&amp; operator=(const TestEventRepeater&amp;) = delete;\n};\n\nTestEventRepeater::~TestEventRepeater() {\n  ForEach(listeners_, Delete&lt;TestEventListener&gt;);\n}\n\nvoid TestEventRepeater::Append(TestEventListener* listener) {\n  listeners_.push_back(listener);\n}\n\nTestEventListener* TestEventRepeater::Release(TestEventListener* listener) {\n  for (size_t i = 0; i &lt; listeners_.size(); ++i) {\n    if (listeners_[i] == listener) {\n      listeners_.erase(listeners_.begin() + static_cast&lt;int&gt;(i));\n      return listener;\n    }\n  }\n\n  return nullptr;\n}\n\n// Since most methods are very similar, use macros to reduce boilerplate.\n// This defines a member that forwards the call to all listeners.\n#define GTEST_REPEATER_METHOD_(Name, Type)              \\\n  void TestEventRepeater::Name(const Type&amp; parameter) { \\\n    if (forwarding_enabled_) {                          \\\n      for (size_t i = 0; i &lt; listeners_.size(); i++) {  \\\n        listeners_[i]-&gt;Name(parameter);                 \\\n      }                                                 \\\n    }                                                   \\\n  }\n// This defines a member that forwards the call to all listeners in reverse\n// order.\n#define GTEST_REVERSE_REPEATER_METHOD_(Name, Type)      \\\n  void TestEventRepeater::Name(const Type&amp; parameter) { \\\n    if (forwarding_enabled_) {                          \\\n      for (size_t i = listeners_.size(); i != 0; i--) { \\\n        listeners_[i - 1]-&gt;Name(parameter);             \\\n      }                                                 \\\n    }                                                   \\\n  }\n\nGTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)\nGTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REPEATER_METHOD_(OnTestCaseStart, TestSuite)\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REPEATER_METHOD_(OnTestSuiteStart, TestSuite)\nGTEST_REPEATER_METHOD_(OnTestStart, TestInfo)\nGTEST_REPEATER_METHOD_(OnTestDisabled, TestInfo)\nGTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)\nGTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestSuite)\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REVERSE_REPEATER_METHOD_(OnTestSuiteEnd, TestSuite)\nGTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)\n\n#undef GTEST_REPEATER_METHOD_\n#undef GTEST_REVERSE_REPEATER_METHOD_\n\nvoid TestEventRepeater::OnTestIterationStart(const UnitTest&amp; unit_test,\n                                             int iteration) {\n  if (forwarding_enabled_) {\n    for (size_t i = 0; i &lt; listeners_.size(); i++) {\n      listeners_[i]-&gt;OnTestIterationStart(unit_test, iteration);\n    }\n  }\n}\n\nvoid TestEventRepeater::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                           int iteration) {\n  if (forwarding_enabled_) {\n    for (size_t i = listeners_.size(); i &gt; 0; i--) {\n      listeners_[i - 1]-&gt;OnTestIterationEnd(unit_test, iteration);\n    }\n  }\n}\n\n// End TestEventRepeater\n\n// This class generates an XML output file.\nclass XmlUnitTestResultPrinter : public EmptyTestEventListener {\n public:\n  explicit XmlUnitTestResultPrinter(const char* output_file);\n\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void ListTestsMatchingFilter(const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n  // Prints an XML summary of all unit tests.\n  static void PrintXmlTestsList(std::ostream* stream,\n                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n private:\n  // Is c a whitespace character that is normalized to a space character\n  // when it appears in an XML attribute value?\n  static bool IsNormalizableWhitespace(unsigned char c) {\n    return c == &#x27;\\t&#x27; || c == &#x27;\\n&#x27; || c == &#x27;\\r&#x27;;\n  }\n\n  // May c appear in a well-formed XML document?\n  // https://www.w3.org/TR/REC-xml/#charsets\n  static bool IsValidXmlCharacter(unsigned char c) {\n    return IsNormalizableWhitespace(c) || c &gt;= 0x20;\n  }\n\n  // Returns an XML-escaped copy of the input string str.  If\n  // is_attribute is true, the text is meant to appear as an attribute\n  // value, and normalizable whitespace is preserved by replacing it\n  // with character references.\n  static std::string EscapeXml(const std::string&amp; str, bool is_attribute);\n\n  // Returns the given string with all characters invalid in XML removed.\n  static std::string RemoveInvalidXmlCharacters(const std::string&amp; str);\n\n  // Convenience wrapper around EscapeXml when str is an attribute value.\n  static std::string EscapeXmlAttribute(const std::string&amp; str) {\n    return EscapeXml(str, true);\n  }\n\n  // Convenience wrapper around EscapeXml when str is not an attribute value.\n  static std::string EscapeXmlText(const char* str) {\n    return EscapeXml(str, false);\n  }\n\n  // Verifies that the given attribute belongs to the given element and\n  // streams the attribute as XML.\n  static void OutputXmlAttribute(std::ostream* stream,\n                                 const std::string&amp; element_name,\n                                 const std::string&amp; name,\n                                 const std::string&amp; value);\n\n  // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.\n  static void OutputXmlCDataSection(::std::ostream* stream, const char* data);\n\n  // Streams a test suite XML stanza containing the given test result.\n  //\n  // Requires: result.Failed()\n  static void OutputXmlTestSuiteForTestResult(::std::ostream* stream,\n                                              const TestResult&amp; result);\n\n  // Streams an XML representation of a TestResult object.\n  static void OutputXmlTestResult(::std::ostream* stream,\n                                  const TestResult&amp; result);\n\n  // Streams an XML representation of a TestInfo object.\n  static void OutputXmlTestInfo(::std::ostream* stream,\n                                const char* test_suite_name,\n                                const TestInfo&amp; test_info);\n\n  // Prints an XML representation of a TestSuite object\n  static void PrintXmlTestSuite(::std::ostream* stream,\n                                const TestSuite&amp; test_suite);\n\n  // Prints an XML summary of unit_test to output stream out.\n  static void PrintXmlUnitTest(::std::ostream* stream,\n                               const UnitTest&amp; unit_test);\n\n  // Produces a string representing the test properties in a result as space\n  // delimited XML attributes based on the property key=&quot;value&quot; pairs.\n  // When the std::string is not empty, it includes a space at the beginning,\n  // to delimit this attribute from prior attributes.\n  static std::string TestPropertiesAsXmlAttributes(const TestResult&amp; result);\n\n  // Streams an XML representation of the test properties of a TestResult\n  // object.\n  static void OutputXmlTestProperties(std::ostream* stream,\n                                      const TestResult&amp; result);\n\n  // The output file.\n  const std::string output_file_;\n\n  XmlUnitTestResultPrinter(const XmlUnitTestResultPrinter&amp;) = delete;\n  XmlUnitTestResultPrinter&amp; operator=(const XmlUnitTestResultPrinter&amp;) = delete;\n};\n\n// Creates a new XmlUnitTestResultPrinter.\nXmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)\n    : output_file_(output_file) {\n  if (output_file_.empty()) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;XML output file may not be null&quot;;\n  }\n}\n\n// Called after the unit test ends.\nvoid XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                  int /*iteration*/) {\n  FILE* xmlout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintXmlUnitTest(&amp;stream, unit_test);\n  fprintf(xmlout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(xmlout);\n}\n\nvoid XmlUnitTestResultPrinter::ListTestsMatchingFilter(\n    const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  FILE* xmlout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintXmlTestsList(&amp;stream, test_suites);\n  fprintf(xmlout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(xmlout);\n}\n\n// Returns an XML-escaped copy of the input string str.  If is_attribute\n// is true, the text is meant to appear as an attribute value, and\n// normalizable whitespace is preserved by replacing it with character\n// references.\n//\n// Invalid XML characters in str, if any, are stripped from the output.\n// It is expected that most, if not all, of the text processed by this\n// module will consist of ordinary English text.\n// If this module is ever modified to produce version 1.1 XML output,\n// most invalid characters can be retained using character references.\nstd::string XmlUnitTestResultPrinter::EscapeXml(const std::string&amp; str,\n                                                bool is_attribute) {\n  Message m;\n\n  for (size_t i = 0; i &lt; str.size(); ++i) {\n    const char ch = str[i];\n    switch (ch) {\n      case &#x27;&lt;&#x27;:\n        m &lt;&lt; &quot;&amp;lt;&quot;;\n        break;\n      case &#x27;&gt;&#x27;:\n        m &lt;&lt; &quot;&amp;gt;&quot;;\n        break;\n      case &#x27;&amp;&#x27;:\n        m &lt;&lt; &quot;&amp;amp;&quot;;\n        break;\n      case &#x27;\\&#x27;&#x27;:\n        if (is_attribute)\n          m &lt;&lt; &quot;&amp;apos;&quot;;\n        else\n          m &lt;&lt; &#x27;\\&#x27;&#x27;;\n        break;\n      case &#x27;&quot;&#x27;:\n        if (is_attribute)\n          m &lt;&lt; &quot;&amp;quot;&quot;;\n        else\n          m &lt;&lt; &#x27;&quot;&#x27;;\n        break;\n      default:\n        if (IsValidXmlCharacter(static_cast&lt;unsigned char&gt;(ch))) {\n          if (is_attribute &amp;&amp;\n              IsNormalizableWhitespace(static_cast&lt;unsigned char&gt;(ch)))\n            m &lt;&lt; &quot;&amp;#x&quot; &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch))\n              &lt;&lt; &quot;;&quot;;\n          else\n            m &lt;&lt; ch;\n        }\n        break;\n    }\n  }\n\n  return m.GetString();\n}\n\n// Returns the given string with all characters invalid in XML removed.\n// Currently invalid characters are dropped from the string. An\n// alternative is to replace them with certain characters such as . or ?.\nstd::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(\n    const std::string&amp; str) {\n  std::string output;\n  output.reserve(str.size());\n  for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)\n    if (IsValidXmlCharacter(static_cast&lt;unsigned char&gt;(*it)))\n      output.push_back(*it);\n\n  return output;\n}\n\n// The following routines generate an XML representation of a UnitTest\n// object.\n//\n// This is how Google Test concepts map to the DTD:\n//\n// &lt;testsuites name=&quot;AllTests&quot;&gt;        &lt;-- corresponds to a UnitTest object\n//   &lt;testsuite name=&quot;testcase-name&quot;&gt;  &lt;-- corresponds to a TestSuite object\n//     &lt;testcase name=&quot;test-name&quot;&gt;     &lt;-- corresponds to a TestInfo object\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//                                     &lt;-- individual assertion failures\n//     &lt;/testcase&gt;\n//   &lt;/testsuite&gt;\n// &lt;/testsuites&gt;\n\n// Formats the given time in milliseconds as seconds.\nstd::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {\n  ::std::stringstream ss;\n  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3);\n  return ss.str();\n}\n\nstatic bool PortableLocaltime(time_t seconds, struct tm* out) {\n#if defined(_MSC_VER)\n  return localtime_s(out, &amp;seconds) == 0;\n#elif defined(__MINGW32__) || defined(__MINGW64__)\n  // MINGW &lt;time.h&gt; provides neither localtime_r nor localtime_s, but uses\n  // Windows&#x27; localtime(), which has a thread-local tm buffer.\n  struct tm* tm_ptr = localtime(&amp;seconds);  // NOLINT\n  if (tm_ptr == nullptr) return false;\n  *out = *tm_ptr;\n  return true;\n#elif defined(__STDC_LIB_EXT1__)\n  // Uses localtime_s when available as localtime_r is only available from\n  // C23 standard.\n  return localtime_s(&amp;seconds, out) != nullptr;\n#else\n  return localtime_r(&amp;seconds, out) != nullptr;\n#endif\n}\n\n// Converts the given epoch time in milliseconds to a date string in the ISO\n// 8601 format, without the timezone information.\nstd::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {\n  struct tm time_struct;\n  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))\n    return &quot;&quot;;\n  // YYYY-MM-DDThh:mm:ss.sss\n  return StreamableToString(time_struct.tm_year + 1900) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mon + 1) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mday) + &quot;T&quot; +\n         String::FormatIntWidth2(time_struct.tm_hour) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_min) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_sec) + &quot;.&quot; +\n         String::FormatIntWidthN(static_cast&lt;int&gt;(ms % 1000), 3);\n}\n\n// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.\nvoid XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,\n                                                     const char* data) {\n  const char* segment = data;\n  *stream &lt;&lt; &quot;&lt;![CDATA[&quot;;\n  for (;;) {\n    const char* const next_segment = strstr(segment, &quot;]]&gt;&quot;);\n    if (next_segment != nullptr) {\n      stream-&gt;write(segment,\n                    static_cast&lt;std::streamsize&gt;(next_segment - segment));\n      *stream &lt;&lt; &quot;]]&gt;]]&amp;gt;&lt;![CDATA[&quot;;\n      segment = next_segment + strlen(&quot;]]&gt;&quot;);\n    } else {\n      *stream &lt;&lt; segment;\n      break;\n    }\n  }\n  *stream &lt;&lt; &quot;]]&gt;&quot;;\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlAttribute(\n    std::ostream* stream, const std::string&amp; element_name,\n    const std::string&amp; name, const std::string&amp; value) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Attribute &quot; &lt;&lt; name &lt;&lt; &quot; is not allowed for element &lt;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;&gt;.&quot;;\n\n  *stream &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot;=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(value) &lt;&lt; &quot;\\&quot;&quot;;\n}\n\n// Streams a test suite XML stanza containing the given test result.\nvoid XmlUnitTestResultPrinter::OutputXmlTestSuiteForTestResult(\n    ::std::ostream* stream, const TestResult&amp; result) {\n  // Output the boilerplate for a minimal test suite with one test.\n  *stream &lt;&lt; &quot;  &lt;testsuite&quot;;\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;name&quot;, &quot;NonTestSuiteFailure&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;tests&quot;, &quot;1&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;failures&quot;, &quot;1&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;disabled&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;skipped&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;errors&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, &quot;testsuite&quot;, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n  *stream &lt;&lt; &quot;&gt;&quot;;\n\n  // Output the boilerplate for a minimal test case with a single test.\n  *stream &lt;&lt; &quot;    &lt;testcase&quot;;\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;name&quot;, &quot;&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;status&quot;, &quot;run&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;result&quot;, &quot;completed&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;classname&quot;, &quot;&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, &quot;testcase&quot;, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n\n  // Output the actual test result.\n  OutputXmlTestResult(stream, result);\n\n  // Complete the test suite.\n  *stream &lt;&lt; &quot;  &lt;/testsuite&gt;\\n&quot;;\n}\n\n// Prints an XML representation of a TestInfo object.\nvoid XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,\n                                                 const char* test_suite_name,\n                                                 const TestInfo&amp; test_info) {\n  const TestResult&amp; result = *test_info.result();\n  const std::string kTestsuite = &quot;testcase&quot;;\n\n  if (test_info.is_in_another_shard()) {\n    return;\n  }\n\n  *stream &lt;&lt; &quot;    &lt;testcase&quot;;\n  OutputXmlAttribute(stream, kTestsuite, &quot;name&quot;, test_info.name());\n\n  if (test_info.value_param() != nullptr) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;value_param&quot;,\n                       test_info.value_param());\n  }\n  if (test_info.type_param() != nullptr) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;type_param&quot;,\n                       test_info.type_param());\n  }\n\n  OutputXmlAttribute(stream, kTestsuite, &quot;file&quot;, test_info.file());\n  OutputXmlAttribute(stream, kTestsuite, &quot;line&quot;,\n                     StreamableToString(test_info.line()));\n  if (GTEST_FLAG_GET(list_tests)) {\n    *stream &lt;&lt; &quot; /&gt;\\n&quot;;\n    return;\n  }\n\n  OutputXmlAttribute(stream, kTestsuite, &quot;status&quot;,\n                     test_info.should_run() ? &quot;run&quot; : &quot;notrun&quot;);\n  OutputXmlAttribute(stream, kTestsuite, &quot;result&quot;,\n                     test_info.should_run()\n                         ? (result.Skipped() ? &quot;skipped&quot; : &quot;completed&quot;)\n                         : &quot;suppressed&quot;);\n  OutputXmlAttribute(stream, kTestsuite, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, kTestsuite, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n  OutputXmlAttribute(stream, kTestsuite, &quot;classname&quot;, test_suite_name);\n\n  OutputXmlTestResult(stream, result);\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlTestResult(::std::ostream* stream,\n                                                   const TestResult&amp; result) {\n  int failures = 0;\n  int skips = 0;\n  for (int i = 0; i &lt; result.total_part_count(); ++i) {\n    const TestPartResult&amp; part = result.GetTestPartResult(i);\n    if (part.failed()) {\n      if (++failures == 1 &amp;&amp; skips == 0) {\n        *stream &lt;&lt; &quot;&gt;\\n&quot;;\n      }\n      const std::string location =\n          internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                          part.line_number());\n      const std::string summary = location + &quot;\\n&quot; + part.summary();\n      *stream &lt;&lt; &quot;      &lt;failure message=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(summary)\n              &lt;&lt; &quot;\\&quot; type=\\&quot;\\&quot;&gt;&quot;;\n      const std::string detail = location + &quot;\\n&quot; + part.message();\n      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());\n      *stream &lt;&lt; &quot;&lt;/failure&gt;\\n&quot;;\n    } else if (part.skipped()) {\n      if (++skips == 1 &amp;&amp; failures == 0) {\n        *stream &lt;&lt; &quot;&gt;\\n&quot;;\n      }\n      const std::string location =\n          internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                          part.line_number());\n      const std::string summary = location + &quot;\\n&quot; + part.summary();\n      *stream &lt;&lt; &quot;      &lt;skipped message=\\&quot;&quot;\n              &lt;&lt; EscapeXmlAttribute(summary.c_str()) &lt;&lt; &quot;\\&quot;&gt;&quot;;\n      const std::string detail = location + &quot;\\n&quot; + part.message();\n      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());\n      *stream &lt;&lt; &quot;&lt;/skipped&gt;\\n&quot;;\n    }\n  }\n\n  if (failures == 0 &amp;&amp; skips == 0 &amp;&amp; result.test_property_count() == 0) {\n    *stream &lt;&lt; &quot; /&gt;\\n&quot;;\n  } else {\n    if (failures == 0 &amp;&amp; skips == 0) {\n      *stream &lt;&lt; &quot;&gt;\\n&quot;;\n    }\n    OutputXmlTestProperties(stream, result);\n    *stream &lt;&lt; &quot;    &lt;/testcase&gt;\\n&quot;;\n  }\n}\n\n// Prints an XML representation of a TestSuite object\nvoid XmlUnitTestResultPrinter::PrintXmlTestSuite(std::ostream* stream,\n                                                 const TestSuite&amp; test_suite) {\n  const std::string kTestsuite = &quot;testsuite&quot;;\n  *stream &lt;&lt; &quot;  &lt;&quot; &lt;&lt; kTestsuite;\n  OutputXmlAttribute(stream, kTestsuite, &quot;name&quot;, test_suite.name());\n  OutputXmlAttribute(stream, kTestsuite, &quot;tests&quot;,\n                     StreamableToString(test_suite.reportable_test_count()));\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;failures&quot;,\n                       StreamableToString(test_suite.failed_test_count()));\n    OutputXmlAttribute(\n        stream, kTestsuite, &quot;disabled&quot;,\n        StreamableToString(test_suite.reportable_disabled_test_count()));\n    OutputXmlAttribute(stream, kTestsuite, &quot;skipped&quot;,\n                       StreamableToString(test_suite.skipped_test_count()));\n\n    OutputXmlAttribute(stream, kTestsuite, &quot;errors&quot;, &quot;0&quot;);\n\n    OutputXmlAttribute(stream, kTestsuite, &quot;time&quot;,\n                       FormatTimeInMillisAsSeconds(test_suite.elapsed_time()));\n    OutputXmlAttribute(\n        stream, kTestsuite, &quot;timestamp&quot;,\n        FormatEpochTimeInMillisAsIso8601(test_suite.start_timestamp()));\n    *stream &lt;&lt; TestPropertiesAsXmlAttributes(test_suite.ad_hoc_test_result());\n  }\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {\n    if (test_suite.GetTestInfo(i)-&gt;is_reportable())\n      OutputXmlTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));\n  }\n  *stream &lt;&lt; &quot;  &lt;/&quot; &lt;&lt; kTestsuite &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// Prints an XML summary of unit_test to output stream out.\nvoid XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,\n                                                const UnitTest&amp; unit_test) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n\n  *stream &lt;&lt; &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot;;\n  *stream &lt;&lt; &quot;&lt;&quot; &lt;&lt; kTestsuites;\n\n  OutputXmlAttribute(stream, kTestsuites, &quot;tests&quot;,\n                     StreamableToString(unit_test.reportable_test_count()));\n  OutputXmlAttribute(stream, kTestsuites, &quot;failures&quot;,\n                     StreamableToString(unit_test.failed_test_count()));\n  OutputXmlAttribute(\n      stream, kTestsuites, &quot;disabled&quot;,\n      StreamableToString(unit_test.reportable_disabled_test_count()));\n  OutputXmlAttribute(stream, kTestsuites, &quot;errors&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, kTestsuites, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));\n  OutputXmlAttribute(\n      stream, kTestsuites, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));\n\n  if (GTEST_FLAG_GET(shuffle)) {\n    OutputXmlAttribute(stream, kTestsuites, &quot;random_seed&quot;,\n                       StreamableToString(unit_test.random_seed()));\n  }\n  *stream &lt;&lt; TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());\n\n  OutputXmlAttribute(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;);\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0)\n      PrintXmlTestSuite(stream, *unit_test.GetTestSuite(i));\n  }\n\n  // If there was a test failure outside of one of the test suites (like in a\n  // test environment) include that in the output.\n  if (unit_test.ad_hoc_test_result().Failed()) {\n    OutputXmlTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());\n  }\n\n  *stream &lt;&lt; &quot;&lt;/&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\nvoid XmlUnitTestResultPrinter::PrintXmlTestsList(\n    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n\n  *stream &lt;&lt; &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot;;\n  *stream &lt;&lt; &quot;&lt;&quot; &lt;&lt; kTestsuites;\n\n  int total_tests = 0;\n  for (auto test_suite : test_suites) {\n    total_tests += test_suite-&gt;total_test_count();\n  }\n  OutputXmlAttribute(stream, kTestsuites, &quot;tests&quot;,\n                     StreamableToString(total_tests));\n  OutputXmlAttribute(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;);\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n\n  for (auto test_suite : test_suites) {\n    PrintXmlTestSuite(stream, *test_suite);\n  }\n  *stream &lt;&lt; &quot;&lt;/&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// Produces a string representing the test properties in a result as space\n// delimited XML attributes based on the property key=&quot;value&quot; pairs.\nstd::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(\n    const TestResult&amp; result) {\n  Message attributes;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    attributes &lt;&lt; &quot; &quot; &lt;&lt; property.key() &lt;&lt; &quot;=&quot;\n               &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return attributes.GetString();\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlTestProperties(\n    std::ostream* stream, const TestResult&amp; result) {\n  const std::string kProperties = &quot;properties&quot;;\n  const std::string kProperty = &quot;property&quot;;\n\n  if (result.test_property_count() &lt;= 0) {\n    return;\n  }\n\n  *stream &lt;&lt; &quot;      &lt;&quot; &lt;&lt; kProperties &lt;&lt; &quot;&gt;\\n&quot;;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    *stream &lt;&lt; &quot;        &lt;&quot; &lt;&lt; kProperty;\n    *stream &lt;&lt; &quot; name=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(property.key()) &lt;&lt; &quot;\\&quot;&quot;;\n    *stream &lt;&lt; &quot; value=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n    *stream &lt;&lt; &quot;/&gt;\\n&quot;;\n  }\n  *stream &lt;&lt; &quot;      &lt;/&quot; &lt;&lt; kProperties &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// End XmlUnitTestResultPrinter\n\n// This class generates an JSON output file.\nclass JsonUnitTestResultPrinter : public EmptyTestEventListener {\n public:\n  explicit JsonUnitTestResultPrinter(const char* output_file);\n\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n\n  // Prints an JSON summary of all unit tests.\n  static void PrintJsonTestList(::std::ostream* stream,\n                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n private:\n  // Returns an JSON-escaped copy of the input string str.\n  static std::string EscapeJson(const std::string&amp; str);\n\n  //// Verifies that the given attribute belongs to the given element and\n  //// streams the attribute as JSON.\n  static void OutputJsonKey(std::ostream* stream,\n                            const std::string&amp; element_name,\n                            const std::string&amp; name, const std::string&amp; value,\n                            const std::string&amp; indent, bool comma = true);\n  static void OutputJsonKey(std::ostream* stream,\n                            const std::string&amp; element_name,\n                            const std::string&amp; name, int value,\n                            const std::string&amp; indent, bool comma = true);\n\n  // Streams a test suite JSON stanza containing the given test result.\n  //\n  // Requires: result.Failed()\n  static void OutputJsonTestSuiteForTestResult(::std::ostream* stream,\n                                               const TestResult&amp; result);\n\n  // Streams a JSON representation of a TestResult object.\n  static void OutputJsonTestResult(::std::ostream* stream,\n                                   const TestResult&amp; result);\n\n  // Streams a JSON representation of a TestInfo object.\n  static void OutputJsonTestInfo(::std::ostream* stream,\n                                 const char* test_suite_name,\n                                 const TestInfo&amp; test_info);\n\n  // Prints a JSON representation of a TestSuite object\n  static void PrintJsonTestSuite(::std::ostream* stream,\n                                 const TestSuite&amp; test_suite);\n\n  // Prints a JSON summary of unit_test to output stream out.\n  static void PrintJsonUnitTest(::std::ostream* stream,\n                                const UnitTest&amp; unit_test);\n\n  // Produces a string representing the test properties in a result as\n  // a JSON dictionary.\n  static std::string TestPropertiesAsJson(const TestResult&amp; result,\n                                          const std::string&amp; indent);\n\n  // The output file.\n  const std::string output_file_;\n\n  JsonUnitTestResultPrinter(const JsonUnitTestResultPrinter&amp;) = delete;\n  JsonUnitTestResultPrinter&amp; operator=(const JsonUnitTestResultPrinter&amp;) =\n      delete;\n};\n\n// Creates a new JsonUnitTestResultPrinter.\nJsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char* output_file)\n    : output_file_(output_file) {\n  if (output_file_.empty()) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;JSON output file may not be null&quot;;\n  }\n}\n\nvoid JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                   int /*iteration*/) {\n  FILE* jsonout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintJsonUnitTest(&amp;stream, unit_test);\n  fprintf(jsonout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(jsonout);\n}\n\n// Returns an JSON-escaped copy of the input string str.\nstd::string JsonUnitTestResultPrinter::EscapeJson(const std::string&amp; str) {\n  Message m;\n\n  for (size_t i = 0; i &lt; str.size(); ++i) {\n    const char ch = str[i];\n    switch (ch) {\n      case &#x27;\\\\&#x27;:\n      case &#x27;&quot;&#x27;:\n      case &#x27;/&#x27;:\n        m &lt;&lt; &#x27;\\\\&#x27; &lt;&lt; ch;\n        break;\n      case &#x27;\\b&#x27;:\n        m &lt;&lt; &quot;\\\\b&quot;;\n        break;\n      case &#x27;\\t&#x27;:\n        m &lt;&lt; &quot;\\\\t&quot;;\n        break;\n      case &#x27;\\n&#x27;:\n        m &lt;&lt; &quot;\\\\n&quot;;\n        break;\n      case &#x27;\\f&#x27;:\n        m &lt;&lt; &quot;\\\\f&quot;;\n        break;\n      case &#x27;\\r&#x27;:\n        m &lt;&lt; &quot;\\\\r&quot;;\n        break;\n      default:\n        if (ch &lt; &#x27; &#x27;) {\n          m &lt;&lt; &quot;\\\\u00&quot; &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch));\n        } else {\n          m &lt;&lt; ch;\n        }\n        break;\n    }\n  }\n\n  return m.GetString();\n}\n\n// The following routines generate an JSON representation of a UnitTest\n// object.\n\n// Formats the given time in milliseconds as seconds.\nstatic std::string FormatTimeInMillisAsDuration(TimeInMillis ms) {\n  ::std::stringstream ss;\n  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3) &lt;&lt; &quot;s&quot;;\n  return ss.str();\n}\n\n// Converts the given epoch time in milliseconds to a date string in the\n// RFC3339 format, without the timezone information.\nstatic std::string FormatEpochTimeInMillisAsRFC3339(TimeInMillis ms) {\n  struct tm time_struct;\n  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))\n    return &quot;&quot;;\n  // YYYY-MM-DDThh:mm:ss\n  return StreamableToString(time_struct.tm_year + 1900) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mon + 1) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mday) + &quot;T&quot; +\n         String::FormatIntWidth2(time_struct.tm_hour) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_min) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_sec) + &quot;Z&quot;;\n}\n\nstatic inline std::string Indent(size_t width) {\n  return std::string(width, &#x27; &#x27;);\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonKey(std::ostream* stream,\n                                              const std::string&amp; element_name,\n                                              const std::string&amp; name,\n                                              const std::string&amp; value,\n                                              const std::string&amp; indent,\n                                              bool comma) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Key \\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot; is not allowed for value \\&quot;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;\\&quot;.&quot;;\n\n  *stream &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot;: \\&quot;&quot; &lt;&lt; EscapeJson(value) &lt;&lt; &quot;\\&quot;&quot;;\n  if (comma) *stream &lt;&lt; &quot;,\\n&quot;;\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonKey(\n    std::ostream* stream, const std::string&amp; element_name,\n    const std::string&amp; name, int value, const std::string&amp; indent, bool comma) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Key \\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot; is not allowed for value \\&quot;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;\\&quot;.&quot;;\n\n  *stream &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; StreamableToString(value);\n  if (comma) *stream &lt;&lt; &quot;,\\n&quot;;\n}\n\n// Streams a test suite JSON stanza containing the given test result.\nvoid JsonUnitTestResultPrinter::OutputJsonTestSuiteForTestResult(\n    ::std::ostream* stream, const TestResult&amp; result) {\n  // Output the boilerplate for a new test suite.\n  *stream &lt;&lt; Indent(4) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, &quot;testsuite&quot;, &quot;name&quot;, &quot;NonTestSuiteFailure&quot;, Indent(6));\n  OutputJsonKey(stream, &quot;testsuite&quot;, &quot;tests&quot;, 1, Indent(6));\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;failures&quot;, 1, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;disabled&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;skipped&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;errors&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;time&quot;,\n                  FormatTimeInMillisAsDuration(result.elapsed_time()),\n                  Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;timestamp&quot;,\n                  FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                  Indent(6));\n  }\n  *stream &lt;&lt; Indent(6) &lt;&lt; &quot;\\&quot;testsuite\\&quot;: [\\n&quot;;\n\n  // Output the boilerplate for a new test case.\n  *stream &lt;&lt; Indent(8) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;name&quot;, &quot;&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;status&quot;, &quot;RUN&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;result&quot;, &quot;COMPLETED&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(result.elapsed_time()),\n                Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;classname&quot;, &quot;&quot;, Indent(10), false);\n  *stream &lt;&lt; TestPropertiesAsJson(result, Indent(10));\n\n  // Output the actual test result.\n  OutputJsonTestResult(stream, result);\n\n  // Finish the test suite.\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(6) &lt;&lt; &quot;]\\n&quot; &lt;&lt; Indent(4) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints a JSON representation of a TestInfo object.\nvoid JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,\n                                                   const char* test_suite_name,\n                                                   const TestInfo&amp; test_info) {\n  const TestResult&amp; result = *test_info.result();\n  const std::string kTestsuite = &quot;testcase&quot;;\n  const std::string kIndent = Indent(10);\n\n  *stream &lt;&lt; Indent(8) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, kTestsuite, &quot;name&quot;, test_info.name(), kIndent);\n\n  if (test_info.value_param() != nullptr) {\n    OutputJsonKey(stream, kTestsuite, &quot;value_param&quot;, test_info.value_param(),\n                  kIndent);\n  }\n  if (test_info.type_param() != nullptr) {\n    OutputJsonKey(stream, kTestsuite, &quot;type_param&quot;, test_info.type_param(),\n                  kIndent);\n  }\n\n  OutputJsonKey(stream, kTestsuite, &quot;file&quot;, test_info.file(), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;line&quot;, test_info.line(), kIndent, false);\n  if (GTEST_FLAG_GET(list_tests)) {\n    *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(8) &lt;&lt; &quot;}&quot;;\n    return;\n  } else {\n    *stream &lt;&lt; &quot;,\\n&quot;;\n  }\n\n  OutputJsonKey(stream, kTestsuite, &quot;status&quot;,\n                test_info.should_run() ? &quot;RUN&quot; : &quot;NOTRUN&quot;, kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;result&quot;,\n                test_info.should_run()\n                    ? (result.Skipped() ? &quot;SKIPPED&quot; : &quot;COMPLETED&quot;)\n                    : &quot;SUPPRESSED&quot;,\n                kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;classname&quot;, test_suite_name, kIndent,\n                false);\n  *stream &lt;&lt; TestPropertiesAsJson(result, kIndent);\n\n  OutputJsonTestResult(stream, result);\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonTestResult(::std::ostream* stream,\n                                                     const TestResult&amp; result) {\n  const std::string kIndent = Indent(10);\n\n  int failures = 0;\n  for (int i = 0; i &lt; result.total_part_count(); ++i) {\n    const TestPartResult&amp; part = result.GetTestPartResult(i);\n    if (part.failed()) {\n      *stream &lt;&lt; &quot;,\\n&quot;;\n      if (++failures == 1) {\n        *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot;\n                &lt;&lt; &quot;failures&quot;\n                &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n      }\n      const std::string location =\n          internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                          part.line_number());\n      const std::string message = EscapeJson(location + &quot;\\n&quot; + part.message());\n      *stream &lt;&lt; kIndent &lt;&lt; &quot;  {\\n&quot;\n              &lt;&lt; kIndent &lt;&lt; &quot;    \\&quot;failure\\&quot;: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;,\\n&quot;\n              &lt;&lt; kIndent &lt;&lt; &quot;    \\&quot;type\\&quot;: \\&quot;\\&quot;\\n&quot;\n              &lt;&lt; kIndent &lt;&lt; &quot;  }&quot;;\n    }\n  }\n\n  if (failures &gt; 0) *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; kIndent &lt;&lt; &quot;]&quot;;\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(8) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints an JSON representation of a TestSuite object\nvoid JsonUnitTestResultPrinter::PrintJsonTestSuite(\n    std::ostream* stream, const TestSuite&amp; test_suite) {\n  const std::string kTestsuite = &quot;testsuite&quot;;\n  const std::string kIndent = Indent(6);\n\n  *stream &lt;&lt; Indent(4) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, kTestsuite, &quot;name&quot;, test_suite.name(), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;tests&quot;, test_suite.reportable_test_count(),\n                kIndent);\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputJsonKey(stream, kTestsuite, &quot;failures&quot;,\n                  test_suite.failed_test_count(), kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;disabled&quot;,\n                  test_suite.reportable_disabled_test_count(), kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;errors&quot;, 0, kIndent);\n    OutputJsonKey(\n        stream, kTestsuite, &quot;timestamp&quot;,\n        FormatEpochTimeInMillisAsRFC3339(test_suite.start_timestamp()),\n        kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;time&quot;,\n                  FormatTimeInMillisAsDuration(test_suite.elapsed_time()),\n                  kIndent, false);\n    *stream &lt;&lt; TestPropertiesAsJson(test_suite.ad_hoc_test_result(), kIndent)\n            &lt;&lt; &quot;,\\n&quot;;\n  }\n\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuite &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  bool comma = false;\n  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {\n    if (test_suite.GetTestInfo(i)-&gt;is_reportable()) {\n      if (comma) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n      } else {\n        comma = true;\n      }\n      OutputJsonTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));\n    }\n  }\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot; &lt;&lt; Indent(4) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints a JSON summary of unit_test to output stream out.\nvoid JsonUnitTestResultPrinter::PrintJsonUnitTest(std::ostream* stream,\n                                                  const UnitTest&amp; unit_test) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n  const std::string kIndent = Indent(2);\n  *stream &lt;&lt; &quot;{\\n&quot;;\n\n  OutputJsonKey(stream, kTestsuites, &quot;tests&quot;, unit_test.reportable_test_count(),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;failures&quot;, unit_test.failed_test_count(),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;disabled&quot;,\n                unit_test.reportable_disabled_test_count(), kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;errors&quot;, 0, kIndent);\n  if (GTEST_FLAG_GET(shuffle)) {\n    OutputJsonKey(stream, kTestsuites, &quot;random_seed&quot;, unit_test.random_seed(),\n                  kIndent);\n  }\n  OutputJsonKey(stream, kTestsuites, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(unit_test.start_timestamp()),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(unit_test.elapsed_time()), kIndent,\n                false);\n\n  *stream &lt;&lt; TestPropertiesAsJson(unit_test.ad_hoc_test_result(), kIndent)\n          &lt;&lt; &quot;,\\n&quot;;\n\n  OutputJsonKey(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;, kIndent);\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  bool comma = false;\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0) {\n      if (comma) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n      } else {\n        comma = true;\n      }\n      PrintJsonTestSuite(stream, *unit_test.GetTestSuite(i));\n    }\n  }\n\n  // If there was a test failure outside of one of the test suites (like in a\n  // test environment) include that in the output.\n  if (unit_test.ad_hoc_test_result().Failed()) {\n    OutputJsonTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());\n  }\n\n  *stream &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot;\n          &lt;&lt; &quot;}\\n&quot;;\n}\n\nvoid JsonUnitTestResultPrinter::PrintJsonTestList(\n    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n  const std::string kIndent = Indent(2);\n  *stream &lt;&lt; &quot;{\\n&quot;;\n  int total_tests = 0;\n  for (auto test_suite : test_suites) {\n    total_tests += test_suite-&gt;total_test_count();\n  }\n  OutputJsonKey(stream, kTestsuites, &quot;tests&quot;, total_tests, kIndent);\n\n  OutputJsonKey(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;, kIndent);\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  for (size_t i = 0; i &lt; test_suites.size(); ++i) {\n    if (i != 0) {\n      *stream &lt;&lt; &quot;,\\n&quot;;\n    }\n    PrintJsonTestSuite(stream, *test_suites[i]);\n  }\n\n  *stream &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot;\n          &lt;&lt; &quot;}\\n&quot;;\n}\n// Produces a string representing the test properties in a result as\n// a JSON dictionary.\nstd::string JsonUnitTestResultPrinter::TestPropertiesAsJson(\n    const TestResult&amp; result, const std::string&amp; indent) {\n  Message attributes;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    attributes &lt;&lt; &quot;,\\n&quot;\n               &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; property.key() &lt;&lt; &quot;\\&quot;: &quot;\n               &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; EscapeJson(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return attributes.GetString();\n}\n\n// End JsonUnitTestResultPrinter\n\n#if GTEST_CAN_STREAM_RESULTS_\n\n// Checks if str contains &#x27;=&#x27;, &#x27;&amp;&#x27;, &#x27;%&#x27; or &#x27;\\n&#x27; characters. If yes,\n// replaces them by &quot;%xx&quot; where xx is their hexadecimal value. For\n// example, replaces &quot;=&quot; with &quot;%3D&quot;.  This algorithm is O(strlen(str))\n// in both time and space -- important as the input str may contain an\n// arbitrarily long test failure message and stack trace.\nstd::string StreamingListener::UrlEncode(const char* str) {\n  std::string result;\n  result.reserve(strlen(str) + 1);\n  for (char ch = *str; ch != &#x27;\\0&#x27;; ch = *++str) {\n    switch (ch) {\n      case &#x27;%&#x27;:\n      case &#x27;=&#x27;:\n      case &#x27;&amp;&#x27;:\n      case &#x27;\\n&#x27;:\n        result.append(&quot;%&quot; + String::FormatByte(static_cast&lt;unsigned char&gt;(ch)));\n        break;\n      default:\n        result.push_back(ch);\n        break;\n    }\n  }\n  return result;\n}\n\nvoid StreamingListener::SocketWriter::MakeConnection() {\n  GTEST_CHECK_(sockfd_ == -1)\n      &lt;&lt; &quot;MakeConnection() can&#x27;t be called when there is already a connection.&quot;;\n\n  addrinfo hints;\n  memset(&amp;hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;  // To allow both IPv4 and IPv6 addresses.\n  hints.ai_socktype = SOCK_STREAM;\n  addrinfo* servinfo = nullptr;\n\n  // Use the getaddrinfo() to get a linked list of IP addresses for\n  // the given host name.\n  const int error_num =\n      getaddrinfo(host_name_.c_str(), port_num_.c_str(), &amp;hints, &amp;servinfo);\n  if (error_num != 0) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;stream_result_to: getaddrinfo() failed: &quot;\n                        &lt;&lt; gai_strerror(error_num);\n  }\n\n  // Loop through all the results and connect to the first we can.\n  for (addrinfo* cur_addr = servinfo; sockfd_ == -1 &amp;&amp; cur_addr != nullptr;\n       cur_addr = cur_addr-&gt;ai_next) {\n    sockfd_ = socket(cur_addr-&gt;ai_family, cur_addr-&gt;ai_socktype,\n                     cur_addr-&gt;ai_protocol);\n    if (sockfd_ != -1) {\n      // Connect the client socket to the server socket.\n      if (connect(sockfd_, cur_addr-&gt;ai_addr, cur_addr-&gt;ai_addrlen) == -1) {\n        close(sockfd_);\n        sockfd_ = -1;\n      }\n    }\n  }\n\n  freeaddrinfo(servinfo);  // all done with this structure\n\n  if (sockfd_ == -1) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;stream_result_to: failed to connect to &quot;\n                        &lt;&lt; host_name_ &lt;&lt; &quot;:&quot; &lt;&lt; port_num_;\n  }\n}\n\n// End of class Streaming Listener\n#endif  // GTEST_CAN_STREAM_RESULTS__\n\n// class OsStackTraceGetter\n\nconst char* const OsStackTraceGetterInterface::kElidedFramesMarker =\n    &quot;... &quot; GTEST_NAME_ &quot; internal frames ...&quot;;\n\nstd::string OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n#if GTEST_HAS_ABSL\n  std::string result;\n\n  if (max_depth &lt;= 0) {\n    return result;\n  }\n\n  max_depth = std::min(max_depth, kMaxStackTraceDepth);\n\n  std::vector&lt;void*&gt; raw_stack(max_depth);\n  // Skips the frames requested by the caller, plus this function.\n  const int raw_stack_size =\n      absl::GetStackTrace(&amp;raw_stack[0], max_depth, skip_count + 1);\n\n  void* caller_frame = nullptr;\n  {\n    MutexLock lock(&amp;mutex_);\n    caller_frame = caller_frame_;\n  }\n\n  for (int i = 0; i &lt; raw_stack_size; ++i) {\n    if (raw_stack[i] == caller_frame &amp;&amp;\n        !GTEST_FLAG_GET(show_internal_stack_frames)) {\n      // Add a marker to the trace and stop adding frames.\n      absl::StrAppend(&amp;result, kElidedFramesMarker, &quot;\\n&quot;);\n      break;\n    }\n\n    char tmp[1024];\n    const char* symbol = &quot;(unknown)&quot;;\n    if (absl::Symbolize(raw_stack[i], tmp, sizeof(tmp))) {\n      symbol = tmp;\n    }\n\n    char line[1024];\n    snprintf(line, sizeof(line), &quot;  %p: %s\\n&quot;, raw_stack[i], symbol);\n    result += line;\n  }\n\n  return result;\n\n#else   // !GTEST_HAS_ABSL\n  static_cast&lt;void&gt;(max_depth);\n  static_cast&lt;void&gt;(skip_count);\n  return &quot;&quot;;\n#endif  // GTEST_HAS_ABSL\n}\n\nvoid OsStackTraceGetter::UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_) {\n#if GTEST_HAS_ABSL\n  void* caller_frame = nullptr;\n  if (absl::GetStackTrace(&amp;caller_frame, 1, 3) &lt;= 0) {\n    caller_frame = nullptr;\n  }\n\n  MutexLock lock(&amp;mutex_);\n  caller_frame_ = caller_frame;\n#endif  // GTEST_HAS_ABSL\n}\n\n// A helper class that creates the premature-exit file in its\n// constructor and deletes the file in its destructor.\nclass ScopedPrematureExitFile {\n public:\n  explicit ScopedPrematureExitFile(const char* premature_exit_filepath)\n      : premature_exit_filepath_(\n            premature_exit_filepath ? premature_exit_filepath : &quot;&quot;) {\n    // If a path to the premature-exit file is specified...\n    if (!premature_exit_filepath_.empty()) {\n      // create the file with a single &quot;0&quot; character in it.  I/O\n      // errors are ignored as there&#x27;s nothing better we can do and we\n      // don&#x27;t want to fail the test because of this.\n      FILE* pfile = posix::FOpen(premature_exit_filepath_.c_str(), &quot;w&quot;);\n      fwrite(&quot;0&quot;, 1, 1, pfile);\n      fclose(pfile);\n    }\n  }\n\n  ~ScopedPrematureExitFile() {\n#if !defined GTEST_OS_ESP8266\n    if (!premature_exit_filepath_.empty()) {\n      int retval = remove(premature_exit_filepath_.c_str());\n      if (retval) {\n        GTEST_LOG_(ERROR) &lt;&lt; &quot;Failed to remove premature exit filepath \\&quot;&quot;\n                          &lt;&lt; premature_exit_filepath_ &lt;&lt; &quot;\\&quot; with error &quot;\n                          &lt;&lt; retval;\n      }\n    }\n#endif\n  }\n\n private:\n  const std::string premature_exit_filepath_;\n\n  ScopedPrematureExitFile(const ScopedPrematureExitFile&amp;) = delete;\n  ScopedPrematureExitFile&amp; operator=(const ScopedPrematureExitFile&amp;) = delete;\n};\n\n}  // namespace internal\n\n// class TestEventListeners\n\nTestEventListeners::TestEventListeners()\n    : repeater_(new internal::TestEventRepeater()),\n      default_result_printer_(nullptr),\n      default_xml_generator_(nullptr) {}\n\nTestEventListeners::~TestEventListeners() { delete repeater_; }\n\n// Returns the standard listener responsible for the default console\n// output.  Can be removed from the listeners list to shut down default\n// console output.  Note that removing this object from the listener list\n// with Release transfers its ownership to the user.\nvoid TestEventListeners::Append(TestEventListener* listener) {\n  repeater_-&gt;Append(listener);\n}\n\n// Removes the given event listener from the list and returns it.  It then\n// becomes the caller&#x27;s responsibility to delete the listener. Returns\n// NULL if the listener is not found in the list.\nTestEventListener* TestEventListeners::Release(TestEventListener* listener) {\n  if (listener == default_result_printer_)\n    default_result_printer_ = nullptr;\n  else if (listener == default_xml_generator_)\n    default_xml_generator_ = nullptr;\n  return repeater_-&gt;Release(listener);\n}\n\n// Returns repeater that broadcasts the TestEventListener events to all\n// subscribers.\nTestEventListener* TestEventListeners::repeater() { return repeater_; }\n\n// Sets the default_result_printer attribute to the provided listener.\n// The listener is also added to the listener list and previous\n// default_result_printer is removed from it and deleted. The listener can\n// also be NULL in which case it will not be added to the list. Does\n// nothing if the previous and the current listener objects are the same.\nvoid TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {\n  if (default_result_printer_ != listener) {\n    // It is an error to pass this method a listener that is already in the\n    // list.\n    delete Release(default_result_printer_);\n    default_result_printer_ = listener;\n    if (listener != nullptr) Append(listener);\n  }\n}\n\n// Sets the default_xml_generator attribute to the provided listener.  The\n// listener is also added to the listener list and previous\n// default_xml_generator is removed from it and deleted. The listener can\n// also be NULL in which case it will not be added to the list. Does\n// nothing if the previous and the current listener objects are the same.\nvoid TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {\n  if (default_xml_generator_ != listener) {\n    // It is an error to pass this method a listener that is already in the\n    // list.\n    delete Release(default_xml_generator_);\n    default_xml_generator_ = listener;\n    if (listener != nullptr) Append(listener);\n  }\n}\n\n// Controls whether events will be forwarded by the repeater to the\n// listeners in the list.\nbool TestEventListeners::EventForwardingEnabled() const {\n  return repeater_-&gt;forwarding_enabled();\n}\n\nvoid TestEventListeners::SuppressEventForwarding() {\n  repeater_-&gt;set_forwarding_enabled(false);\n}\n\n// class UnitTest\n\n// Gets the singleton UnitTest object.  The first time this method is\n// called, a UnitTest object is constructed and returned.  Consecutive\n// calls will return the same object.\n//\n// We don&#x27;t protect this under mutex_ as a user is not supposed to\n// call this before main() starts, from which point on the return\n// value will never change.\nUnitTest* UnitTest::GetInstance() {\n  // CodeGear C++Builder insists on a public destructor for the\n  // default implementation.  Use this implementation to keep good OO\n  // design with private destructor.\n\n#if defined(__BORLANDC__)\n  static UnitTest* const instance = new UnitTest;\n  return instance;\n#else\n  static UnitTest instance;\n  return &amp;instance;\n#endif  // defined(__BORLANDC__)\n}\n\n// Gets the number of successful test suites.\nint UnitTest::successful_test_suite_count() const {\n  return impl()-&gt;successful_test_suite_count();\n}\n\n// Gets the number of failed test suites.\nint UnitTest::failed_test_suite_count() const {\n  return impl()-&gt;failed_test_suite_count();\n}\n\n// Gets the number of all test suites.\nint UnitTest::total_test_suite_count() const {\n  return impl()-&gt;total_test_suite_count();\n}\n\n// Gets the number of all test suites that contain at least one test\n// that should run.\nint UnitTest::test_suite_to_run_count() const {\n  return impl()-&gt;test_suite_to_run_count();\n}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nint UnitTest::successful_test_case_count() const {\n  return impl()-&gt;successful_test_suite_count();\n}\nint UnitTest::failed_test_case_count() const {\n  return impl()-&gt;failed_test_suite_count();\n}\nint UnitTest::total_test_case_count() const {\n  return impl()-&gt;total_test_suite_count();\n}\nint UnitTest::test_case_to_run_count() const {\n  return impl()-&gt;test_suite_to_run_count();\n}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n// Gets the number of successful tests.\nint UnitTest::successful_test_count() const {\n  return impl()-&gt;successful_test_count();\n}\n\n// Gets the number of skipped tests.\nint UnitTest::skipped_test_count() const {\n  return impl()-&gt;skipped_test_count();\n}\n\n// Gets the number of failed tests.\nint UnitTest::failed_test_count() const { return impl()-&gt;failed_test_count(); }\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint UnitTest::reportable_disabled_test_count() const {\n  return impl()-&gt;reportable_disabled_test_count();\n}\n\n// Gets the number of disabled tests.\nint UnitTest::disabled_test_count() const {\n  return impl()-&gt;disabled_test_count();\n}\n\n// Gets the number of tests to be printed in the XML report.\nint UnitTest::reportable_test_count() const {\n  return impl()-&gt;reportable_test_count();\n}\n\n// Gets the number of all tests.\nint UnitTest::total_test_count() const { return impl()-&gt;total_test_count(); }\n\n// Gets the number of tests that should run.\nint UnitTest::test_to_run_count() const { return impl()-&gt;test_to_run_count(); }\n\n// Gets the time of the test program start, in ms from the start of the\n// UNIX epoch.\ninternal::TimeInMillis UnitTest::start_timestamp() const {\n  return impl()-&gt;start_timestamp();\n}\n\n// Gets the elapsed time, in milliseconds.\ninternal::TimeInMillis UnitTest::elapsed_time() const {\n  return impl()-&gt;elapsed_time();\n}\n\n// Returns true if and only if the unit test passed (i.e. all test suites\n// passed).\nbool UnitTest::Passed() const { return impl()-&gt;Passed(); }\n\n// Returns true if and only if the unit test failed (i.e. some test suite\n// failed or something outside of all tests failed).\nbool UnitTest::Failed() const { return impl()-&gt;Failed(); }\n\n// Gets the i-th test suite among all the test suites. i can range from 0 to\n// total_test_suite_count() - 1. If i is not in that range, returns NULL.\nconst TestSuite* UnitTest::GetTestSuite(int i) const {\n  return impl()-&gt;GetTestSuite(i);\n}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nconst TestCase* UnitTest::GetTestCase(int i) const {\n  return impl()-&gt;GetTestCase(i);\n}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n// Returns the TestResult containing information on test failures and\n// properties logged outside of individual test suites.\nconst TestResult&amp; UnitTest::ad_hoc_test_result() const {\n  return *impl()-&gt;ad_hoc_test_result();\n}\n\n// Gets the i-th test suite among all the test suites. i can range from 0 to\n// total_test_suite_count() - 1. If i is not in that range, returns NULL.\nTestSuite* UnitTest::GetMutableTestSuite(int i) {\n  return impl()-&gt;GetMutableSuiteCase(i);\n}\n\n// Returns the list of event listeners that can be used to track events\n// inside Google Test.\nTestEventListeners&amp; UnitTest::listeners() { return *impl()-&gt;listeners(); }\n\n// Registers and returns a global test environment.  When a test\n// program is run, all global test environments will be set-up in the\n// order they were registered.  After all tests in the program have\n// finished, all global test environments will be torn-down in the\n// *reverse* order they were registered.\n//\n// The UnitTest object takes ownership of the given environment.\n//\n// We don&#x27;t protect this under mutex_, as we only support calling it\n// from the main thread.\nEnvironment* UnitTest::AddEnvironment(Environment* env) {\n  if (env == nullptr) {\n    return nullptr;\n  }\n\n  impl_-&gt;environments().push_back(env);\n  return env;\n}\n\n// Adds a TestPartResult to the current TestResult object.  All Google Test\n// assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call\n// this to report their results.  The user code should use the\n// assertion macros instead of calling this directly.\nvoid UnitTest::AddTestPartResult(TestPartResult::Type result_type,\n                                 const char* file_name, int line_number,\n                                 const std::string&amp; message,\n                                 const std::string&amp; os_stack_trace)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  Message msg;\n  msg &lt;&lt; message;\n\n  internal::MutexLock lock(&amp;mutex_);\n  if (impl_-&gt;gtest_trace_stack().size() &gt; 0) {\n    msg &lt;&lt; &quot;\\n&quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot; trace:&quot;;\n\n    for (size_t i = impl_-&gt;gtest_trace_stack().size(); i &gt; 0; --i) {\n      const internal::TraceInfo&amp; trace = impl_-&gt;gtest_trace_stack()[i - 1];\n      msg &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; internal::FormatFileLocation(trace.file, trace.line) &lt;&lt; &quot; &quot;\n          &lt;&lt; trace.message;\n    }\n  }\n\n  if (os_stack_trace.c_str() != nullptr &amp;&amp; !os_stack_trace.empty()) {\n    msg &lt;&lt; internal::kStackTraceMarker &lt;&lt; os_stack_trace;\n  }\n\n  const TestPartResult result = TestPartResult(\n      result_type, file_name, line_number, msg.GetString().c_str());\n  impl_-&gt;GetTestPartResultReporterForCurrentThread()-&gt;ReportTestPartResult(\n      result);\n\n  if (result_type != TestPartResult::kSuccess &amp;&amp;\n      result_type != TestPartResult::kSkip) {\n    // gtest_break_on_failure takes precedence over\n    // gtest_throw_on_failure.  This allows a user to set the latter\n    // in the code (perhaps in order to use Google Test assertions\n    // with another testing framework) and specify the former on the\n    // command line for debugging.\n    if (GTEST_FLAG_GET(break_on_failure)) {\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT\n      // Using DebugBreak on Windows allows gtest to still break into a debugger\n      // when a failure happens and both the --gtest_break_on_failure and\n      // the --gtest_catch_exceptions flags are specified.\n      DebugBreak();\n#elif (!defined(__native_client__)) &amp;&amp;            \\\n    ((defined(__clang__) || defined(__GNUC__)) &amp;&amp; \\\n     (defined(__x86_64__) || defined(__i386__)))\n      // with clang/gcc we can achieve the same effect on x86 by invoking int3\n      asm(&quot;int3&quot;);\n#else\n      // Dereference nullptr through a volatile pointer to prevent the compiler\n      // from removing. We use this rather than abort() or __builtin_trap() for\n      // portability: some debuggers don&#x27;t correctly trap abort().\n      *static_cast&lt;volatile int*&gt;(nullptr) = 1;\n#endif  // GTEST_OS_WINDOWS\n    } else if (GTEST_FLAG_GET(throw_on_failure)) {\n#if GTEST_HAS_EXCEPTIONS\n      throw internal::GoogleTestFailureException(result);\n#else\n      // We cannot call abort() as it generates a pop-up in debug mode\n      // that cannot be suppressed in VC 7.1 or below.\n      exit(1);\n#endif\n    }\n  }\n}\n\n// Adds a TestProperty to the current TestResult object when invoked from\n// inside a test, to current TestSuite&#x27;s ad_hoc_test_result_ when invoked\n// from SetUpTestSuite or TearDownTestSuite, or to the global property set\n// when invoked elsewhere.  If the result already contains a property with\n// the same key, the value will be updated.\nvoid UnitTest::RecordProperty(const std::string&amp; key,\n                              const std::string&amp; value) {\n  impl_-&gt;RecordProperty(TestProperty(key, value));\n}\n\n// Runs all tests in this UnitTest object and prints the result.\n// Returns 0 if successful, or 1 otherwise.\n//\n// We don&#x27;t protect this under mutex_, as we only support calling it\n// from the main thread.\nint UnitTest::Run() {\n  const bool in_death_test_child_process =\n      GTEST_FLAG_GET(internal_run_death_test).length() &gt; 0;\n\n  // Google Test implements this protocol for catching that a test\n  // program exits before returning control to Google Test:\n  //\n  //   1. Upon start, Google Test creates a file whose absolute path\n  //      is specified by the environment variable\n  //      TEST_PREMATURE_EXIT_FILE.\n  //   2. When Google Test has finished its work, it deletes the file.\n  //\n  // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before\n  // running a Google-Test-based test program and check the existence\n  // of the file at the end of the test execution to see if it has\n  // exited prematurely.\n\n  // If we are in the child process of a death test, don&#x27;t\n  // create/delete the premature exit file, as doing so is unnecessary\n  // and will confuse the parent process.  Otherwise, create/delete\n  // the file upon entering/leaving this function.  If the program\n  // somehow exits before this function has a chance to return, the\n  // premature-exit file will be left undeleted, causing a test runner\n  // that understands the premature-exit-file protocol to report the\n  // test as having failed.\n  const internal::ScopedPrematureExitFile premature_exit_file(\n      in_death_test_child_process\n          ? nullptr\n          : internal::posix::GetEnv(&quot;TEST_PREMATURE_EXIT_FILE&quot;));\n\n  // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be\n  // used for the duration of the program.\n  impl()-&gt;set_catch_exceptions(GTEST_FLAG_GET(catch_exceptions));\n\n#if GTEST_OS_WINDOWS\n  // Either the user wants Google Test to catch exceptions thrown by the\n  // tests or this is executing in the context of death test child\n  // process. In either case the user does not want to see pop-up dialogs\n  // about crashes - they are expected.\n  if (impl()-&gt;catch_exceptions() || in_death_test_child_process) {\n#if !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT\n    // SetErrorMode doesn&#x27;t exist on CE.\n    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |\n                 SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n#if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n    // Death test children can be terminated with _abort().  On Windows,\n    // _abort() can show a dialog with a warning message.  This forces the\n    // abort message to go to stderr instead.\n    _set_error_mode(_OUT_TO_STDERR);\n#endif\n\n#if defined(_MSC_VER) &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n    // In the debug version, Visual Studio pops up a separate dialog\n    // offering a choice to debug the aborted program. We need to suppress\n    // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement\n    // executed. Google Test will notify the user of any unexpected\n    // failure via stderr.\n    if (!GTEST_FLAG_GET(break_on_failure))\n      _set_abort_behavior(\n          0x0,                                    // Clear the following flags:\n          _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  // pop-up window, core dump.\n\n    // In debug mode, the Windows CRT can crash with an assertion over invalid\n    // input (e.g. passing an invalid file descriptor).  The default handling\n    // for these assertions is to pop up a dialog and wait for user input.\n    // Instead ask the CRT to dump such assertions to stderr non-interactively.\n    if (!IsDebuggerPresent()) {\n      (void)_CrtSetReportMode(_CRT_ASSERT,\n                              _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n      (void)_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n    }\n#endif\n  }\n#endif  // GTEST_OS_WINDOWS\n\n  return internal::HandleExceptionsInMethodIfSupported(\n             impl(), &amp;internal::UnitTestImpl::RunAllTests,\n             &quot;auxiliary test code (environments or event listeners)&quot;)\n             ? 0\n             : 1;\n}\n\n// Returns the working directory when the first TEST() or TEST_F() was\n// executed.\nconst char* UnitTest::original_working_dir() const {\n  return impl_-&gt;original_working_dir_.c_str();\n}\n\n// Returns the TestSuite object for the test that&#x27;s currently running,\n// or NULL if no test is running.\nconst TestSuite* UnitTest::current_test_suite() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_suite();\n}\n\n// Legacy API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nconst TestCase* UnitTest::current_test_case() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_suite();\n}\n#endif\n\n// Returns the TestInfo object for the test that&#x27;s currently running,\n// or NULL if no test is running.\nconst TestInfo* UnitTest::current_test_info() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_info();\n}\n\n// Returns the random seed used at the start of the current test run.\nint UnitTest::random_seed() const { return impl_-&gt;random_seed(); }\n\n// Returns ParameterizedTestSuiteRegistry object used to keep track of\n// value-parameterized tests and instantiate and register them.\ninternal::ParameterizedTestSuiteRegistry&amp;\nUnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) {\n  return impl_-&gt;parameterized_test_registry();\n}\n\n// Creates an empty UnitTest.\nUnitTest::UnitTest() { impl_ = new internal::UnitTestImpl(this); }\n\n// Destructor of UnitTest.\nUnitTest::~UnitTest() { delete impl_; }\n\n// Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n// Google Test trace stack.\nvoid UnitTest::PushGTestTrace(const internal::TraceInfo&amp; trace)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;gtest_trace_stack().push_back(trace);\n}\n\n// Pops a trace from the per-thread Google Test trace stack.\nvoid UnitTest::PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;gtest_trace_stack().pop_back();\n}\n\nnamespace internal {\n\nUnitTestImpl::UnitTestImpl(UnitTest* parent)\n    : parent_(parent),\n      GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 /* using this in initializer */)\n          default_global_test_part_result_reporter_(this),\n      default_per_thread_test_part_result_reporter_(this),\n      GTEST_DISABLE_MSC_WARNINGS_POP_() global_test_part_result_repoter_(\n          &amp;default_global_test_part_result_reporter_),\n      per_thread_test_part_result_reporter_(\n          &amp;default_per_thread_test_part_result_reporter_),\n      parameterized_test_registry_(),\n      parameterized_tests_registered_(false),\n      last_death_test_suite_(-1),\n      current_test_suite_(nullptr),\n      current_test_info_(nullptr),\n      ad_hoc_test_result_(),\n      os_stack_trace_getter_(nullptr),\n      post_flag_parse_init_performed_(false),\n      random_seed_(0),  // Will be overridden by the flag before first use.\n      random_(0),       // Will be reseeded before first use.\n      start_timestamp_(0),\n      elapsed_time_(0),\n#if GTEST_HAS_DEATH_TEST\n      death_test_factory_(new DefaultDeathTestFactory),\n#endif\n      // Will be overridden by the flag before first use.\n      catch_exceptions_(false) {\n  listeners()-&gt;SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);\n}\n\nUnitTestImpl::~UnitTestImpl() {\n  // Deletes every TestSuite.\n  ForEach(test_suites_, internal::Delete&lt;TestSuite&gt;);\n\n  // Deletes every Environment.\n  ForEach(environments_, internal::Delete&lt;Environment&gt;);\n\n  delete os_stack_trace_getter_;\n}\n\n// Adds a TestProperty to the current TestResult object when invoked in a\n// context of a test, to current test suite&#x27;s ad_hoc_test_result when invoke\n// from SetUpTestSuite/TearDownTestSuite, or to the global property set\n// otherwise.  If the result already contains a property with the same key,\n// the value will be updated.\nvoid UnitTestImpl::RecordProperty(const TestProperty&amp; test_property) {\n  std::string xml_element;\n  TestResult* test_result;  // TestResult appropriate for property recording.\n\n  if (current_test_info_ != nullptr) {\n    xml_element = &quot;testcase&quot;;\n    test_result = &amp;(current_test_info_-&gt;result_);\n  } else if (current_test_suite_ != nullptr) {\n    xml_element = &quot;testsuite&quot;;\n    test_result = &amp;(current_test_suite_-&gt;ad_hoc_test_result_);\n  } else {\n    xml_element = &quot;testsuites&quot;;\n    test_result = &amp;ad_hoc_test_result_;\n  }\n  test_result-&gt;RecordProperty(xml_element, test_property);\n}\n\n#if GTEST_HAS_DEATH_TEST\n// Disables event forwarding if the control is currently in a death test\n// subprocess. Must not be called before InitGoogleTest.\nvoid UnitTestImpl::SuppressTestEventsIfInSubprocess() {\n  if (internal_run_death_test_flag_.get() != nullptr)\n    listeners()-&gt;SuppressEventForwarding();\n}\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Initializes event listeners performing XML output as specified by\n// UnitTestOptions. Must not be called before InitGoogleTest.\nvoid UnitTestImpl::ConfigureXmlOutput() {\n  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();\n  if (output_format == &quot;xml&quot;) {\n    listeners()-&gt;SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(\n        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\n  } else if (output_format == &quot;json&quot;) {\n    listeners()-&gt;SetDefaultXmlGenerator(new JsonUnitTestResultPrinter(\n        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\n  } else if (output_format != &quot;&quot;) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;WARNING: unrecognized output format \\&quot;&quot;\n                        &lt;&lt; output_format &lt;&lt; &quot;\\&quot; ignored.&quot;;\n  }\n}\n\n#if GTEST_CAN_STREAM_RESULTS_\n// Initializes event listeners for streaming test results in string form.\n// Must not be called before InitGoogleTest.\nvoid UnitTestImpl::ConfigureStreamingOutput() {\n  const std::string&amp; target = GTEST_FLAG_GET(stream_result_to);\n  if (!target.empty()) {\n    const size_t pos = target.find(&#x27;:&#x27;);\n    if (pos != std::string::npos) {\n      listeners()-&gt;Append(\n          new StreamingListener(target.substr(0, pos), target.substr(pos + 1)));\n    } else {\n      GTEST_LOG_(WARNING) &lt;&lt; &quot;unrecognized streaming target \\&quot;&quot; &lt;&lt; target\n                          &lt;&lt; &quot;\\&quot; ignored.&quot;;\n    }\n  }\n}\n#endif  // GTEST_CAN_STREAM_RESULTS_\n\n// Performs initialization dependent upon flag values obtained in\n// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to\n// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest\n// this function is also called from RunAllTests.  Since this function can be\n// called more than once, it has to be idempotent.\nvoid UnitTestImpl::PostFlagParsingInit() {\n  // Ensures that this function does not execute more than once.\n  if (!post_flag_parse_init_performed_) {\n    post_flag_parse_init_performed_ = true;\n\n#if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)\n    // Register to send notifications about key process state changes.\n    listeners()-&gt;Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());\n#endif  // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)\n\n#if GTEST_HAS_DEATH_TEST\n    InitDeathTestSubprocessControlInfo();\n    SuppressTestEventsIfInSubprocess();\n#endif  // GTEST_HAS_DEATH_TEST\n\n    // Registers parameterized tests. This makes parameterized tests\n    // available to the UnitTest reflection API without running\n    // RUN_ALL_TESTS.\n    RegisterParameterizedTests();\n\n    // Configures listeners for XML output. This makes it possible for users\n    // to shut down the default XML output before invoking RUN_ALL_TESTS.\n    ConfigureXmlOutput();\n\n    if (GTEST_FLAG_GET(brief)) {\n      listeners()-&gt;SetDefaultResultPrinter(new BriefUnitTestResultPrinter);\n    }\n\n#if GTEST_CAN_STREAM_RESULTS_\n    // Configures listeners for streaming test results to the specified server.\n    ConfigureStreamingOutput();\n#endif  // GTEST_CAN_STREAM_RESULTS_\n\n#if GTEST_HAS_ABSL\n    if (GTEST_FLAG_GET(install_failure_signal_handler)) {\n      absl::FailureSignalHandlerOptions options;\n      absl::InstallFailureSignalHandler(options);\n    }\n#endif  // GTEST_HAS_ABSL\n  }\n}\n\n// A predicate that checks the name of a TestSuite against a known\n// value.\n//\n// This is used for implementation of the UnitTest class only.  We put\n// it in the anonymous namespace to prevent polluting the outer\n// namespace.\n//\n// TestSuiteNameIs is copyable.\nclass TestSuiteNameIs {\n public:\n  // Constructor.\n  explicit TestSuiteNameIs(const std::string&amp; name) : name_(name) {}\n\n  // Returns true if and only if the name of test_suite matches name_.\n  bool operator()(const TestSuite* test_suite) const {\n    return test_suite != nullptr &amp;&amp;\n           strcmp(test_suite-&gt;name(), name_.c_str()) == 0;\n  }\n\n private:\n  std::string name_;\n};\n\n// Finds and returns a TestSuite with the given name.  If one doesn&#x27;t\n// exist, creates one and returns it.  It&#x27;s the CALLER&#x27;S\n// RESPONSIBILITY to ensure that this function is only called WHEN THE\n// TESTS ARE NOT SHUFFLED.\n//\n// Arguments:\n//\n//   test_suite_name: name of the test suite\n//   type_param:      the name of the test suite&#x27;s type parameter, or NULL if\n//                    this is not a typed or a type-parameterized test suite.\n//   set_up_tc:       pointer to the function that sets up the test suite\n//   tear_down_tc:    pointer to the function that tears down the test suite\nTestSuite* UnitTestImpl::GetTestSuite(\n    const char* test_suite_name, const char* type_param,\n    internal::SetUpTestSuiteFunc set_up_tc,\n    internal::TearDownTestSuiteFunc tear_down_tc) {\n  // Can we find a TestSuite with the given name?\n  const auto test_suite =\n      std::find_if(test_suites_.rbegin(), test_suites_.rend(),\n                   TestSuiteNameIs(test_suite_name));\n\n  if (test_suite != test_suites_.rend()) return *test_suite;\n\n  // No.  Let&#x27;s create one.\n  auto* const new_test_suite =\n      new TestSuite(test_suite_name, type_param, set_up_tc, tear_down_tc);\n\n  const UnitTestFilter death_test_suite_filter(kDeathTestSuiteFilter);\n  // Is this a death test suite?\n  if (death_test_suite_filter.MatchesName(test_suite_name)) {\n    // Yes.  Inserts the test suite after the last death test suite\n    // defined so far.  This only works when the test suites haven&#x27;t\n    // been shuffled.  Otherwise we may end up running a death test\n    // after a non-death test.\n    ++last_death_test_suite_;\n    test_suites_.insert(test_suites_.begin() + last_death_test_suite_,\n                        new_test_suite);\n  } else {\n    // No.  Appends to the end of the list.\n    test_suites_.push_back(new_test_suite);\n  }\n\n  test_suite_indices_.push_back(static_cast&lt;int&gt;(test_suite_indices_.size()));\n  return new_test_suite;\n}\n\n// Helpers for setting up / tearing down the given environment.  They\n// are for use in the ForEach() function.\nstatic void SetUpEnvironment(Environment* env) { env-&gt;SetUp(); }\nstatic void TearDownEnvironment(Environment* env) { env-&gt;TearDown(); }\n\n// Runs all tests in this UnitTest object, prints the result, and\n// returns true if all tests are successful.  If any exception is\n// thrown during a test, the test is considered to be failed, but the\n// rest of the tests will still be run.\n//\n// When parameterized tests are enabled, it expands and registers\n// parameterized tests first in RegisterParameterizedTests().\n// All other functions called from RunAllTests() may safely assume that\n// parameterized tests are ready to be counted and run.\nbool UnitTestImpl::RunAllTests() {\n  // True if and only if Google Test is initialized before RUN_ALL_TESTS() is\n  // called.\n  const bool gtest_is_initialized_before_run_all_tests = GTestIsInitialized();\n\n  // Do not run any test if the --help flag was specified.\n  if (g_help_flag) return true;\n\n  // Repeats the call to the post-flag parsing initialization in case the\n  // user didn&#x27;t call InitGoogleTest.\n  PostFlagParsingInit();\n\n  // Even if sharding is not on, test runners may want to use the\n  // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding\n  // protocol.\n  internal::WriteToShardStatusFileIfNeeded();\n\n  // True if and only if we are in a subprocess for running a thread-safe-style\n  // death test.\n  bool in_subprocess_for_death_test = false;\n\n#if GTEST_HAS_DEATH_TEST\n  in_subprocess_for_death_test =\n      (internal_run_death_test_flag_.get() != nullptr);\n#if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)\n  if (in_subprocess_for_death_test) {\n    GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();\n  }\n#endif  // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)\n#endif  // GTEST_HAS_DEATH_TEST\n\n  const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,\n                                        in_subprocess_for_death_test);\n\n  // Compares the full test names with the filter to decide which\n  // tests to run.\n  const bool has_tests_to_run =\n      FilterTests(should_shard ? HONOR_SHARDING_PROTOCOL\n                               : IGNORE_SHARDING_PROTOCOL) &gt; 0;\n\n  // Lists the tests and exits if the --gtest_list_tests flag was specified.\n  if (GTEST_FLAG_GET(list_tests)) {\n    // This must be called *after* FilterTests() has been called.\n    ListTestsMatchingFilter();\n    return true;\n  }\n\n  random_seed_ = GetRandomSeedFromFlag(GTEST_FLAG_GET(random_seed));\n\n  // True if and only if at least one test has failed.\n  bool failed = false;\n\n  TestEventListener* repeater = listeners()-&gt;repeater();\n\n  start_timestamp_ = GetTimeInMillis();\n  repeater-&gt;OnTestProgramStart(*parent_);\n\n  // How many times to repeat the tests?  We don&#x27;t want to repeat them\n  // when we are inside the subprocess of a death test.\n  const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG_GET(repeat);\n\n  // Repeats forever if the repeat count is negative.\n  const bool gtest_repeat_forever = repeat &lt; 0;\n\n  // Should test environments be set up and torn down for each repeat, or only\n  // set up on the first and torn down on the last iteration? If there is no\n  // &quot;last&quot; iteration because the tests will repeat forever, always recreate the\n  // environments to avoid leaks in case one of the environments is using\n  // resources that are external to this process. Without this check there would\n  // be no way to clean up those external resources automatically.\n  const bool recreate_environments_when_repeating =\n      GTEST_FLAG_GET(recreate_environments_when_repeating) ||\n      gtest_repeat_forever;\n\n  for (int i = 0; gtest_repeat_forever || i != repeat; i++) {\n    // We want to preserve failures generated by ad-hoc test\n    // assertions executed before RUN_ALL_TESTS().\n    ClearNonAdHocTestResult();\n\n    Timer timer;\n\n    // Shuffles test suites and tests if requested.\n    if (has_tests_to_run &amp;&amp; GTEST_FLAG_GET(shuffle)) {\n      random()-&gt;Reseed(static_cast&lt;uint32_t&gt;(random_seed_));\n      // This should be done before calling OnTestIterationStart(),\n      // such that a test event listener can see the actual test order\n      // in the event.\n      ShuffleTests();\n    }\n\n    // Tells the unit test event listeners that the tests are about to start.\n    repeater-&gt;OnTestIterationStart(*parent_, i);\n\n    // Runs each test suite if there is at least one test to run.\n    if (has_tests_to_run) {\n      // Sets up all environments beforehand. If test environments aren&#x27;t\n      // recreated for each iteration, only do so on the first iteration.\n      if (i == 0 || recreate_environments_when_repeating) {\n        repeater-&gt;OnEnvironmentsSetUpStart(*parent_);\n        ForEach(environments_, SetUpEnvironment);\n        repeater-&gt;OnEnvironmentsSetUpEnd(*parent_);\n      }\n\n      // Runs the tests only if there was no fatal failure or skip triggered\n      // during global set-up.\n      if (Test::IsSkipped()) {\n        // Emit diagnostics when global set-up calls skip, as it will not be\n        // emitted by default.\n        TestResult&amp; test_result =\n            *internal::GetUnitTestImpl()-&gt;current_test_result();\n        for (int j = 0; j &lt; test_result.total_part_count(); ++j) {\n          const TestPartResult&amp; test_part_result =\n              test_result.GetTestPartResult(j);\n          if (test_part_result.type() == TestPartResult::kSkip) {\n            const std::string&amp; result = test_part_result.message();\n            printf(&quot;%s\\n&quot;, result.c_str());\n          }\n        }\n        fflush(stdout);\n      } else if (!Test::HasFatalFailure()) {\n        for (int test_index = 0; test_index &lt; total_test_suite_count();\n             test_index++) {\n          GetMutableSuiteCase(test_index)-&gt;Run();\n          if (GTEST_FLAG_GET(fail_fast) &amp;&amp;\n              GetMutableSuiteCase(test_index)-&gt;Failed()) {\n            for (int j = test_index + 1; j &lt; total_test_suite_count(); j++) {\n              GetMutableSuiteCase(j)-&gt;Skip();\n            }\n            break;\n          }\n        }\n      } else if (Test::HasFatalFailure()) {\n        // If there was a fatal failure during the global setup then we know we\n        // aren&#x27;t going to run any tests. Explicitly mark all of the tests as\n        // skipped to make this obvious in the output.\n        for (int test_index = 0; test_index &lt; total_test_suite_count();\n             test_index++) {\n          GetMutableSuiteCase(test_index)-&gt;Skip();\n        }\n      }\n\n      // Tears down all environments in reverse order afterwards. If test\n      // environments aren&#x27;t recreated for each iteration, only do so on the\n      // last iteration.\n      if (i == repeat - 1 || recreate_environments_when_repeating) {\n        repeater-&gt;OnEnvironmentsTearDownStart(*parent_);\n        std::for_each(environments_.rbegin(), environments_.rend(),\n                      TearDownEnvironment);\n        repeater-&gt;OnEnvironmentsTearDownEnd(*parent_);\n      }\n    }\n\n    elapsed_time_ = timer.Elapsed();\n\n    // Tells the unit test event listener that the tests have just finished.\n    repeater-&gt;OnTestIterationEnd(*parent_, i);\n\n    // Gets the result and clears it.\n    if (!Passed()) {\n      failed = true;\n    }\n\n    // Restores the original test order after the iteration.  This\n    // allows the user to quickly repro a failure that happens in the\n    // N-th iteration without repeating the first (N - 1) iterations.\n    // This is not enclosed in &quot;if (GTEST_FLAG(shuffle)) { ... }&quot;, in\n    // case the user somehow changes the value of the flag somewhere\n    // (it&#x27;s always safe to unshuffle the tests).\n    UnshuffleTests();\n\n    if (GTEST_FLAG_GET(shuffle)) {\n      // Picks a new random seed for each iteration.\n      random_seed_ = GetNextRandomSeed(random_seed_);\n    }\n  }\n\n  repeater-&gt;OnTestProgramEnd(*parent_);\n\n  if (!gtest_is_initialized_before_run_all_tests) {\n    ColoredPrintf(\n        GTestColor::kRed,\n        &quot;\\nIMPORTANT NOTICE - DO NOT IGNORE:\\n&quot;\n        &quot;This test program did NOT call &quot; GTEST_INIT_GOOGLE_TEST_NAME_\n        &quot;() before calling RUN_ALL_TESTS(). This is INVALID. Soon &quot; GTEST_NAME_\n        &quot; will start to enforce the valid usage. &quot;\n        &quot;Please fix it ASAP, or IT WILL START TO FAIL.\\n&quot;);  // NOLINT\n#if GTEST_FOR_GOOGLE_\n    ColoredPrintf(GTestColor::kRed,\n                  &quot;For more details, see http://wiki/Main/ValidGUnitMain.\\n&quot;);\n#endif  // GTEST_FOR_GOOGLE_\n  }\n\n  return !failed;\n}\n\n// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file\n// if the variable is present. If a file already exists at this location, this\n// function will write over it. If the variable is present, but the file cannot\n// be created, prints an error and exits.\nvoid WriteToShardStatusFileIfNeeded() {\n  const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);\n  if (test_shard_file != nullptr) {\n    FILE* const file = posix::FOpen(test_shard_file, &quot;w&quot;);\n    if (file == nullptr) {\n      ColoredPrintf(GTestColor::kRed,\n                    &quot;Could not write to the test shard status file \\&quot;%s\\&quot; &quot;\n                    &quot;specified by the %s environment variable.\\n&quot;,\n                    test_shard_file, kTestShardStatusFile);\n      fflush(stdout);\n      exit(EXIT_FAILURE);\n    }\n    fclose(file);\n  }\n}\n\n// Checks whether sharding is enabled by examining the relevant\n// environment variable values. If the variables are present,\n// but inconsistent (i.e., shard_index &gt;= total_shards), prints\n// an error and exits. If in_subprocess_for_death_test, sharding is\n// disabled because it must only be applied to the original test\n// process. Otherwise, we could filter out death tests we intended to execute.\nbool ShouldShard(const char* total_shards_env, const char* shard_index_env,\n                 bool in_subprocess_for_death_test) {\n  if (in_subprocess_for_death_test) {\n    return false;\n  }\n\n  const int32_t total_shards = Int32FromEnvOrDie(total_shards_env, -1);\n  const int32_t shard_index = Int32FromEnvOrDie(shard_index_env, -1);\n\n  if (total_shards == -1 &amp;&amp; shard_index == -1) {\n    return false;\n  } else if (total_shards == -1 &amp;&amp; shard_index != -1) {\n    const Message msg = Message() &lt;&lt; &quot;Invalid environment variables: you have &quot;\n                                  &lt;&lt; kTestShardIndex &lt;&lt; &quot; = &quot; &lt;&lt; shard_index\n                                  &lt;&lt; &quot;, but have left &quot; &lt;&lt; kTestTotalShards\n                                  &lt;&lt; &quot; unset.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  } else if (total_shards != -1 &amp;&amp; shard_index == -1) {\n    const Message msg = Message()\n                        &lt;&lt; &quot;Invalid environment variables: you have &quot;\n                        &lt;&lt; kTestTotalShards &lt;&lt; &quot; = &quot; &lt;&lt; total_shards\n                        &lt;&lt; &quot;, but have left &quot; &lt;&lt; kTestShardIndex &lt;&lt; &quot; unset.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  } else if (shard_index &lt; 0 || shard_index &gt;= total_shards) {\n    const Message msg =\n        Message() &lt;&lt; &quot;Invalid environment variables: we require 0 &lt;= &quot;\n                  &lt;&lt; kTestShardIndex &lt;&lt; &quot; &lt; &quot; &lt;&lt; kTestTotalShards\n                  &lt;&lt; &quot;, but you have &quot; &lt;&lt; kTestShardIndex &lt;&lt; &quot;=&quot; &lt;&lt; shard_index\n                  &lt;&lt; &quot;, &quot; &lt;&lt; kTestTotalShards &lt;&lt; &quot;=&quot; &lt;&lt; total_shards &lt;&lt; &quot;.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  }\n\n  return total_shards &gt; 1;\n}\n\n// Parses the environment variable var as an Int32. If it is unset,\n// returns default_val. If it is not an Int32, prints an error\n// and aborts.\nint32_t Int32FromEnvOrDie(const char* var, int32_t default_val) {\n  const char* str_val = posix::GetEnv(var);\n  if (str_val == nullptr) {\n    return default_val;\n  }\n\n  int32_t result;\n  if (!ParseInt32(Message() &lt;&lt; &quot;The value of environment variable &quot; &lt;&lt; var,\n                  str_val, &amp;result)) {\n    exit(EXIT_FAILURE);\n  }\n  return result;\n}\n\n// Given the total number of shards, the shard index, and the test id,\n// returns true if and only if the test should be run on this shard. The test id\n// is some arbitrary but unique non-negative integer assigned to each test\n// method. Assumes that 0 &lt;= shard_index &lt; total_shards.\nbool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {\n  return (test_id % total_shards) == shard_index;\n}\n\n// Compares the name of each test with the user-specified filter to\n// decide whether the test should be run, then records the result in\n// each TestSuite and TestInfo object.\n// If shard_tests == true, further filters tests based on sharding\n// variables in the environment - see\n// https://github.com/google/googletest/blob/master/googletest/docs/advanced.md\n// . Returns the number of tests that should run.\nint UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {\n  const int32_t total_shards = shard_tests == HONOR_SHARDING_PROTOCOL\n                                   ? Int32FromEnvOrDie(kTestTotalShards, -1)\n                                   : -1;\n  const int32_t shard_index = shard_tests == HONOR_SHARDING_PROTOCOL\n                                  ? Int32FromEnvOrDie(kTestShardIndex, -1)\n                                  : -1;\n\n  const PositiveAndNegativeUnitTestFilter gtest_flag_filter(\n      GTEST_FLAG_GET(filter));\n  const UnitTestFilter disable_test_filter(kDisableTestFilter);\n  // num_runnable_tests are the number of tests that will\n  // run across all shards (i.e., match filter and are not disabled).\n  // num_selected_tests are the number of tests to be run on\n  // this shard.\n  int num_runnable_tests = 0;\n  int num_selected_tests = 0;\n  for (auto* test_suite : test_suites_) {\n    const std::string&amp; test_suite_name = test_suite-&gt;name();\n    test_suite-&gt;set_should_run(false);\n\n    for (size_t j = 0; j &lt; test_suite-&gt;test_info_list().size(); j++) {\n      TestInfo* const test_info = test_suite-&gt;test_info_list()[j];\n      const std::string test_name(test_info-&gt;name());\n      // A test is disabled if test suite name or test name matches\n      // kDisableTestFilter.\n      const bool is_disabled =\n          disable_test_filter.MatchesName(test_suite_name) ||\n          disable_test_filter.MatchesName(test_name);\n      test_info-&gt;is_disabled_ = is_disabled;\n\n      const bool matches_filter =\n          gtest_flag_filter.MatchesTest(test_suite_name, test_name);\n      test_info-&gt;matches_filter_ = matches_filter;\n\n      const bool is_runnable =\n          (GTEST_FLAG_GET(also_run_disabled_tests) || !is_disabled) &amp;&amp;\n          matches_filter;\n\n      const bool is_in_another_shard =\n          shard_tests != IGNORE_SHARDING_PROTOCOL &amp;&amp;\n          !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests);\n      test_info-&gt;is_in_another_shard_ = is_in_another_shard;\n      const bool is_selected = is_runnable &amp;&amp; !is_in_another_shard;\n\n      num_runnable_tests += is_runnable;\n      num_selected_tests += is_selected;\n\n      test_info-&gt;should_run_ = is_selected;\n      test_suite-&gt;set_should_run(test_suite-&gt;should_run() || is_selected);\n    }\n  }\n  return num_selected_tests;\n}\n\n// Prints the given C-string on a single line by replacing all &#x27;\\n&#x27;\n// characters with string &quot;\\\\n&quot;.  If the output takes more than\n// max_length characters, only prints the first max_length characters\n// and &quot;...&quot;.\nstatic void PrintOnOneLine(const char* str, int max_length) {\n  if (str != nullptr) {\n    for (int i = 0; *str != &#x27;\\0&#x27;; ++str) {\n      if (i &gt;= max_length) {\n        printf(&quot;...&quot;);\n        break;\n      }\n      if (*str == &#x27;\\n&#x27;) {\n        printf(&quot;\\\\n&quot;);\n        i += 2;\n      } else {\n        printf(&quot;%c&quot;, *str);\n        ++i;\n      }\n    }\n  }\n}\n\n// Prints the names of the tests matching the user-specified filter flag.\nvoid UnitTestImpl::ListTestsMatchingFilter() {\n  // Print at most this many characters for each type/value parameter.\n  const int kMaxParamLength = 250;\n\n  for (auto* test_suite : test_suites_) {\n    bool printed_test_suite_name = false;\n\n    for (size_t j = 0; j &lt; test_suite-&gt;test_info_list().size(); j++) {\n      const TestInfo* const test_info = test_suite-&gt;test_info_list()[j];\n      if (test_info-&gt;matches_filter_) {\n        if (!printed_test_suite_name) {\n          printed_test_suite_name = true;\n          printf(&quot;%s.&quot;, test_suite-&gt;name());\n          if (test_suite-&gt;type_param() != nullptr) {\n            printf(&quot;  # %s = &quot;, kTypeParamLabel);\n            // We print the type parameter on a single line to make\n            // the output easy to parse by a program.\n            PrintOnOneLine(test_suite-&gt;type_param(), kMaxParamLength);\n          }\n          printf(&quot;\\n&quot;);\n        }\n        printf(&quot;  %s&quot;, test_info-&gt;name());\n        if (test_info-&gt;value_param() != nullptr) {\n          printf(&quot;  # %s = &quot;, kValueParamLabel);\n          // We print the value parameter on a single line to make the\n          // output easy to parse by a program.\n          PrintOnOneLine(test_info-&gt;value_param(), kMaxParamLength);\n        }\n        printf(&quot;\\n&quot;);\n      }\n    }\n  }\n  fflush(stdout);\n  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();\n  if (output_format == &quot;xml&quot; || output_format == &quot;json&quot;) {\n    FILE* fileout = OpenFileForWriting(\n        UnitTestOptions::GetAbsolutePathToOutputFile().c_str());\n    std::stringstream stream;\n    if (output_format == &quot;xml&quot;) {\n      XmlUnitTestResultPrinter(\n          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())\n          .PrintXmlTestsList(&amp;stream, test_suites_);\n    } else if (output_format == &quot;json&quot;) {\n      JsonUnitTestResultPrinter(\n          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())\n          .PrintJsonTestList(&amp;stream, test_suites_);\n    }\n    fprintf(fileout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n    fclose(fileout);\n  }\n}\n\n// Sets the OS stack trace getter.\n//\n// Does nothing if the input and the current OS stack trace getter are\n// the same; otherwise, deletes the old getter and makes the input the\n// current getter.\nvoid UnitTestImpl::set_os_stack_trace_getter(\n    OsStackTraceGetterInterface* getter) {\n  if (os_stack_trace_getter_ != getter) {\n    delete os_stack_trace_getter_;\n    os_stack_trace_getter_ = getter;\n  }\n}\n\n// Returns the current OS stack trace getter if it is not NULL;\n// otherwise, creates an OsStackTraceGetter, makes it the current\n// getter, and returns it.\nOsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {\n  if (os_stack_trace_getter_ == nullptr) {\n#ifdef GTEST_OS_STACK_TRACE_GETTER_\n    os_stack_trace_getter_ = new GTEST_OS_STACK_TRACE_GETTER_;\n#else\n    os_stack_trace_getter_ = new OsStackTraceGetter;\n#endif  // GTEST_OS_STACK_TRACE_GETTER_\n  }\n\n  return os_stack_trace_getter_;\n}\n\n// Returns the most specific TestResult currently running.\nTestResult* UnitTestImpl::current_test_result() {\n  if (current_test_info_ != nullptr) {\n    return &amp;current_test_info_-&gt;result_;\n  }\n  if (current_test_suite_ != nullptr) {\n    return &amp;current_test_suite_-&gt;ad_hoc_test_result_;\n  }\n  return &amp;ad_hoc_test_result_;\n}\n\n// Shuffles all test suites, and the tests within each test suite,\n// making sure that death tests are still run first.\nvoid UnitTestImpl::ShuffleTests() {\n  // Shuffles the death test suites.\n  ShuffleRange(random(), 0, last_death_test_suite_ + 1, &amp;test_suite_indices_);\n\n  // Shuffles the non-death test suites.\n  ShuffleRange(random(), last_death_test_suite_ + 1,\n               static_cast&lt;int&gt;(test_suites_.size()), &amp;test_suite_indices_);\n\n  // Shuffles the tests inside each test suite.\n  for (auto&amp; test_suite : test_suites_) {\n    test_suite-&gt;ShuffleTests(random());\n  }\n}\n\n// Restores the test suites and tests to their order before the first shuffle.\nvoid UnitTestImpl::UnshuffleTests() {\n  for (size_t i = 0; i &lt; test_suites_.size(); i++) {\n    // Unshuffles the tests in each test suite.\n    test_suites_[i]-&gt;UnshuffleTests();\n    // Resets the index of each test suite.\n    test_suite_indices_[i] = static_cast&lt;int&gt;(i);\n  }\n}\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won&#x27;t.\nGTEST_NO_INLINE_ GTEST_NO_TAIL_CALL_ std::string\nGetCurrentOsStackTraceExceptTop(UnitTest* /*unit_test*/, int skip_count) {\n  // We pass skip_count + 1 to skip this wrapper function in addition\n  // to what the user really wants to skip.\n  return GetUnitTestImpl()-&gt;CurrentOsStackTraceExceptTop(skip_count + 1);\n}\n\n// Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to\n// suppress unreachable code warnings.\nnamespace {\nclass ClassUniqueToAlwaysTrue {};\n}  // namespace\n\nbool IsTrue(bool condition) { return condition; }\n\nbool AlwaysTrue() {\n#if GTEST_HAS_EXCEPTIONS\n  // This condition is always false so AlwaysTrue() never actually throws,\n  // but it makes the compiler think that it may throw.\n  if (IsTrue(false)) throw ClassUniqueToAlwaysTrue();\n#endif  // GTEST_HAS_EXCEPTIONS\n  return true;\n}\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nbool SkipPrefix(const char* prefix, const char** pstr) {\n  const size_t prefix_len = strlen(prefix);\n  if (strncmp(*pstr, prefix, prefix_len) == 0) {\n    *pstr += prefix_len;\n    return true;\n  }\n  return false;\n}\n\n// Parses a string as a command line flag.  The string should have\n// the format &quot;--flag=value&quot;.  When def_optional is true, the &quot;=value&quot;\n// part can be omitted.\n//\n// Returns the value of the flag, or NULL if the parsing failed.\nstatic const char* ParseFlagValue(const char* str, const char* flag_name,\n                                  bool def_optional) {\n  // str and flag must not be NULL.\n  if (str == nullptr || flag_name == nullptr) return nullptr;\n\n  // The flag must start with &quot;--&quot; followed by GTEST_FLAG_PREFIX_.\n  const std::string flag_str =\n      std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ + flag_name;\n  const size_t flag_len = flag_str.length();\n  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;\n\n  // Skips the flag name.\n  const char* flag_end = str + flag_len;\n\n  // When def_optional is true, it&#x27;s OK to not have a &quot;=value&quot; part.\n  if (def_optional &amp;&amp; (flag_end[0] == &#x27;\\0&#x27;)) {\n    return flag_end;\n  }\n\n  // If def_optional is true and there are more characters after the\n  // flag name, or if def_optional is false, there must be a &#x27;=&#x27; after\n  // the flag name.\n  if (flag_end[0] != &#x27;=&#x27;) return nullptr;\n\n  // Returns the string after &quot;=&quot;.\n  return flag_end + 1;\n}\n\n// Parses a string for a bool flag, in the form of either\n// &quot;--flag=value&quot; or &quot;--flag&quot;.\n//\n// In the former case, the value is taken as true as long as it does\n// not start with &#x27;0&#x27;, &#x27;f&#x27;, or &#x27;F&#x27;.\n//\n// In the latter case, the value is taken as true.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\nstatic bool ParseFlag(const char* str, const char* flag_name, bool* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, true);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Converts the string value to a bool.\n  *value = !(*value_str == &#x27;0&#x27; || *value_str == &#x27;f&#x27; || *value_str == &#x27;F&#x27;);\n  return true;\n}\n\n// Parses a string for an int32_t flag, in the form of &quot;--flag=value&quot;.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\nbool ParseFlag(const char* str, const char* flag_name, int32_t* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, false);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Sets *value to the value of the flag.\n  return ParseInt32(Message() &lt;&lt; &quot;The value of flag --&quot; &lt;&lt; flag_name, value_str,\n                    value);\n}\n\n// Parses a string for a string flag, in the form of &quot;--flag=value&quot;.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\ntemplate &lt;typename String&gt;\nstatic bool ParseFlag(const char* str, const char* flag_name, String* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, false);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Sets *value to the value of the flag.\n  *value = value_str;\n  return true;\n}\n\n// Determines whether a string has a prefix that Google Test uses for its\n// flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.\n// If Google Test detects that a command line flag has its prefix but is not\n// recognized, it will print its help message. Flags starting with\n// GTEST_INTERNAL_PREFIX_ followed by &quot;internal_&quot; are considered Google Test\n// internal flags and do not trigger the help message.\nstatic bool HasGoogleTestFlagPrefix(const char* str) {\n  return (SkipPrefix(&quot;--&quot;, &amp;str) || SkipPrefix(&quot;-&quot;, &amp;str) ||\n          SkipPrefix(&quot;/&quot;, &amp;str)) &amp;&amp;\n         !SkipPrefix(GTEST_FLAG_PREFIX_ &quot;internal_&quot;, &amp;str) &amp;&amp;\n         (SkipPrefix(GTEST_FLAG_PREFIX_, &amp;str) ||\n          SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &amp;str));\n}\n\n// Prints a string containing code-encoded text.  The following escape\n// sequences can be used in the string to control the text color:\n//\n//   @@    prints a single &#x27;@&#x27; character.\n//   @R    changes the color to red.\n//   @G    changes the color to green.\n//   @Y    changes the color to yellow.\n//   @D    changes to the default terminal text color.\n//\nstatic void PrintColorEncoded(const char* str) {\n  GTestColor color = GTestColor::kDefault;  // The current color.\n\n  // Conceptually, we split the string into segments divided by escape\n  // sequences.  Then we print one segment at a time.  At the end of\n  // each iteration, the str pointer advances to the beginning of the\n  // next segment.\n  for (;;) {\n    const char* p = strchr(str, &#x27;@&#x27;);\n    if (p == nullptr) {\n      ColoredPrintf(color, &quot;%s&quot;, str);\n      return;\n    }\n\n    ColoredPrintf(color, &quot;%s&quot;, std::string(str, p).c_str());\n\n    const char ch = p[1];\n    str = p + 2;\n    if (ch == &#x27;@&#x27;) {\n      ColoredPrintf(color, &quot;@&quot;);\n    } else if (ch == &#x27;D&#x27;) {\n      color = GTestColor::kDefault;\n    } else if (ch == &#x27;R&#x27;) {\n      color = GTestColor::kRed;\n    } else if (ch == &#x27;G&#x27;) {\n      color = GTestColor::kGreen;\n    } else if (ch == &#x27;Y&#x27;) {\n      color = GTestColor::kYellow;\n    } else {\n      --str;\n    }\n  }\n}\n\nstatic const char kColorEncodedHelpMessage[] =\n    &quot;This program contains tests written using &quot; GTEST_NAME_\n    &quot;. You can use the\\n&quot;\n    &quot;following command line flags to control its behavior:\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Selection:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;list_tests@D\\n&quot;\n    &quot;      List the names of all tests instead of running them. The name of\\n&quot;\n    &quot;      TEST(Foo, Bar) is \\&quot;Foo.Bar\\&quot;.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;filter=@YPOSITIVE_PATTERNS&quot;\n    &quot;[@G-@YNEGATIVE_PATTERNS]@D\\n&quot;\n    &quot;      Run only the tests whose name matches one of the positive patterns &quot;\n    &quot;but\\n&quot;\n    &quot;      none of the negative patterns. &#x27;?&#x27; matches any single character; &quot;\n    &quot;&#x27;*&#x27;\\n&quot;\n    &quot;      matches any substring; &#x27;:&#x27; separates two patterns.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;also_run_disabled_tests@D\\n&quot;\n    &quot;      Run all disabled tests too.\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Execution:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;repeat=@Y[COUNT]@D\\n&quot;\n    &quot;      Run the tests repeatedly; use a negative count to repeat forever.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;shuffle@D\\n&quot;\n    &quot;      Randomize tests&#x27; orders on every iteration.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;random_seed=@Y[NUMBER]@D\\n&quot;\n    &quot;      Random number seed to use for shuffling test orders (between 1 and\\n&quot;\n    &quot;      99999, or 0 to use a seed based on the current time).\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;recreate_environments_when_repeating@D\\n&quot;\n    &quot;      Sets up and tears down the global test environment on each repeat\\n&quot;\n    &quot;      of the test.\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Output:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\\n&quot;\n    &quot;      Enable/disable colored output. The default is @Gauto@D.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;brief=1@D\\n&quot;\n    &quot;      Only print test failures.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;print_time=0@D\\n&quot;\n    &quot;      Don&#x27;t print the elapsed time of each test.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G&quot; GTEST_PATH_SEP_\n    &quot;@Y|@G:@YFILE_PATH]@D\\n&quot;\n    &quot;      Generate a JSON or XML report in the given directory or with the &quot;\n    &quot;given\\n&quot;\n    &quot;      file name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\\n&quot;\n#if GTEST_CAN_STREAM_RESULTS_\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;stream_result_to=@YHOST@G:@YPORT@D\\n&quot;\n    &quot;      Stream test results to the given server.\\n&quot;\n#endif  // GTEST_CAN_STREAM_RESULTS_\n    &quot;\\n&quot;\n    &quot;Assertion Behavior:\\n&quot;\n#if GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\\n&quot;\n    &quot;      Set the default death test style.\\n&quot;\n#endif  // GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;break_on_failure@D\\n&quot;\n    &quot;      Turn assertion failures into debugger break-points.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;throw_on_failure@D\\n&quot;\n    &quot;      Turn assertion failures into C++ exceptions for use by an external\\n&quot;\n    &quot;      test framework.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;catch_exceptions=0@D\\n&quot;\n    &quot;      Do not report exceptions as test failures. Instead, allow them\\n&quot;\n    &quot;      to crash the program or throw a pop-up (on Windows).\\n&quot;\n    &quot;\\n&quot;\n    &quot;Except for @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;list_tests@D, you can alternatively set &quot;\n    &quot;the corresponding\\n&quot;\n    &quot;environment variable of a flag (all letters in upper-case). For example, &quot;\n    &quot;to\\n&quot;\n    &quot;disable colored text output, you can either specify &quot;\n    &quot;@G--&quot; GTEST_FLAG_PREFIX_\n    &quot;color=no@D or set\\n&quot;\n    &quot;the @G&quot; GTEST_FLAG_PREFIX_UPPER_\n    &quot;COLOR@D environment variable to @Gno@D.\\n&quot;\n    &quot;\\n&quot;\n    &quot;For more information, please read the &quot; GTEST_NAME_\n    &quot; documentation at\\n&quot;\n    &quot;@G&quot; GTEST_PROJECT_URL_ &quot;@D. If you find a bug in &quot; GTEST_NAME_\n    &quot;\\n&quot;\n    &quot;(not one in your own code or tests), please report it to\\n&quot;\n    &quot;@G&lt;&quot; GTEST_DEV_EMAIL_ &quot;&gt;@D.\\n&quot;;\n\nstatic bool ParseGoogleTestFlag(const char* const arg) {\n#define GTEST_INTERNAL_PARSE_FLAG(flag_name)  \\\n  do {                                        \\\n    auto value = GTEST_FLAG_GET(flag_name);   \\\n    if (ParseFlag(arg, #flag_name, &amp;value)) { \\\n      GTEST_FLAG_SET(flag_name, value);       \\\n      return true;                            \\\n    }                                         \\\n  } while (false)\n\n  GTEST_INTERNAL_PARSE_FLAG(also_run_disabled_tests);\n  GTEST_INTERNAL_PARSE_FLAG(break_on_failure);\n  GTEST_INTERNAL_PARSE_FLAG(catch_exceptions);\n  GTEST_INTERNAL_PARSE_FLAG(color);\n  GTEST_INTERNAL_PARSE_FLAG(death_test_style);\n  GTEST_INTERNAL_PARSE_FLAG(death_test_use_fork);\n  GTEST_INTERNAL_PARSE_FLAG(fail_fast);\n  GTEST_INTERNAL_PARSE_FLAG(filter);\n  GTEST_INTERNAL_PARSE_FLAG(internal_run_death_test);\n  GTEST_INTERNAL_PARSE_FLAG(list_tests);\n  GTEST_INTERNAL_PARSE_FLAG(output);\n  GTEST_INTERNAL_PARSE_FLAG(brief);\n  GTEST_INTERNAL_PARSE_FLAG(print_time);\n  GTEST_INTERNAL_PARSE_FLAG(print_utf8);\n  GTEST_INTERNAL_PARSE_FLAG(random_seed);\n  GTEST_INTERNAL_PARSE_FLAG(repeat);\n  GTEST_INTERNAL_PARSE_FLAG(recreate_environments_when_repeating);\n  GTEST_INTERNAL_PARSE_FLAG(shuffle);\n  GTEST_INTERNAL_PARSE_FLAG(stack_trace_depth);\n  GTEST_INTERNAL_PARSE_FLAG(stream_result_to);\n  GTEST_INTERNAL_PARSE_FLAG(throw_on_failure);\n  return false;\n}\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\nstatic void LoadFlagsFromFile(const std::string&amp; path) {\n  FILE* flagfile = posix::FOpen(path.c_str(), &quot;r&quot;);\n  if (!flagfile) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Unable to open file \\&quot;&quot; &lt;&lt; GTEST_FLAG_GET(flagfile)\n                      &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  std::string contents(ReadEntireFile(flagfile));\n  posix::FClose(flagfile);\n  std::vector&lt;std::string&gt; lines;\n  SplitString(contents, &#x27;\\n&#x27;, &amp;lines);\n  for (size_t i = 0; i &lt; lines.size(); ++i) {\n    if (lines[i].empty()) continue;\n    if (!ParseGoogleTestFlag(lines[i].c_str())) g_help_flag = true;\n  }\n}\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n\n// Parses the command line for Google Test flags, without initializing\n// other parts of Google Test.  The type parameter CharType can be\n// instantiated to either char or wchar_t.\ntemplate &lt;typename CharType&gt;\nvoid ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {\n  std::string flagfile_value;\n  for (int i = 1; i &lt; *argc; i++) {\n    const std::string arg_string = StreamableToString(argv[i]);\n    const char* const arg = arg_string.c_str();\n\n    using internal::ParseFlag;\n\n    bool remove_flag = false;\n    if (ParseGoogleTestFlag(arg)) {\n      remove_flag = true;\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\n    } else if (ParseFlag(arg, &quot;flagfile&quot;, &amp;flagfile_value)) {\n      GTEST_FLAG_SET(flagfile, flagfile_value);\n      LoadFlagsFromFile(flagfile_value);\n      remove_flag = true;\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n    } else if (arg_string == &quot;--help&quot; || HasGoogleTestFlagPrefix(arg)) {\n      // Both help flag and unrecognized Google Test flags (excluding\n      // internal ones) trigger help display.\n      g_help_flag = true;\n    }\n\n    if (remove_flag) {\n      // Shift the remainder of the argv list left by one.  Note\n      // that argv has (*argc + 1) elements, the last one always being\n      // NULL.  The following loop moves the trailing NULL element as\n      // well.\n      for (int j = i; j != *argc; j++) {\n        argv[j] = argv[j + 1];\n      }\n\n      // Decrements the argument count.\n      (*argc)--;\n\n      // We also need to decrement the iterator as we just removed\n      // an element.\n      i--;\n    }\n  }\n\n  if (g_help_flag) {\n    // We print the help here instead of in RUN_ALL_TESTS(), as the\n    // latter may not be called at all if the user is using Google\n    // Test with another testing framework.\n    PrintColorEncoded(kColorEncodedHelpMessage);\n  }\n}\n\n// Parses the command line for Google Test flags, without initializing\n// other parts of Google Test.\nvoid ParseGoogleTestFlagsOnly(int* argc, char** argv) {\n#if GTEST_HAS_ABSL\n  if (*argc &gt; 0) {\n    // absl::ParseCommandLine() requires *argc &gt; 0.\n    auto positional_args = absl::flags_internal::ParseCommandLineImpl(\n        *argc, argv, absl::flags_internal::ArgvListAction::kRemoveParsedArgs,\n        absl::flags_internal::UsageFlagsAction::kHandleUsage,\n        absl::flags_internal::OnUndefinedFlag::kReportUndefined);\n    // Any command-line positional arguments not part of any command-line flag\n    // (or arguments to a flag) are copied back out to argv, with the program\n    // invocation name at position 0, and argc is resized. This includes\n    // positional arguments after the flag-terminating delimiter &#x27;--&#x27;.\n    // See https://abseil.io/docs/cpp/guides/flags.\n    std::copy(positional_args.begin(), positional_args.end(), argv);\n    if (static_cast&lt;int&gt;(positional_args.size()) &lt; *argc) {\n      argv[positional_args.size()] = nullptr;\n      *argc = static_cast&lt;int&gt;(positional_args.size());\n    }\n  }\n#else\n  ParseGoogleTestFlagsOnlyImpl(argc, argv);\n#endif\n\n  // Fix the value of *_NSGetArgc() on macOS, but if and only if\n  // *_NSGetArgv() == argv\n  // Only applicable to char** version of argv\n#if GTEST_OS_MAC\n#ifndef GTEST_OS_IOS\n  if (*_NSGetArgv() == argv) {\n    *_NSGetArgc() = *argc;\n  }\n#endif\n#endif\n}\nvoid ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {\n  ParseGoogleTestFlagsOnlyImpl(argc, argv);\n}\n\n// The internal implementation of InitGoogleTest().\n//\n// The type parameter CharType can be instantiated to either char or\n// wchar_t.\ntemplate &lt;typename CharType&gt;\nvoid InitGoogleTestImpl(int* argc, CharType** argv) {\n  // We don&#x27;t want to run the initialization code twice.\n  if (GTestIsInitialized()) return;\n\n  if (*argc &lt;= 0) return;\n\n  g_argvs.clear();\n  for (int i = 0; i != *argc; i++) {\n    g_argvs.push_back(StreamableToString(argv[i]));\n  }\n\n#if GTEST_HAS_ABSL\n  absl::InitializeSymbolizer(g_argvs[0].c_str());\n\n  // When using the Abseil Flags library, set the program usage message to the\n  // help message, but remove the color-encoding from the message first.\n  absl::SetProgramUsageMessage(absl::StrReplaceAll(\n      kColorEncodedHelpMessage,\n      {{&quot;@D&quot;, &quot;&quot;}, {&quot;@R&quot;, &quot;&quot;}, {&quot;@G&quot;, &quot;&quot;}, {&quot;@Y&quot;, &quot;&quot;}, {&quot;@@&quot;, &quot;@&quot;}}));\n#endif  // GTEST_HAS_ABSL\n\n  ParseGoogleTestFlagsOnly(argc, argv);\n  GetUnitTestImpl()-&gt;PostFlagParsingInit();\n}\n\n}  // namespace internal\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nvoid InitGoogleTest(int* argc, char** argv) {\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nvoid InitGoogleTest(int* argc, wchar_t** argv) {\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n// This overloaded version can be used on Arduino/embedded platforms where\n// there is no argc/argv.\nvoid InitGoogleTest() {\n  // Since Arduino doesn&#x27;t have a command line, fake out the argc/argv arguments\n  int argc = 1;\n  const auto arg0 = &quot;dummy&quot;;\n  char* argv0 = const_cast&lt;char*&gt;(arg0);\n  char** argv = &amp;argv0;\n\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(&amp;argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(&amp;argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n#if !defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)\n// Return value of first environment variable that is set and contains\n// a non-empty string. If there are none, return the &quot;fallback&quot; string.\n// Since we like the temporary directory to have a directory separator suffix,\n// add it if not provided in the environment variable value.\nstatic std::string GetTempDirFromEnv(\n    std::initializer_list&lt;const char*&gt; environment_variables,\n    const char* fallback, char separator) {\n  for (const char* variable_name : environment_variables) {\n    const char* value = internal::posix::GetEnv(variable_name);\n    if (value != nullptr &amp;&amp; value[0] != &#x27;\\0&#x27;) {\n      if (value[strlen(value) - 1] != separator) {\n        return std::string(value).append(1, separator);\n      }\n      return value;\n    }\n  }\n  return fallback;\n}\n#endif\n\nstd::string TempDir() {\n#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)\n  return GTEST_CUSTOM_TEMPDIR_FUNCTION_();\n#elif GTEST_OS_WINDOWS || GTEST_OS_WINDOWS_MOBILE\n  return GetTempDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TEMP&quot;}, &quot;\\\\temp\\\\&quot;, &#x27;\\\\&#x27;);\n#elif GTEST_OS_LINUX_ANDROID\n  return GetTempDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TMPDIR&quot;}, &quot;/data/local/tmp/&quot;, &#x27;/&#x27;);\n#else\n  return GetTempDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TMPDIR&quot;}, &quot;/tmp/&quot;, &#x27;/&#x27;);\n#endif\n}\n\n// Class ScopedTrace\n\n// Pushes the given source file location and message onto a per-thread\n// trace stack maintained by Google Test.\nvoid ScopedTrace::PushTrace(const char* file, int line, std::string message) {\n  internal::TraceInfo trace;\n  trace.file = file;\n  trace.line = line;\n  trace.message.swap(message);\n\n  UnitTest::GetInstance()-&gt;PushGTestTrace(trace);\n}\n\n// Pops the info pushed by the c&#x27;tor.\nScopedTrace::~ScopedTrace() GTEST_LOCK_EXCLUDED_(&amp;UnitTest::mutex_) {\n  UnitTest::GetInstance()-&gt;PopGTestTrace();\n}\n\n}  // namespace testing\n"}}, "reports": [{"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "reportHash": "4fbf56876b5fbc53c09432d358d677cf", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "checker": {"name": "performance-noexcept-swap", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-swap.html"}, "analyzerName": "clang-tidy", "line": 212, "column": 8, "message": "swap functions should be marked noexcept", "events": [{"message": "swap functions should be marked noexcept", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "line": 212, "column": 8}], "macros": [], "notes": [{"message": "noexcept  (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h", "line": 212, "column": 37}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "35ffd59c8fd1485608d2d153ac7bc95f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 264, "column": 7, "message": "destructor of 'MatcherBase<const std::basic_string<char> &>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}, {"message": "destructor of 'MatcherBase<const std::basic_string<char> &>' is protected and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "b19c88c2e02e95a6ec471ddeaf9e3eb6", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 264, "column": 7, "message": "destructor of 'MatcherBase<const std::basic_string_view<char> &>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}, {"message": "destructor of 'MatcherBase<const std::basic_string_view<char> &>' is protected and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "1eb34686ef8bafd95bf4427425893870", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 264, "column": 7, "message": "destructor of 'MatcherBase<std::basic_string<char>>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}, {"message": "destructor of 'MatcherBase<std::basic_string<char>>' is protected and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "8fa234cb9af70db7dbeb74940e45af43", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 264, "column": 7, "message": "destructor of 'MatcherBase<std::basic_string_view<char>>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}, {"message": "destructor of 'MatcherBase<std::basic_string_view<char>>' is protected and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 264, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "37d2b130b4cfd2a5559927c10b68a00e", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 335, "column": 3, "message": "move constructors should be marked noexcept", "events": [{"message": "move constructors should be marked noexcept", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 335, "column": 3}], "macros": [], "notes": [{"message": ": vtable_(other.vtable_), buffer_(other.buffer_) { (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 335, "column": 7}, {"message": "noexcept  (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 335, "column": 2}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "b4942153ff03a7289a4de3a2168de314", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 340, "column": 16, "message": "move assignment operators should be marked noexcept", "events": [{"message": "move assignment operators should be marked noexcept", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 340, "column": 16}], "macros": [], "notes": [{"message": "noexcept  (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 340, "column": 48}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "reportHash": "33105a639b49690cff91a67296624e2d", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "checker": {"name": "bugprone-sizeof-expression", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html"}, "analyzerName": "clang-tidy", "line": 433, "column": 12, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate", "events": [{"message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h", "line": 433, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "HIGH", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "reportHash": "9460180f021935b0f218e03d4812e000", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 1093, "column": 18, "message": "destructor of 'UnitTest' is private and prevents using the type", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "line": 1093, "column": 18}, {"message": "make it protected", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "line": 1093, "column": 18}, {"message": "destructor of 'UnitTest' is private and prevents using the type", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "line": 1093, "column": 18}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "reportHash": "4719eada12705e8e20a73dafcb832e93", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "checker": {"name": "misc-unconventional-assign-operator", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"}, "analyzerName": "clang-tidy", "line": 1588, "column": 3, "message": "operator=() should return 'AssertHelper&'", "events": [{"message": "operator=() should return 'AssertHelper&'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/gtest.h", "line": 1588, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "86507bd0541f768a1cacd34203a19d19", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 604, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 7}], "macros": [], "notes": [{"message": "\"%s Test %s must be defined before \" (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}, {"message": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}, {"message": "\"REGISTER_TYPED_TEST_SUITE_P(%s, ...).\\n\", (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}, {"message": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}, {"message": "FormatFileLocation(file, line).c_str(), test_name, case_name); (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}, {"message": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 604, "column": 15}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "d2e096be0ebec9f67ae670c33187ffeb", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 608, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 608, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 608, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "9d6c58fae59147fca031b6c1c85a6296", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 785, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 7}], "macros": [], "notes": [{"message": "case_name, test_name.c_str(), (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 15}, {"message": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 15}, {"message": "FormatFileLocation(code_location.file.c_str(), code_location.line) (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 15}, {"message": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 15}, {"message": ".c_str()); (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 19}, {"message": "~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 785, "column": 19}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "d2e096be0ebec9f67ae670c33187ffeb", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 789, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 789, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 789, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "1c4176a968476513342f4ee98abfbf15", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "checker": {"name": "cert-dcl58-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl58-cpp.html"}, "analyzerName": "clang-tidy", "line": 1332, "column": 8, "message": "modification of 'std' namespace can result in undefined behavior", "events": [{"message": "'std' namespace opened here", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 1323, "column": 11}, {"message": "modification of 'std' namespace can result in undefined behavior", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h", "line": 1332, "column": 8}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "HIGH", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "reportHash": "0c89a506bba90cbd1aea245378575706", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 984, "column": 30, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 984, "column": 30}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 984, "column": 30}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "reportHash": "9975a8fe37957a4a78a591f900b3eb46", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 1935, "column": 10, "message": "comparison between 'signed char' and 'unsigned char'", "events": [{"message": "comparison between 'signed char' and 'unsigned char'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 1935, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "reportHash": "14d071dc2bf4b2e783137c37e265ad57", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "checker": {"name": "bugprone-inc-dec-in-conditions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/inc-dec-in-conditions.html"}, "analyzerName": "clang-tidy", "line": 1947, "column": 40, "message": "decrementing and referencing a variable in a complex condition can cause unintended side-effects due to C++'s order of evaluation, consider moving the modification outside of the condition to avoid misunderstandings", "events": [{"message": "variable is referenced here", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 1947, "column": 10}, {"message": "decrementing and referencing a variable in a complex condition can cause unintended side-effects due to C++'s order of evaluation, consider moving the modification outside of the condition to avoid misunderstandings", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 1947, "column": 40}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h", "reportHash": "4ff880da88d49b20daef86740bcfb435", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h", "checker": {"name": "clang-diagnostic-reserved-identifier", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wreserved-identifier"}, "analyzerName": "clang-tidy", "line": 78, "column": 14, "message": "identifier '__cxa_demangle' is reserved because it starts with '__'", "events": [{"message": "identifier '__cxa_demangle' is reserved because it starts with '__'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h", "line": 78, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "reportHash": "df3d6c413effdf96193e78428b28d62f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "checker": {"name": "performance-noexcept-swap", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-swap.html"}, "analyzerName": "clang-tidy", "line": 52, "column": 23, "message": "swap functions should be marked noexcept", "events": [{"message": "swap functions should be marked noexcept", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "line": 52, "column": 23}], "macros": [], "notes": [{"message": "noexcept  (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-assertion-result.cc", "line": 52, "column": 53}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "2d10f6325b2d2a64d898cd0fe8c5ab28", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 295, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 295, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 295, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "e4d097cc2e633a2fbdc0e4ac08fed681", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 296, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 296, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 296, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "563a16ffccbf63786420921f29fd01e6", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 297, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 297, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 297, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "dca96a25c723396fef84d4141f704641", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 300, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 300, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 300, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "2b30506a84a87cc0bb6783140b0f4ff2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 301, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 301, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 301, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "f7cd5f970ab45b94451773d4e72d8502", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 400, "column": 7, "message": "destructor of 'DeathTestImpl' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 400, "column": 7}, {"message": "destructor of 'DeathTestImpl' is protected and virtual", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 400, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "f7a2af38285f3ec9aa1356626a1a4f8e", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "readability-container-data-pointer", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-data-pointer.html"}, "analyzerName": "clang-tidy", "line": 1198, "column": 32, "message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "events": [{"message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 1198, "column": 32}], "macros": [], "notes": [{"message": "args_.data() (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 1198, "column": 32}], "reviewStatus": "Unreviewed", "severity": "STYLE", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "reportHash": "fcc9cc2737f4eb3931f895df8c7f7eca", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "checker": {"name": "bugprone-misplaced-widening-cast", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misplaced-widening-cast.html"}, "analyzerName": "clang-tidy", "line": 1341, "column": 29, "message": "either cast from 'int' to 'size_t' (aka 'unsigned long') is ineffective, or there is loss of precision before the conversion", "events": [{"message": "either cast from 'int' to 'size_t' (aka 'unsigned long') is ineffective, or there is loss of precision before the conversion", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-death-test.cc", "line": 1341, "column": 29}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "HIGH", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "066b4c6253ca4e8c4c3ff061d9f96ebc", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 700, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 700, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 700, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "6134e2f51d9a70add64241e9260cd186", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 1002, "column": 12, "message": "constness of 'file_name' prevents automatic move", "events": [{"message": "constness of 'file_name' prevents automatic move", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1002, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "5ab1b8c0631a64aec270190113cec01c", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1022, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1022, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1022, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "3138322617157b5f75b3c929ef053613", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1110, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1110, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1110, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "29a1fbc29a0b425a3ee765a9bcfe1f2e", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1115, "column": 23, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1115, "column": 23}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1115, "column": 23}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "16b95e09f254abfda0cf0423fc57b353", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1120, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1120, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1120, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "12cd323a8799bdd5a81da9e8d1cc8f04", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1203, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1203, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1203, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "2e7b68fe5651e9e9c28486b285e91b9b", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1214, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1214, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1214, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "b28a694c710a6d9a4b9a2ecf68730f3f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1297, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1297, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1297, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "b28a694c710a6d9a4b9a2ecf68730f3f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1314, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1314, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1314, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "reportHash": "b28a694c710a6d9a4b9a2ecf68730f3f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 1356, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1356, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-port.cc", "line": 1356, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "reportHash": "3a47c10ad373da0ceccf0afbc44d3adb", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 81, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "expanded from macro 'GTEST_SNPRINTF_'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 2120, "column": 25}, {"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "line": 81, "column": 5}, {"message": "expanded from macro 'GTEST_SNPRINTF_'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h", "line": 2120, "column": 25}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-printers.cc", "line": 81, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "reportHash": "747cfe04153b22d0a3da7404847da6b0", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 94, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 94, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 94, "column": 5}], "macros": [], "notes": [{"message": "errors_str.c_str()); (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 94, "column": 13}, {"message": "~~~~~~~~~~~~~~~~~~~ (fixit)", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 94, "column": 13}], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "reportHash": "7115a714cbebb18331c66ee87508b2b5", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 96, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 96, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest-typed-test.cc", "line": 96, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "f80c5bce29099fce32d463462be3b130", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "misc-unconventional-assign-operator", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"}, "analyzerName": "clang-tidy", "line": 435, "column": 1, "message": "operator=() should return 'AssertHelper&'", "events": [{"message": "operator=() should return 'AssertHelper&'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 435, "column": 1}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "843d485fe2cb8dc6dfd964e2dc23afc7", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "bugprone-switch-missing-default-case", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/switch-missing-default-case.html"}, "analyzerName": "clang-tidy", "line": 1374, "column": 5, "message": "switching on non-enum value without default case may not cover all cases", "events": [{"message": "switching on non-enum value without default case may not cover all cases", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 1374, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "d7184c9c70c627c5197f89b84286dac0", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 1990, "column": 46, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 1990, "column": 46}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "c26676b030dbe5cf2494c31821d66d8f", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 1991, "column": 47, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 1991, "column": 47}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "7ad8974e969ea676ada1282ec3a62fcf", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 2028, "column": 50, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 2028, "column": 50}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "9111c5c26bd8fc0720498c0bb9213b99", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 2201, "column": 12, "message": "constness of 'user_msg_string' prevents automatic move", "events": [{"message": "constness of 'user_msg_string' prevents automatic move", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 2201, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3151, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3151, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3151, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3417, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3417, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3417, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3424, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3424, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3424, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3438, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3438, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3438, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3460, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3460, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3460, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3467, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3467, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3467, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "81a01cf348adf676b5e5c311e5ee20e3", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3481, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3481, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3481, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3503, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3503, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3503, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3515, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3515, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3515, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3534, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3534, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3534, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3644, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3644, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3644, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "81a01cf348adf676b5e5c311e5ee20e3", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3699, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3699, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3699, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "85069a35f901218682261e4c57e13f4d", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3716, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3716, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3716, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3749, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3749, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3749, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "549a1b237784df2c8fca52387bc78977", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3996, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3996, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3996, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "029f269f1dcdddb8d845bdf5c2832948", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 3997, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3997, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 3997, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "549a1b237784df2c8fca52387bc78977", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 4005, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4005, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4005, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "029f269f1dcdddb8d845bdf5c2832948", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 4006, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4006, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4006, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "a0d65c5f1b0127394f61f0e194865205", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 4510, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4510, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4510, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "fa2334520ae2d68eff036d725914d308", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 4511, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4511, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 4511, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "672feeab72e2fc803729cea5a2687928", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5023, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5023, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5023, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "2efc49b4600a7d66c5ad1b8a39ebbe14", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5024, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5024, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5024, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "9631f3d62146b5dc203d2168bad9aa62", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5866, "column": 9, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5866, "column": 9}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5866, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "81a01cf348adf676b5e5c311e5ee20e3", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5956, "column": 7, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5956, "column": 7}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5956, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "81fb129d10b10527714b8ad5e23e4e78", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5959, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5959, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5959, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "85069a35f901218682261e4c57e13f4d", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5986, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5986, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5986, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "85069a35f901218682261e4c57e13f4d", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 5994, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5994, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 5994, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "85069a35f901218682261e4c57e13f4d", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 6003, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6003, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6003, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "8f3efab4a5f4cde3407291eda3abd1b2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 6152, "column": 3, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6152, "column": 3}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6152, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "cad26a725a09ded222bbf34143b2a3c2", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 6167, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6167, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6167, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "reportHash": "cfa5694f1bf78a3ae41d6a7786d40189", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "checker": {"name": "cert-err33-c", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"}, "analyzerName": "clang-tidy", "line": 6168, "column": 5, "message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "events": [{"message": "cast the expression to void to silence this warning", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6168, "column": 5}, {"message": "the value returned by this function should not be disregarded; neglecting it may lead to errors", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googletest/src/gtest.cc", "line": 6168, "column": 5}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
