<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(report.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
    // If there are no events, or the last event does not match
    // the main warning message we print the warning message as a separate
    // error node.
    var lastEvent = null
    if (currentEvents.length > 0)
      lastEvent =currentEvents[currentEvents.length - 1];
    if (!lastEvent ||
          lastEvent.message != this._currentReport.message ||
          lastEvent.line != this._currentReport.line){
        var element = document.createElement('div');
        var left = that._codeMirror.defaultCharWidth() * lastEvent.column + 'px';
        element.setAttribute('style', 'margin-left: ' + left);
        element.setAttribute('class', 'check-msg ' + "error");
        var error_tag = document.createElement('span');
        error_tag.setAttribute('class', 'checker-enum error');
        error_tag.innerHTML = "E";
        element.appendChild(error_tag);
        var msg = document.createElement('span');
        msg.innerHTML = that.escapeHTML(this._currentReport.message)
          .replace(/(?:\r\n|\r|\n)/g, '<br>');
        element.appendChild(msg);
        that._lineWidgets.push(that._codeMirror.addLineWidget(
          this._currentReport.line - 1, element));
      }
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h": {"id": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "filePath": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "content": "#ifndef SRC_EULER_BACKWARD_STEP_SOLVER\n#define SRC_EULER_BACKWARD_STEP_SOLVER\n\n\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include &lt;sstream&gt;\n#include &quot;IOdeStepSolver.h&quot;\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\nnamespace PySysLinkBase\n{\n    class EulerBackwardStepSolver : public IOdeStepSolver\n    {\n        public:\n            EulerBackwardStepSolver(double maximumIterations = 50, double tolerance = 1e-6) \n                : maximumIterations(maximumIterations), tolerance(tolerance)\n            {\n            };\n            virtual std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; system, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep)\n            {\n                throw std::runtime_error(&quot;Jacobian needed for implicit Euler method&quot;);\n            }\n            virtual std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; systemDerivatives,\n                                                                    std::function&lt;std::vector&lt;std::vector&lt;double&gt;&gt;(std::vector&lt;double&gt;, double)&gt; systemJacobian, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep);\n            virtual bool IsJacobianNeeded() const \n            {\n                return true;\n            }          \n        \n        private:\n            double maximumIterations;\n            double tolerance;\n            std::vector&lt;double&gt; ComputeNewtonStep(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; systemJacobianEnd,\n                const std::vector&lt;double&gt;&amp; systemDerivativesEnd, const std::vector&lt;double&gt;&amp; states_0, const std::vector&lt;double&gt;&amp; statesEnd,\n                 double timeStep);\n    };\n} // namespace PySysLinkBase\n\n#endif /* SRC_EULER_FORWARD_STEP_SOLVER */\n"}, "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h": {"id": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "filePath": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "content": "#ifndef SRC_EULER_FORWARD_STEP_SOLVER\n#define SRC_EULER_FORWARD_STEP_SOLVER\n\n\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include &quot;IOdeStepSolver.h&quot;\n\nnamespace PySysLinkBase\n{\n    class EulerForwardStepSolver : public IOdeStepSolver\n    {\n        public:\n            virtual std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; system, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep);\n            virtual bool IsJacobianNeeded() const \n            {\n                return false;\n            }\n            virtual std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; systemDerivatives,\n                                                                    std::function&lt;std::vector&lt;std::vector&lt;double&gt;&gt;(std::vector&lt;double&gt;, double)&gt; systemJacobian, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep)\n            {\n                throw std::runtime_error(&quot;Jacobian not needed&quot;);\n            }\n    };\n} // namespace PySysLinkBase\n\n#endif /* SRC_EULER_FORWARD_STEP_SOLVER */\n"}, "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h": {"id": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "filePath": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "content": "#ifndef SRC_CONTINUOUS_AND_ODE_ODEINT_IMPLICIT_STEP_SOLVER\n#define SRC_CONTINUOUS_AND_ODE_ODEINT_IMPLICIT_STEP_SOLVER\n\n\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include &quot;IOdeStepSolver.h&quot;\n#include &lt;boost/numeric/odeint.hpp&gt;\n#include &lt;utility&gt;\n#include &lt;boost/numeric/ublas/vector.hpp&gt;\n#include &lt;boost/numeric/ublas/io.hpp&gt;\n\nnamespace PySysLinkBase\n{\n    template &lt;typename T&gt; \n    class OdeintImplicitStepSolver : public IOdeStepSolver\n    {\n        private:\n            std::shared_ptr&lt;T&gt; controlledStepper;\n\n            // Convert std::vector&lt;double&gt; to ublas::vector&lt;double&gt;\n            static boost::numeric::ublas::vector&lt;double&gt; stdToUblas(const std::vector&lt;double&gt;&amp; v) {\n                boost::numeric::ublas::vector&lt;double&gt; u(v.size());\n                for (size_t i = 0; i &lt; v.size(); ++i) {\n                    u(i) = v[i];\n                }\n                return u;\n            }\n\n            // Convert ublas::vector&lt;double&gt; to std::vector&lt;double&gt;\n            static std::vector&lt;double&gt; ublasToStd(const boost::numeric::ublas::vector&lt;double&gt;&amp; u) {\n                std::vector&lt;double&gt; v(u.size());\n                for (size_t i = 0; i &lt; u.size(); ++i) {\n                    v[i] = u(i);\n                }\n                return v;\n            }\n\n            boost::numeric::ublas::matrix&lt;double&gt; stdToUblasMatrix(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; mat) {\n                size_t rows = mat.size();\n                size_t cols = (rows &gt; 0 ? mat[0].size() : 0);\n                boost::numeric::ublas::matrix&lt;double&gt; m(rows, cols);\n                for (size_t i = 0; i &lt; rows; ++i) {\n                    for (size_t j = 0; j &lt; cols; ++j) {\n                        m(i, j) = mat[i][j];\n                    }\n                }\n                return m;\n            }\n\n        public:\n            OdeintImplicitStepSolver(std::shared_ptr&lt;T&gt; controlledStepper)\n            {\n                this-&gt;controlledStepper = controlledStepper;\n            }\n\n            virtual bool IsJacobianNeeded() const \n            {\n                return true;\n            }\n\n            virtual std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; system, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep)\n            {\n                throw std::runtime_error(&quot;Jacobian needed for implicit odeint method&quot;);\n            }\n\n\n            \n\n            std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; system, \n                                                                    std::function&lt;std::vector&lt;std::vector&lt;double&gt;&gt;(std::vector&lt;double&gt;, double)&gt; systemJacobian, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep)\n            {\n                auto systemFunction = [&amp;](const boost::numeric::ublas::vector&lt;double&gt;&amp; x_ublas, boost::numeric::ublas::vector&lt;double&gt;&amp; dxdt_ublas, double t) -&gt; void {\n                    std::vector&lt;double&gt; x_std = OdeintImplicitStepSolver::ublasToStd(x_ublas);\n                    std::vector&lt;double&gt; dxdt_std = system(x_std, t);\n                    if(dxdt_std.size() != static_cast&lt;size_t&gt;(dxdt_ublas.size())) {\n                        dxdt_ublas = boost::numeric::ublas::vector&lt;double&gt;(dxdt_std.size());\n                    }\n                    for (size_t i = 0; i &lt; dxdt_std.size(); ++i) {\n                        dxdt_ublas(i) = dxdt_std[i];\n                    }\n                };\n                \n                auto systemJacobianFunction = [&amp;](const boost::numeric::ublas::vector&lt;double&gt;&amp; x,\n                    boost::numeric::ublas::matrix&lt;double&gt;&amp; J,\n                    double t,\n                    boost::numeric::ublas::vector&lt;double&gt;&amp; dfdt) -&gt; void {\n                    std::vector&lt;double&gt; x_std = OdeintImplicitStepSolver::ublasToStd(x);\n                    std::vector&lt;std::vector&lt;double&gt;&gt; J_std = systemJacobian(x_std, t);\n                    // Here you need to compute dfdt (the time derivative of f) or set it to zero if appropriate.\n                    // For example, if dfdt is not provided by your original function, you might choose:\n                    dfdt = boost::numeric::ublas::vector&lt;double&gt;(x_std.size(), 0.0);\n                    J = OdeintImplicitStepSolver::stdToUblasMatrix(J_std);\n                };\n                \n                typedef boost::numeric::ublas::vector&lt;double&gt; state_type;\n\n                // Assuming state_type is boost::numeric::ublas::vector&lt;double&gt;\n                std::function&lt;void(const state_type&amp;, state_type&amp;, double)&gt; boundSystem = systemFunction;\n                std::function&lt;void(const state_type&amp;, boost::numeric::ublas::matrix&lt;double&gt;&amp;, double, state_type&amp;)&gt; boundJacobian = systemJacobianFunction;\n\n                // Create the stepper\n                // Stepper stepper;\n\n                // Integrate a single step\n                std::vector&lt;double&gt; newStates = states_0; // Initial state\n                double dt = timeStep;\n\n                boost::numeric::ublas::vector&lt;double&gt; newStates_ublas(newStates.size());\n                for (std::size_t i = 0; i &lt; newStates.size(); ++i) {\n                    newStates_ublas(i) = newStates[i];\n                }\n\n                boost::numeric::odeint::controlled_step_result result = this-&gt;controlledStepper-&gt;try_step(std::make_pair( boundSystem, boundJacobian ), newStates_ublas, currentTime, dt);\n                \n                newStates = OdeintImplicitStepSolver::ublasToStd(newStates_ublas);\n\n                system(states_0, currentTime); // Set initial states again, may be optimized\n\n                // Debug log output\n                if (result == boost::numeric::odeint::success)\n                {\n                    return {true, newStates, dt};\n                }\n                else\n                {\n                    return {false, newStates, dt};\n                }\n            }\n    };\n} // namespace PySysLinkBase\n\n#endif /* SRC_CONTINUOUS_AND_ODE_ODEINT_IMPLICIT_STEP_SOLVER */\n"}, "/usr/include/c++/13/type_traits": {"id": "/usr/include/c++/13/type_traits", "filePath": "/usr/include/c++/13/type_traits", "content": "// C++11 &lt;type_traits&gt; -*- C++ -*-\n\n// Copyright (C) 2007-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file include/type_traits\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_TYPE_TRAITS\n#define _GLIBCXX_TYPE_TRAITS 1\n\n#pragma GCC system_header\n\n#if __cplusplus &lt; 201103L\n# include &lt;bits/c++0x_warning.h&gt;\n#else\n\n#include &lt;bits/c++config.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template&lt;typename _Tp&gt;\n    class reference_wrapper;\n\n  /**\n   * @defgroup metaprogramming Metaprogramming\n   * @ingroup utilities\n   *\n   * Template utilities for compile-time introspection and modification,\n   * including type classification traits, type property inspection traits\n   * and type transformation traits.\n   *\n   * @since C++11\n   *\n   * @{\n   */\n\n  /// integral_constant\n  template&lt;typename _Tp, _Tp __v&gt;\n    struct integral_constant\n    {\n      static constexpr _Tp                  value = __v;\n      typedef _Tp                           value_type;\n      typedef integral_constant&lt;_Tp, __v&gt;   type;\n      constexpr operator value_type() const noexcept { return value; }\n#if __cplusplus &gt; 201103L\n\n#define __cpp_lib_integral_constant_callable 201304L\n\n      constexpr value_type operator()() const noexcept { return value; }\n#endif\n    };\n\n#if ! __cpp_inline_variables\n  template&lt;typename _Tp, _Tp __v&gt;\n    constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value;\n#endif\n\n  /// The type used as a compile-time boolean with true value.\n  using true_type =  integral_constant&lt;bool, true&gt;;\n\n  /// The type used as a compile-time boolean with false value.\n  using false_type = integral_constant&lt;bool, false&gt;;\n\n  /// @cond undocumented\n  /// bool_constant for C++11\n  template&lt;bool __v&gt;\n    using __bool_constant = integral_constant&lt;bool, __v&gt;;\n  /// @endcond\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_bool_constant 201505L\n  /// Alias template for compile-time boolean constant types.\n  /// @since C++17\n  template&lt;bool __v&gt;\n    using bool_constant = integral_constant&lt;bool, __v&gt;;\n#endif\n\n  // Metaprogramming helper types.\n\n  // Primary template.\n  /// Define a member typedef `type` only if a boolean constant is true.\n  template&lt;bool, typename _Tp = void&gt;\n    struct enable_if\n    { };\n\n  // Partial specialization for true.\n  template&lt;typename _Tp&gt;\n    struct enable_if&lt;true, _Tp&gt;\n    { typedef _Tp type; };\n\n  // __enable_if_t (std::enable_if_t for C++11)\n  template&lt;bool _Cond, typename _Tp = void&gt;\n    using __enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n\n  template&lt;bool&gt;\n    struct __conditional\n    {\n      template&lt;typename _Tp, typename&gt;\n\tusing type = _Tp;\n    };\n\n  template&lt;&gt;\n    struct __conditional&lt;false&gt;\n    {\n      template&lt;typename, typename _Up&gt;\n\tusing type = _Up;\n    };\n\n  // More efficient version of std::conditional_t for internal use (and C++11)\n  template&lt;bool _Cond, typename _If, typename _Else&gt;\n    using __conditional_t\n      = typename __conditional&lt;_Cond&gt;::template type&lt;_If, _Else&gt;;\n\n  /// @cond undocumented\n  template &lt;typename _Type&gt;\n    struct __type_identity\n    { using type = _Type; };\n\n  template&lt;typename _Tp&gt;\n    using __type_identity_t = typename __type_identity&lt;_Tp&gt;::type;\n\n  namespace __detail\n  {\n    // A variadic alias template that resolves to its first argument.\n    template&lt;typename _Tp, typename...&gt;\n      using __first_t = _Tp;\n\n    // These are deliberately not defined.\n    template&lt;typename... _Bn&gt;\n      auto __or_fn(int) -&gt; __first_t&lt;false_type,\n\t\t\t\t     __enable_if_t&lt;!bool(_Bn::value)&gt;...&gt;;\n\n    template&lt;typename... _Bn&gt;\n      auto __or_fn(...) -&gt; true_type;\n\n    template&lt;typename... _Bn&gt;\n      auto __and_fn(int) -&gt; __first_t&lt;true_type,\n\t\t\t\t      __enable_if_t&lt;bool(_Bn::value)&gt;...&gt;;\n\n    template&lt;typename... _Bn&gt;\n      auto __and_fn(...) -&gt; false_type;\n  } // namespace detail\n\n  // Like C++17 std::dis/conjunction, but usable in C++11 and resolves\n  // to either true_type or false_type which allows for a more efficient\n  // implementation that avoids recursive class template instantiation.\n  template&lt;typename... _Bn&gt;\n    struct __or_\n    : decltype(__detail::__or_fn&lt;_Bn...&gt;(0))\n    { };\n\n  template&lt;typename... _Bn&gt;\n    struct __and_\n    : decltype(__detail::__and_fn&lt;_Bn...&gt;(0))\n    { };\n\n  template&lt;typename _Pp&gt;\n    struct __not_\n    : __bool_constant&lt;!bool(_Pp::value)&gt;\n    { };\n  /// @endcond\n\n#if __cplusplus &gt;= 201703L\n\n  /// @cond undocumented\n  template&lt;typename... _Bn&gt;\n    inline constexpr bool __or_v = __or_&lt;_Bn...&gt;::value;\n  template&lt;typename... _Bn&gt;\n    inline constexpr bool __and_v = __and_&lt;_Bn...&gt;::value;\n\n  namespace __detail\n  {\n    template&lt;typename /* = void */, typename _B1, typename... _Bn&gt;\n      struct __disjunction_impl\n      { using type = _B1; };\n\n    template&lt;typename _B1, typename _B2, typename... _Bn&gt;\n      struct __disjunction_impl&lt;__enable_if_t&lt;!bool(_B1::value)&gt;, _B1, _B2, _Bn...&gt;\n      { using type = typename __disjunction_impl&lt;void, _B2, _Bn...&gt;::type; };\n\n    template&lt;typename /* = void */, typename _B1, typename... _Bn&gt;\n      struct __conjunction_impl\n      { using type = _B1; };\n\n    template&lt;typename _B1, typename _B2, typename... _Bn&gt;\n      struct __conjunction_impl&lt;__enable_if_t&lt;bool(_B1::value)&gt;, _B1, _B2, _Bn...&gt;\n      { using type = typename __conjunction_impl&lt;void, _B2, _Bn...&gt;::type; };\n  } // namespace __detail\n  /// @endcond\n\n#define __cpp_lib_logical_traits 201510L\n\n  template&lt;typename... _Bn&gt;\n    struct conjunction\n    : __detail::__conjunction_impl&lt;void, _Bn...&gt;::type\n    { };\n\n  template&lt;&gt;\n    struct conjunction&lt;&gt;\n    : true_type\n    { };\n\n  template&lt;typename... _Bn&gt;\n    struct disjunction\n    : __detail::__disjunction_impl&lt;void, _Bn...&gt;::type\n    { };\n\n  template&lt;&gt;\n    struct disjunction&lt;&gt;\n    : false_type\n    { };\n\n  template&lt;typename _Pp&gt;\n    struct negation\n    : __not_&lt;_Pp&gt;::type\n    { };\n\n  /** @ingroup variable_templates\n   * @{\n   */\n  template&lt;typename... _Bn&gt;\n    inline constexpr bool conjunction_v = conjunction&lt;_Bn...&gt;::value;\n\n  template&lt;typename... _Bn&gt;\n    inline constexpr bool disjunction_v = disjunction&lt;_Bn...&gt;::value;\n\n  template&lt;typename _Pp&gt;\n    inline constexpr bool negation_v = negation&lt;_Pp&gt;::value;\n  /// @}\n\n#endif // C++17\n\n  // Forward declarations\n  template&lt;typename&gt;\n    struct is_reference;\n  template&lt;typename&gt;\n    struct is_function;\n  template&lt;typename&gt;\n    struct is_void;\n  template&lt;typename&gt;\n    struct remove_cv;\n  template&lt;typename&gt;\n    struct is_const;\n\n  /// @cond undocumented\n  template&lt;typename&gt;\n    struct __is_array_unknown_bounds;\n\n  // Helper functions that return false_type for incomplete classes,\n  // incomplete unions and arrays of known bound from those.\n\n  template &lt;typename _Tp, size_t = sizeof(_Tp)&gt;\n    constexpr true_type __is_complete_or_unbounded(__type_identity&lt;_Tp&gt;)\n    { return {}; }\n\n  template &lt;typename _TypeIdentity,\n      typename _NestedType = typename _TypeIdentity::type&gt;\n    constexpr typename __or_&lt;\n      is_reference&lt;_NestedType&gt;,\n      is_function&lt;_NestedType&gt;,\n      is_void&lt;_NestedType&gt;,\n      __is_array_unknown_bounds&lt;_NestedType&gt;\n    &gt;::type __is_complete_or_unbounded(_TypeIdentity)\n    { return {}; }\n\n  // __remove_cv_t (std::remove_cv_t for C++11).\n  template&lt;typename _Tp&gt;\n    using __remove_cv_t = typename remove_cv&lt;_Tp&gt;::type;\n  /// @endcond\n\n  // Primary type categories.\n\n  /// is_void\n  template&lt;typename _Tp&gt;\n    struct is_void\n    : public false_type { };\n\n  template&lt;&gt;\n    struct is_void&lt;void&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_void&lt;const void&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_void&lt;volatile void&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_void&lt;const volatile void&gt;\n    : public true_type { };\n\n  /// @cond undocumented\n  template&lt;typename&gt;\n    struct __is_integral_helper\n    : public false_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;bool&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;char&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;signed char&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned char&gt;\n    : public true_type { };\n\n  // We want is_integral&lt;wchar_t&gt; to be true (and make_signed/unsigned to work)\n  // even when libc doesn&#x27;t provide working &lt;wchar.h&gt; and related functions,\n  // so don&#x27;t check _GLIBCXX_USE_WCHAR_T here.\n  template&lt;&gt;\n    struct __is_integral_helper&lt;wchar_t&gt;\n    : public true_type { };\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template&lt;&gt;\n    struct __is_integral_helper&lt;char8_t&gt;\n    : public true_type { };\n#endif\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;char16_t&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;char32_t&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;short&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned short&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;int&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned int&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;long&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned long&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;long long&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned long long&gt;\n    : public true_type { };\n\n  // Conditionalizing on __STRICT_ANSI__ here will break any port that\n  // uses one of these types for size_t.\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_0&gt;\n    : public true_type { };\n\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_0&gt;\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_1&gt;\n    : public true_type { };\n\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_1&gt;\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_2&gt;\n    : public true_type { };\n\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_2&gt;\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_3&gt;\n    : public true_type { };\n\n  __extension__\n  template&lt;&gt;\n    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_3&gt;\n    : public true_type { };\n#endif\n  /// @endcond\n\n  /// is_integral\n  template&lt;typename _Tp&gt;\n    struct is_integral\n    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// @cond undocumented\n  template&lt;typename&gt;\n    struct __is_floating_point_helper\n    : public false_type { };\n\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;float&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;double&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;long double&gt;\n    : public true_type { };\n\n#ifdef __STDCPP_FLOAT16_T__\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;_Float16&gt;\n    : public true_type { };\n#endif\n\n#ifdef __STDCPP_FLOAT32_T__\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;_Float32&gt;\n    : public true_type { };\n#endif\n\n#ifdef __STDCPP_FLOAT64_T__\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;_Float64&gt;\n    : public true_type { };\n#endif\n\n#ifdef __STDCPP_FLOAT128_T__\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;_Float128&gt;\n    : public true_type { };\n#endif\n\n#ifdef __STDCPP_BFLOAT16_T__\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;__gnu_cxx::__bfloat16_t&gt;\n    : public true_type { };\n#endif\n\n#if !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128) &amp;&amp; !defined(__CUDACC__)\n  template&lt;&gt;\n    struct __is_floating_point_helper&lt;__float128&gt;\n    : public true_type { };\n#endif\n  /// @endcond\n\n  /// is_floating_point\n  template&lt;typename _Tp&gt;\n    struct is_floating_point\n    : public __is_floating_point_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_array\n  template&lt;typename&gt;\n    struct is_array\n    : public false_type { };\n\n  template&lt;typename _Tp, std::size_t _Size&gt;\n    struct is_array&lt;_Tp[_Size]&gt;\n    : public true_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_array&lt;_Tp[]&gt;\n    : public true_type { };\n\n  template&lt;typename&gt;\n    struct __is_pointer_helper\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_pointer_helper&lt;_Tp*&gt;\n    : public true_type { };\n\n  /// is_pointer\n  template&lt;typename _Tp&gt;\n    struct is_pointer\n    : public __is_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_lvalue_reference\n  template&lt;typename&gt;\n    struct is_lvalue_reference\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_lvalue_reference&lt;_Tp&amp;&gt;\n    : public true_type { };\n\n  /// is_rvalue_reference\n  template&lt;typename&gt;\n    struct is_rvalue_reference\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_rvalue_reference&lt;_Tp&amp;&amp;&gt;\n    : public true_type { };\n\n  template&lt;typename&gt;\n    struct __is_member_object_pointer_helper\n    : public false_type { };\n\n  template&lt;typename _Tp, typename _Cp&gt;\n    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt;\n    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type { };\n\n  /// is_member_object_pointer\n  template&lt;typename _Tp&gt;\n    struct is_member_object_pointer\n    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  template&lt;typename&gt;\n    struct __is_member_function_pointer_helper\n    : public false_type { };\n\n  template&lt;typename _Tp, typename _Cp&gt;\n    struct __is_member_function_pointer_helper&lt;_Tp _Cp::*&gt;\n    : public is_function&lt;_Tp&gt;::type { };\n\n  /// is_member_function_pointer\n  template&lt;typename _Tp&gt;\n    struct is_member_function_pointer\n    : public __is_member_function_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_enum\n  template&lt;typename _Tp&gt;\n    struct is_enum\n    : public integral_constant&lt;bool, __is_enum(_Tp)&gt;\n    { };\n\n  /// is_union\n  template&lt;typename _Tp&gt;\n    struct is_union\n    : public integral_constant&lt;bool, __is_union(_Tp)&gt;\n    { };\n\n  /// is_class\n  template&lt;typename _Tp&gt;\n    struct is_class\n    : public integral_constant&lt;bool, __is_class(_Tp)&gt;\n    { };\n\n  /// is_function\n  template&lt;typename _Tp&gt;\n    struct is_function\n    : public __bool_constant&lt;!is_const&lt;const _Tp&gt;::value&gt; { };\n\n  template&lt;typename _Tp&gt;\n    struct is_function&lt;_Tp&amp;&gt;\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_function&lt;_Tp&amp;&amp;&gt;\n    : public false_type { };\n\n#define __cpp_lib_is_null_pointer 201309L\n\n  /// is_null_pointer (LWG 2247).\n  template&lt;typename _Tp&gt;\n    struct is_null_pointer\n    : public false_type { };\n\n  template&lt;&gt;\n    struct is_null_pointer&lt;std::nullptr_t&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_null_pointer&lt;const std::nullptr_t&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_null_pointer&lt;volatile std::nullptr_t&gt;\n    : public true_type { };\n\n  template&lt;&gt;\n    struct is_null_pointer&lt;const volatile std::nullptr_t&gt;\n    : public true_type { };\n\n  /// __is_nullptr_t (deprecated extension).\n  /// @deprecated Non-standard. Use `is_null_pointer` instead.\n  template&lt;typename _Tp&gt;\n    struct __is_nullptr_t\n    : public is_null_pointer&lt;_Tp&gt;\n    { } _GLIBCXX_DEPRECATED_SUGGEST(&quot;std::is_null_pointer&quot;);\n\n  // Composite type categories.\n\n  /// is_reference\n  template&lt;typename _Tp&gt;\n    struct is_reference\n    : public false_type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct is_reference&lt;_Tp&amp;&gt;\n    : public true_type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct is_reference&lt;_Tp&amp;&amp;&gt;\n    : public true_type\n    { };\n\n  /// is_arithmetic\n  template&lt;typename _Tp&gt;\n    struct is_arithmetic\n    : public __or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_fundamental\n  template&lt;typename _Tp&gt;\n    struct is_fundamental\n    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;,\n\t\t   is_null_pointer&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_object\n  template&lt;typename _Tp&gt;\n    struct is_object\n    : public __not_&lt;__or_&lt;is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;,\n                          is_void&lt;_Tp&gt;&gt;&gt;::type\n    { };\n\n  template&lt;typename&gt;\n    struct is_member_pointer;\n\n  /// is_scalar\n  template&lt;typename _Tp&gt;\n    struct is_scalar\n    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_enum&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;,\n                   is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_compound\n  template&lt;typename _Tp&gt;\n    struct is_compound\n    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type { };\n\n  /// @cond undocumented\n  template&lt;typename _Tp&gt;\n    struct __is_member_pointer_helper\n    : public false_type { };\n\n  template&lt;typename _Tp, typename _Cp&gt;\n    struct __is_member_pointer_helper&lt;_Tp _Cp::*&gt;\n    : public true_type { };\n  /// @endcond\n\n  /// is_member_pointer\n  template&lt;typename _Tp&gt;\n    struct is_member_pointer\n    : public __is_member_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type\n    { };\n\n  template&lt;typename, typename&gt;\n    struct is_same;\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename... _Types&gt;\n    using __is_one_of = __or_&lt;is_same&lt;_Tp, _Types&gt;...&gt;;\n\n  // Check if a type is one of the signed integer types.\n  __extension__\n  template&lt;typename _Tp&gt;\n    using __is_signed_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,\n\t  signed char, signed short, signed int, signed long,\n\t  signed long long\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n\t  , signed __GLIBCXX_TYPE_INT_N_0\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n\t  , signed __GLIBCXX_TYPE_INT_N_1\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n\t  , signed __GLIBCXX_TYPE_INT_N_2\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n\t  , signed __GLIBCXX_TYPE_INT_N_3\n#endif\n\t  &gt;;\n\n  // Check if a type is one of the unsigned integer types.\n  __extension__\n  template&lt;typename _Tp&gt;\n    using __is_unsigned_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,\n\t  unsigned char, unsigned short, unsigned int, unsigned long,\n\t  unsigned long long\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_0\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_1\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_2\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_3\n#endif\n\t  &gt;;\n\n  // Check if a type is one of the signed or unsigned integer types.\n  template&lt;typename _Tp&gt;\n    using __is_standard_integer\n      = __or_&lt;__is_signed_integer&lt;_Tp&gt;, __is_unsigned_integer&lt;_Tp&gt;&gt;;\n\n  // __void_t (std::void_t for C++11)\n  template&lt;typename...&gt; using __void_t = void;\n  /// @endcond\n\n  // Type properties.\n\n  /// is_const\n  template&lt;typename&gt;\n    struct is_const\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_const&lt;_Tp const&gt;\n    : public true_type { };\n\n  /// is_volatile\n  template&lt;typename&gt;\n    struct is_volatile\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct is_volatile&lt;_Tp volatile&gt;\n    : public true_type { };\n\n  /// is_trivial\n  template&lt;typename _Tp&gt;\n    struct is_trivial\n    : public integral_constant&lt;bool, __is_trivial(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_copyable\n  template&lt;typename _Tp&gt;\n    struct is_trivially_copyable\n    : public integral_constant&lt;bool, __is_trivially_copyable(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_standard_layout\n  template&lt;typename _Tp&gt;\n    struct is_standard_layout\n    : public integral_constant&lt;bool, __is_standard_layout(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /** is_pod\n   * @deprecated Deprecated in C++20.\n   * Use `is_standard_layout &amp;&amp; is_trivial` instead.\n   */\n  // Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.\n  template&lt;typename _Tp&gt;\n    struct\n    _GLIBCXX20_DEPRECATED_SUGGEST(&quot;is_standard_layout &amp;&amp; is_trivial&quot;)\n    is_pod\n    : public integral_constant&lt;bool, __is_pod(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /** is_literal_type\n   * @deprecated Deprecated in C++17, removed in C++20.\n   * The idea of a literal type isn&#x27;t useful.\n   */\n  template&lt;typename _Tp&gt;\n    struct\n    _GLIBCXX17_DEPRECATED\n    is_literal_type\n    : public integral_constant&lt;bool, __is_literal_type(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_empty\n  template&lt;typename _Tp&gt;\n    struct is_empty\n    : public integral_constant&lt;bool, __is_empty(_Tp)&gt;\n    { };\n\n  /// is_polymorphic\n  template&lt;typename _Tp&gt;\n    struct is_polymorphic\n    : public integral_constant&lt;bool, __is_polymorphic(_Tp)&gt;\n    { };\n\n#if __cplusplus &gt;= 201402L\n#define __cpp_lib_is_final 201402L\n  /// is_final\n  /// @since C++14\n  template&lt;typename _Tp&gt;\n    struct is_final\n    : public integral_constant&lt;bool, __is_final(_Tp)&gt;\n    { };\n#endif\n\n  /// is_abstract\n  template&lt;typename _Tp&gt;\n    struct is_abstract\n    : public integral_constant&lt;bool, __is_abstract(_Tp)&gt;\n    { };\n\n  /// @cond undocumented\n  template&lt;typename _Tp,\n\t   bool = is_arithmetic&lt;_Tp&gt;::value&gt;\n    struct __is_signed_helper\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_signed_helper&lt;_Tp, true&gt;\n    : public integral_constant&lt;bool, _Tp(-1) &lt; _Tp(0)&gt;\n    { };\n  /// @endcond\n\n  /// is_signed\n  template&lt;typename _Tp&gt;\n    struct is_signed\n    : public __is_signed_helper&lt;_Tp&gt;::type\n    { };\n\n  /// is_unsigned\n  template&lt;typename _Tp&gt;\n    struct is_unsigned\n    : public __and_&lt;is_arithmetic&lt;_Tp&gt;, __not_&lt;is_signed&lt;_Tp&gt;&gt;&gt;::type\n    { };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Up = _Tp&amp;&amp;&gt;\n    _Up\n    __declval(int);\n\n  template&lt;typename _Tp&gt;\n    _Tp\n    __declval(long);\n  /// @endcond\n\n  template&lt;typename _Tp&gt;\n    auto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0));\n\n  template&lt;typename&gt;\n    struct remove_all_extents;\n\n  /// @cond undocumented\n  template&lt;typename _Tp&gt;\n    struct __is_array_known_bounds\n    : public false_type\n    { };\n\n  template&lt;typename _Tp, size_t _Size&gt;\n    struct __is_array_known_bounds&lt;_Tp[_Size]&gt;\n    : public true_type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_array_unknown_bounds\n    : public false_type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_array_unknown_bounds&lt;_Tp[]&gt;\n    : public true_type\n    { };\n\n  // Destructible and constructible type properties.\n\n  // In N3290 is_destructible does not say anything about function\n  // types and abstract types, see LWG 2049. This implementation\n  // describes function types as non-destructible and all complete\n  // object types as destructible, iff the explicit destructor\n  // call expression is wellformed.\n  struct __do_is_destructible_impl\n  {\n    template&lt;typename _Tp, typename = decltype(declval&lt;_Tp&amp;&gt;().~_Tp())&gt;\n      static true_type __test(int);\n\n    template&lt;typename&gt;\n      static false_type __test(...);\n  };\n\n  template&lt;typename _Tp&gt;\n    struct __is_destructible_impl\n    : public __do_is_destructible_impl\n    {\n      typedef decltype(__test&lt;_Tp&gt;(0)) type;\n    };\n\n  template&lt;typename _Tp,\n           bool = __or_&lt;is_void&lt;_Tp&gt;,\n                        __is_array_unknown_bounds&lt;_Tp&gt;,\n                        is_function&lt;_Tp&gt;&gt;::value,\n           bool = __or_&lt;is_reference&lt;_Tp&gt;, is_scalar&lt;_Tp&gt;&gt;::value&gt;\n    struct __is_destructible_safe;\n\n  template&lt;typename _Tp&gt;\n    struct __is_destructible_safe&lt;_Tp, false, false&gt;\n    : public __is_destructible_impl&lt;typename\n               remove_all_extents&lt;_Tp&gt;::type&gt;::type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_destructible_safe&lt;_Tp, true, false&gt;\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_destructible_safe&lt;_Tp, false, true&gt;\n    : public true_type { };\n  /// @endcond\n\n  /// is_destructible\n  template&lt;typename _Tp&gt;\n    struct is_destructible\n    : public __is_destructible_safe&lt;_Tp&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n\n  // is_nothrow_destructible requires that is_destructible is\n  // satisfied as well.  We realize that by mimicing the\n  // implementation of is_destructible but refer to noexcept(expr)\n  // instead of decltype(expr).\n  struct __do_is_nt_destructible_impl\n  {\n    template&lt;typename _Tp&gt;\n      static __bool_constant&lt;noexcept(declval&lt;_Tp&amp;&gt;().~_Tp())&gt;\n      __test(int);\n\n    template&lt;typename&gt;\n      static false_type __test(...);\n  };\n\n  template&lt;typename _Tp&gt;\n    struct __is_nt_destructible_impl\n    : public __do_is_nt_destructible_impl\n    {\n      typedef decltype(__test&lt;_Tp&gt;(0)) type;\n    };\n\n  template&lt;typename _Tp,\n           bool = __or_&lt;is_void&lt;_Tp&gt;,\n                        __is_array_unknown_bounds&lt;_Tp&gt;,\n                        is_function&lt;_Tp&gt;&gt;::value,\n           bool = __or_&lt;is_reference&lt;_Tp&gt;, is_scalar&lt;_Tp&gt;&gt;::value&gt;\n    struct __is_nt_destructible_safe;\n\n  template&lt;typename _Tp&gt;\n    struct __is_nt_destructible_safe&lt;_Tp, false, false&gt;\n    : public __is_nt_destructible_impl&lt;typename\n               remove_all_extents&lt;_Tp&gt;::type&gt;::type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_nt_destructible_safe&lt;_Tp, true, false&gt;\n    : public false_type { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_nt_destructible_safe&lt;_Tp, false, true&gt;\n    : public true_type { };\n  /// @endcond\n\n  /// is_nothrow_destructible\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_destructible\n    : public __is_nt_destructible_safe&lt;_Tp&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename... _Args&gt;\n    using __is_constructible_impl\n      = __bool_constant&lt;__is_constructible(_Tp, _Args...)&gt;;\n  /// @endcond\n\n  /// is_constructible\n  template&lt;typename _Tp, typename... _Args&gt;\n    struct is_constructible\n      : public __is_constructible_impl&lt;_Tp, _Args...&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_default_constructible\n  template&lt;typename _Tp&gt;\n    struct is_default_constructible\n    : public __is_constructible_impl&lt;_Tp&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename = void&gt;\n    struct __add_lvalue_reference_helper\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct __add_lvalue_reference_helper&lt;_Tp, __void_t&lt;_Tp&amp;&gt;&gt;\n    { using type = _Tp&amp;; };\n\n  template&lt;typename _Tp&gt;\n    using __add_lval_ref_t = typename __add_lvalue_reference_helper&lt;_Tp&gt;::type;\n  /// @endcond\n\n  /// is_copy_constructible\n  template&lt;typename _Tp&gt;\n    struct is_copy_constructible\n    : public __is_constructible_impl&lt;_Tp, __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename = void&gt;\n    struct __add_rvalue_reference_helper\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct __add_rvalue_reference_helper&lt;_Tp, __void_t&lt;_Tp&amp;&amp;&gt;&gt;\n    { using type = _Tp&amp;&amp;; };\n\n  template&lt;typename _Tp&gt;\n    using __add_rval_ref_t = typename __add_rvalue_reference_helper&lt;_Tp&gt;::type;\n  /// @endcond\n\n  /// is_move_constructible\n  template&lt;typename _Tp&gt;\n    struct is_move_constructible\n    : public __is_constructible_impl&lt;_Tp, __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename... _Args&gt;\n    using __is_nothrow_constructible_impl\n      = __bool_constant&lt;__is_nothrow_constructible(_Tp, _Args...)&gt;;\n  /// @endcond\n\n  /// is_nothrow_constructible\n  template&lt;typename _Tp, typename... _Args&gt;\n    struct is_nothrow_constructible\n    : public __is_nothrow_constructible_impl&lt;_Tp, _Args...&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_default_constructible\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_default_constructible\n    : public __is_nothrow_constructible_impl&lt;_Tp&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_copy_constructible\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_copy_constructible\n    : public __is_nothrow_constructible_impl&lt;_Tp, __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_move_constructible\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_move_constructible\n    : public __is_nothrow_constructible_impl&lt;_Tp, __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Up&gt;\n    using __is_assignable_impl = __bool_constant&lt;__is_assignable(_Tp, _Up)&gt;;\n  /// @endcond\n\n  /// is_assignable\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_assignable\n    : public __is_assignable_impl&lt;_Tp, _Up&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_copy_assignable\n  template&lt;typename _Tp&gt;\n    struct is_copy_assignable\n    : public __is_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t  __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_move_assignable\n  template&lt;typename _Tp&gt;\n    struct is_move_assignable\n    : public __is_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;, __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Up&gt;\n    using __is_nothrow_assignable_impl\n      = __bool_constant&lt;__is_nothrow_assignable(_Tp, _Up)&gt;;\n  /// @endcond\n\n  /// is_nothrow_assignable\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_nothrow_assignable\n    : public __is_nothrow_assignable_impl&lt;_Tp, _Up&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_copy_assignable\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_copy_assignable\n    : public __is_nothrow_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t\t  __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_move_assignable\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_move_assignable\n    : public __is_nothrow_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t\t  __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename... _Args&gt;\n    using __is_trivially_constructible_impl\n      = __bool_constant&lt;__is_trivially_constructible(_Tp, _Args...)&gt;;\n  /// @endcond\n\n  /// is_trivially_constructible\n  template&lt;typename _Tp, typename... _Args&gt;\n    struct is_trivially_constructible\n    : public __is_trivially_constructible_impl&lt;_Tp, _Args...&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_default_constructible\n  template&lt;typename _Tp&gt;\n    struct is_trivially_default_constructible\n    : public __is_trivially_constructible_impl&lt;_Tp&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  struct __do_is_implicitly_default_constructible_impl\n  {\n    template &lt;typename _Tp&gt;\n    static void __helper(const _Tp&amp;);\n\n    template &lt;typename _Tp&gt;\n    static true_type __test(const _Tp&amp;,\n                            decltype(__helper&lt;const _Tp&amp;&gt;({}))* = 0);\n\n    static false_type __test(...);\n  };\n\n  template&lt;typename _Tp&gt;\n    struct __is_implicitly_default_constructible_impl\n    : public __do_is_implicitly_default_constructible_impl\n    {\n      typedef decltype(__test(declval&lt;_Tp&gt;())) type;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __is_implicitly_default_constructible_safe\n    : public __is_implicitly_default_constructible_impl&lt;_Tp&gt;::type\n    { };\n\n  template &lt;typename _Tp&gt;\n    struct __is_implicitly_default_constructible\n    : public __and_&lt;__is_constructible_impl&lt;_Tp&gt;,\n\t\t    __is_implicitly_default_constructible_safe&lt;_Tp&gt;&gt;::type\n    { };\n\n  /// is_trivially_copy_constructible\n  template&lt;typename _Tp&gt;\n    struct is_trivially_copy_constructible\n    : public __is_trivially_constructible_impl&lt;_Tp, __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_move_constructible\n  template&lt;typename _Tp&gt;\n    struct is_trivially_move_constructible\n    : public __is_trivially_constructible_impl&lt;_Tp, __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Up&gt;\n    using __is_trivially_assignable_impl\n      = __bool_constant&lt;__is_trivially_assignable(_Tp, _Up)&gt;;\n  /// @endcond\n\n  /// is_trivially_assignable\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_trivially_assignable\n    : public __is_trivially_assignable_impl&lt;_Tp, _Up&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_copy_assignable\n  template&lt;typename _Tp&gt;\n    struct is_trivially_copy_assignable\n    : public __is_trivially_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t\t    __add_lval_ref_t&lt;const _Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_move_assignable\n  template&lt;typename _Tp&gt;\n    struct is_trivially_move_assignable\n    : public __is_trivially_assignable_impl&lt;__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t\t    __add_rval_ref_t&lt;_Tp&gt;&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_trivially_destructible\n  template&lt;typename _Tp&gt;\n    struct is_trivially_destructible\n    : public __and_&lt;__is_destructible_safe&lt;_Tp&gt;,\n\t\t    __bool_constant&lt;__has_trivial_destructor(_Tp)&gt;&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n\n  /// has_virtual_destructor\n  template&lt;typename _Tp&gt;\n    struct has_virtual_destructor\n    : public integral_constant&lt;bool, __has_virtual_destructor(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n\n  // type property queries.\n\n  /// alignment_of\n  template&lt;typename _Tp&gt;\n    struct alignment_of\n    : public integral_constant&lt;std::size_t, alignof(_Tp)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// rank\n  template&lt;typename&gt;\n    struct rank\n    : public integral_constant&lt;std::size_t, 0&gt; { };\n\n  template&lt;typename _Tp, std::size_t _Size&gt;\n    struct rank&lt;_Tp[_Size]&gt;\n    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; { };\n\n  template&lt;typename _Tp&gt;\n    struct rank&lt;_Tp[]&gt;\n    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; { };\n\n  /// extent\n  template&lt;typename, unsigned _Uint = 0&gt;\n    struct extent\n    : public integral_constant&lt;size_t, 0&gt; { };\n\n  template&lt;typename _Tp, size_t _Size&gt;\n    struct extent&lt;_Tp[_Size], 0&gt;\n    : public integral_constant&lt;size_t, _Size&gt; { };\n\n  template&lt;typename _Tp, unsigned _Uint, size_t _Size&gt;\n    struct extent&lt;_Tp[_Size], _Uint&gt;\n    : public extent&lt;_Tp, _Uint - 1&gt;::type { };\n\n  template&lt;typename _Tp&gt;\n    struct extent&lt;_Tp[], 0&gt;\n    : public integral_constant&lt;size_t, 0&gt; { };\n\n  template&lt;typename _Tp, unsigned _Uint&gt;\n    struct extent&lt;_Tp[], _Uint&gt;\n    : public extent&lt;_Tp, _Uint - 1&gt;::type { };\n\n\n  // Type relations.\n\n  /// is_same\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_same\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME\n    : public integral_constant&lt;bool, __is_same(_Tp, _Up)&gt;\n#else\n    : public false_type\n#endif\n    { };\n\n#ifndef _GLIBCXX_HAVE_BUILTIN_IS_SAME\n  template&lt;typename _Tp&gt;\n    struct is_same&lt;_Tp, _Tp&gt;\n    : public true_type\n    { };\n#endif\n\n  /// is_base_of\n  template&lt;typename _Base, typename _Derived&gt;\n    struct is_base_of\n    : public integral_constant&lt;bool, __is_base_of(_Base, _Derived)&gt;\n    { };\n\n#if __has_builtin(__is_convertible)\n  template&lt;typename _From, typename _To&gt;\n    struct is_convertible\n    : public __bool_constant&lt;__is_convertible(_From, _To)&gt;\n    { };\n#else\n  template&lt;typename _From, typename _To,\n           bool = __or_&lt;is_void&lt;_From&gt;, is_function&lt;_To&gt;,\n                        is_array&lt;_To&gt;&gt;::value&gt;\n    struct __is_convertible_helper\n    {\n      typedef typename is_void&lt;_To&gt;::type type;\n    };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wctor-dtor-privacy&quot;\n  template&lt;typename _From, typename _To&gt;\n    class __is_convertible_helper&lt;_From, _To, false&gt;\n    {\n      template&lt;typename _To1&gt;\n\tstatic void __test_aux(_To1) noexcept;\n\n      template&lt;typename _From1, typename _To1,\n\t       typename = decltype(__test_aux&lt;_To1&gt;(std::declval&lt;_From1&gt;()))&gt;\n\tstatic true_type\n\t__test(int);\n\n      template&lt;typename, typename&gt;\n\tstatic false_type\n\t__test(...);\n\n    public:\n      typedef decltype(__test&lt;_From, _To&gt;(0)) type;\n    };\n#pragma GCC diagnostic pop\n\n  /// is_convertible\n  template&lt;typename _From, typename _To&gt;\n    struct is_convertible\n    : public __is_convertible_helper&lt;_From, _To&gt;::type\n    { };\n#endif\n\n  // helper trait for unique_ptr&lt;T[]&gt;, shared_ptr&lt;T[]&gt;, and span&lt;T, N&gt;\n  template&lt;typename _ToElementType, typename _FromElementType&gt;\n    using __is_array_convertible\n      = is_convertible&lt;_FromElementType(*)[], _ToElementType(*)[]&gt;;\n\n#if __cplusplus &gt;= 202002L\n#define __cpp_lib_is_nothrow_convertible 201806L\n\n#if __has_builtin(__is_nothrow_convertible)\n  /// is_nothrow_convertible_v\n  template&lt;typename _From, typename _To&gt;\n    inline constexpr bool is_nothrow_convertible_v\n      = __is_nothrow_convertible(_From, _To);\n\n  /// is_nothrow_convertible\n  template&lt;typename _From, typename _To&gt;\n    struct is_nothrow_convertible\n    : public bool_constant&lt;is_nothrow_convertible_v&lt;_From, _To&gt;&gt;\n    { };\n#else\n  template&lt;typename _From, typename _To,\n           bool = __or_&lt;is_void&lt;_From&gt;, is_function&lt;_To&gt;,\n                        is_array&lt;_To&gt;&gt;::value&gt;\n    struct __is_nt_convertible_helper\n    : is_void&lt;_To&gt;\n    { };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wctor-dtor-privacy&quot;\n  template&lt;typename _From, typename _To&gt;\n    class __is_nt_convertible_helper&lt;_From, _To, false&gt;\n    {\n      template&lt;typename _To1&gt;\n\tstatic void __test_aux(_To1) noexcept;\n\n      template&lt;typename _From1, typename _To1&gt;\n\tstatic\n\t__bool_constant&lt;noexcept(__test_aux&lt;_To1&gt;(std::declval&lt;_From1&gt;()))&gt;\n\t__test(int);\n\n      template&lt;typename, typename&gt;\n\tstatic false_type\n\t__test(...);\n\n    public:\n      using type = decltype(__test&lt;_From, _To&gt;(0));\n    };\n#pragma GCC diagnostic pop\n\n  /// is_nothrow_convertible\n  template&lt;typename _From, typename _To&gt;\n    struct is_nothrow_convertible\n    : public __is_nt_convertible_helper&lt;_From, _To&gt;::type\n    { };\n\n  /// is_nothrow_convertible_v\n  template&lt;typename _From, typename _To&gt;\n    inline constexpr bool is_nothrow_convertible_v\n      = is_nothrow_convertible&lt;_From, _To&gt;::value;\n#endif\n#endif // C++2a\n\n  // Const-volatile modifications.\n\n  /// remove_const\n  template&lt;typename _Tp&gt;\n    struct remove_const\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_const&lt;_Tp const&gt;\n    { typedef _Tp     type; };\n\n  /// remove_volatile\n  template&lt;typename _Tp&gt;\n    struct remove_volatile\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_volatile&lt;_Tp volatile&gt;\n    { typedef _Tp     type; };\n\n  /// remove_cv\n#if __has_builtin(__remove_cv)\n  template&lt;typename _Tp&gt;\n    struct remove_cv\n    { using type = __remove_cv(_Tp); };\n#else\n  template&lt;typename _Tp&gt;\n    struct remove_cv\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_cv&lt;const _Tp&gt;\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_cv&lt;volatile _Tp&gt;\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_cv&lt;const volatile _Tp&gt;\n    { using type = _Tp; };\n#endif\n\n  /// add_const\n  template&lt;typename _Tp&gt;\n    struct add_const\n    { using type = _Tp const; };\n\n  /// add_volatile\n  template&lt;typename _Tp&gt;\n    struct add_volatile\n    { using type = _Tp volatile; };\n\n  /// add_cv\n  template&lt;typename _Tp&gt;\n    struct add_cv\n    { using type = _Tp const volatile; };\n\n#if __cplusplus &gt; 201103L\n\n#define __cpp_lib_transformation_trait_aliases 201304L\n\n  /// Alias template for remove_const\n  template&lt;typename _Tp&gt;\n    using remove_const_t = typename remove_const&lt;_Tp&gt;::type;\n\n  /// Alias template for remove_volatile\n  template&lt;typename _Tp&gt;\n    using remove_volatile_t = typename remove_volatile&lt;_Tp&gt;::type;\n\n  /// Alias template for remove_cv\n  template&lt;typename _Tp&gt;\n    using remove_cv_t = typename remove_cv&lt;_Tp&gt;::type;\n\n  /// Alias template for add_const\n  template&lt;typename _Tp&gt;\n    using add_const_t = typename add_const&lt;_Tp&gt;::type;\n\n  /// Alias template for add_volatile\n  template&lt;typename _Tp&gt;\n    using add_volatile_t = typename add_volatile&lt;_Tp&gt;::type;\n\n  /// Alias template for add_cv\n  template&lt;typename _Tp&gt;\n    using add_cv_t = typename add_cv&lt;_Tp&gt;::type;\n#endif\n\n  // Reference transformations.\n\n  /// remove_reference\n#if __has_builtin(__remove_reference)\n  template&lt;typename _Tp&gt;\n    struct remove_reference\n    { using type = __remove_reference(_Tp); };\n#else\n  template&lt;typename _Tp&gt;\n    struct remove_reference\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_reference&lt;_Tp&amp;&gt;\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_reference&lt;_Tp&amp;&amp;&gt;\n    { using type = _Tp; };\n#endif\n\n  /// add_lvalue_reference\n  template&lt;typename _Tp&gt;\n    struct add_lvalue_reference\n    { using type = __add_lval_ref_t&lt;_Tp&gt;; };\n\n  /// add_rvalue_reference\n  template&lt;typename _Tp&gt;\n    struct add_rvalue_reference\n    { using type = __add_rval_ref_t&lt;_Tp&gt;; };\n\n#if __cplusplus &gt; 201103L\n  /// Alias template for remove_reference\n  template&lt;typename _Tp&gt;\n    using remove_reference_t = typename remove_reference&lt;_Tp&gt;::type;\n\n  /// Alias template for add_lvalue_reference\n  template&lt;typename _Tp&gt;\n    using add_lvalue_reference_t = typename add_lvalue_reference&lt;_Tp&gt;::type;\n\n  /// Alias template for add_rvalue_reference\n  template&lt;typename _Tp&gt;\n    using add_rvalue_reference_t = typename add_rvalue_reference&lt;_Tp&gt;::type;\n#endif\n\n  // Sign modifications.\n\n  /// @cond undocumented\n\n  // Utility for constructing identically cv-qualified types.\n  template&lt;typename _Unqualified, bool _IsConst, bool _IsVol&gt;\n    struct __cv_selector;\n\n  template&lt;typename _Unqualified&gt;\n    struct __cv_selector&lt;_Unqualified, false, false&gt;\n    { typedef _Unqualified __type; };\n\n  template&lt;typename _Unqualified&gt;\n    struct __cv_selector&lt;_Unqualified, false, true&gt;\n    { typedef volatile _Unqualified __type; };\n\n  template&lt;typename _Unqualified&gt;\n    struct __cv_selector&lt;_Unqualified, true, false&gt;\n    { typedef const _Unqualified __type; };\n\n  template&lt;typename _Unqualified&gt;\n    struct __cv_selector&lt;_Unqualified, true, true&gt;\n    { typedef const volatile _Unqualified __type; };\n\n  template&lt;typename _Qualified, typename _Unqualified,\n\t   bool _IsConst = is_const&lt;_Qualified&gt;::value,\n\t   bool _IsVol = is_volatile&lt;_Qualified&gt;::value&gt;\n    class __match_cv_qualifiers\n    {\n      typedef __cv_selector&lt;_Unqualified, _IsConst, _IsVol&gt; __match;\n\n    public:\n      typedef typename __match::__type __type;\n    };\n\n  // Utility for finding the unsigned versions of signed integral types.\n  template&lt;typename _Tp&gt;\n    struct __make_unsigned\n    { typedef _Tp __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;char&gt;\n    { typedef unsigned char __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;signed char&gt;\n    { typedef unsigned char __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;short&gt;\n    { typedef unsigned short __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;int&gt;\n    { typedef unsigned int __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;long&gt;\n    { typedef unsigned long __type; };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;long long&gt;\n    { typedef unsigned long long __type; };\n\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  __extension__\n  template&lt;&gt;\n    struct __make_unsigned&lt;__GLIBCXX_TYPE_INT_N_0&gt;\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_0 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  __extension__\n  template&lt;&gt;\n    struct __make_unsigned&lt;__GLIBCXX_TYPE_INT_N_1&gt;\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_1 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  __extension__\n  template&lt;&gt;\n    struct __make_unsigned&lt;__GLIBCXX_TYPE_INT_N_2&gt;\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_2 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  __extension__\n  template&lt;&gt;\n    struct __make_unsigned&lt;__GLIBCXX_TYPE_INT_N_3&gt;\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_3 __type; };\n#endif\n\n  // Select between integral and enum: not possible to be both.\n  template&lt;typename _Tp,\n\t   bool _IsInt = is_integral&lt;_Tp&gt;::value,\n\t   bool _IsEnum = is_enum&lt;_Tp&gt;::value&gt;\n    class __make_unsigned_selector;\n\n  template&lt;typename _Tp&gt;\n    class __make_unsigned_selector&lt;_Tp, true, false&gt;\n    {\n      using __unsigned_type\n\t= typename __make_unsigned&lt;__remove_cv_t&lt;_Tp&gt;&gt;::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers&lt;_Tp, __unsigned_type&gt;::__type;\n    };\n\n  class __make_unsigned_selector_base\n  {\n  protected:\n    template&lt;typename...&gt; struct _List { };\n\n    template&lt;typename _Tp, typename... _Up&gt;\n      struct _List&lt;_Tp, _Up...&gt; : _List&lt;_Up...&gt;\n      { static constexpr size_t __size = sizeof(_Tp); };\n\n    template&lt;size_t _Sz, typename _Tp, bool = (_Sz &lt;= _Tp::__size)&gt;\n      struct __select;\n\n    template&lt;size_t _Sz, typename _Uint, typename... _UInts&gt;\n      struct __select&lt;_Sz, _List&lt;_Uint, _UInts...&gt;, true&gt;\n      { using __type = _Uint; };\n\n    template&lt;size_t _Sz, typename _Uint, typename... _UInts&gt;\n      struct __select&lt;_Sz, _List&lt;_Uint, _UInts...&gt;, false&gt;\n      : __select&lt;_Sz, _List&lt;_UInts...&gt;&gt;\n      { };\n  };\n\n  // Choose unsigned integer type with the smallest rank and same size as _Tp\n  template&lt;typename _Tp&gt;\n    class __make_unsigned_selector&lt;_Tp, false, true&gt;\n    : __make_unsigned_selector_base\n    {\n      // With -fshort-enums, an enum may be as small as a char.\n      using _UInts = _List&lt;unsigned char, unsigned short, unsigned int,\n\t\t\t   unsigned long, unsigned long long&gt;;\n\n      using __unsigned_type = typename __select&lt;sizeof(_Tp), _UInts&gt;::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers&lt;_Tp, __unsigned_type&gt;::__type;\n    };\n\n  // wchar_t, char8_t, char16_t and char32_t are integral types but are\n  // neither signed integer types nor unsigned integer types, so must be\n  // transformed to the unsigned integer type with the smallest rank.\n  // Use the partial specialization for enumeration types to do that.\n  template&lt;&gt;\n    struct __make_unsigned&lt;wchar_t&gt;\n    {\n      using __type\n\t= typename __make_unsigned_selector&lt;wchar_t, false, true&gt;::__type;\n    };\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template&lt;&gt;\n    struct __make_unsigned&lt;char8_t&gt;\n    {\n      using __type\n\t= typename __make_unsigned_selector&lt;char8_t, false, true&gt;::__type;\n    };\n#endif\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;char16_t&gt;\n    {\n      using __type\n\t= typename __make_unsigned_selector&lt;char16_t, false, true&gt;::__type;\n    };\n\n  template&lt;&gt;\n    struct __make_unsigned&lt;char32_t&gt;\n    {\n      using __type\n\t= typename __make_unsigned_selector&lt;char32_t, false, true&gt;::__type;\n    };\n  /// @endcond\n\n  // Given an integral/enum type, return the corresponding unsigned\n  // integer type.\n  // Primary template.\n  /// make_unsigned\n  template&lt;typename _Tp&gt;\n    struct make_unsigned\n    { typedef typename __make_unsigned_selector&lt;_Tp&gt;::__type type; };\n\n  // Integral, but don&#x27;t define.\n  template&lt;&gt; struct make_unsigned&lt;bool&gt;;\n  template&lt;&gt; struct make_unsigned&lt;bool const&gt;;\n  template&lt;&gt; struct make_unsigned&lt;bool volatile&gt;;\n  template&lt;&gt; struct make_unsigned&lt;bool const volatile&gt;;\n\n  /// @cond undocumented\n\n  // Utility for finding the signed versions of unsigned integral types.\n  template&lt;typename _Tp&gt;\n    struct __make_signed\n    { typedef _Tp __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;char&gt;\n    { typedef signed char __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned char&gt;\n    { typedef signed char __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned short&gt;\n    { typedef signed short __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned int&gt;\n    { typedef signed int __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned long&gt;\n    { typedef signed long __type; };\n\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned long long&gt;\n    { typedef signed long long __type; };\n\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  __extension__\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned __GLIBCXX_TYPE_INT_N_0&gt;\n    { typedef __GLIBCXX_TYPE_INT_N_0 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  __extension__\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned __GLIBCXX_TYPE_INT_N_1&gt;\n    { typedef __GLIBCXX_TYPE_INT_N_1 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  __extension__\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned __GLIBCXX_TYPE_INT_N_2&gt;\n    { typedef __GLIBCXX_TYPE_INT_N_2 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  __extension__\n  template&lt;&gt;\n    struct __make_signed&lt;unsigned __GLIBCXX_TYPE_INT_N_3&gt;\n    { typedef __GLIBCXX_TYPE_INT_N_3 __type; };\n#endif\n\n  // Select between integral and enum: not possible to be both.\n  template&lt;typename _Tp,\n\t   bool _IsInt = is_integral&lt;_Tp&gt;::value,\n\t   bool _IsEnum = is_enum&lt;_Tp&gt;::value&gt;\n    class __make_signed_selector;\n\n  template&lt;typename _Tp&gt;\n    class __make_signed_selector&lt;_Tp, true, false&gt;\n    {\n      using __signed_type\n\t= typename __make_signed&lt;__remove_cv_t&lt;_Tp&gt;&gt;::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers&lt;_Tp, __signed_type&gt;::__type;\n    };\n\n  // Choose signed integer type with the smallest rank and same size as _Tp\n  template&lt;typename _Tp&gt;\n    class __make_signed_selector&lt;_Tp, false, true&gt;\n    {\n      typedef typename __make_unsigned_selector&lt;_Tp&gt;::__type __unsigned_type;\n\n    public:\n      typedef typename __make_signed_selector&lt;__unsigned_type&gt;::__type __type;\n    };\n\n  // wchar_t, char16_t and char32_t are integral types but are neither\n  // signed integer types nor unsigned integer types, so must be\n  // transformed to the signed integer type with the smallest rank.\n  // Use the partial specialization for enumeration types to do that.\n  template&lt;&gt;\n    struct __make_signed&lt;wchar_t&gt;\n    {\n      using __type\n\t= typename __make_signed_selector&lt;wchar_t, false, true&gt;::__type;\n    };\n\n#if defined(_GLIBCXX_USE_CHAR8_T)\n  template&lt;&gt;\n    struct __make_signed&lt;char8_t&gt;\n    {\n      using __type\n\t= typename __make_signed_selector&lt;char8_t, false, true&gt;::__type;\n    };\n#endif\n\n  template&lt;&gt;\n    struct __make_signed&lt;char16_t&gt;\n    {\n      using __type\n\t= typename __make_signed_selector&lt;char16_t, false, true&gt;::__type;\n    };\n\n  template&lt;&gt;\n    struct __make_signed&lt;char32_t&gt;\n    {\n      using __type\n\t= typename __make_signed_selector&lt;char32_t, false, true&gt;::__type;\n    };\n  /// @endcond\n\n  // Given an integral/enum type, return the corresponding signed\n  // integer type.\n  // Primary template.\n  /// make_signed\n  template&lt;typename _Tp&gt;\n    struct make_signed\n    { typedef typename __make_signed_selector&lt;_Tp&gt;::__type type; };\n\n  // Integral, but don&#x27;t define.\n  template&lt;&gt; struct make_signed&lt;bool&gt;;\n  template&lt;&gt; struct make_signed&lt;bool const&gt;;\n  template&lt;&gt; struct make_signed&lt;bool volatile&gt;;\n  template&lt;&gt; struct make_signed&lt;bool const volatile&gt;;\n\n#if __cplusplus &gt; 201103L\n  /// Alias template for make_signed\n  template&lt;typename _Tp&gt;\n    using make_signed_t = typename make_signed&lt;_Tp&gt;::type;\n\n  /// Alias template for make_unsigned\n  template&lt;typename _Tp&gt;\n    using make_unsigned_t = typename make_unsigned&lt;_Tp&gt;::type;\n#endif\n\n  // Array modifications.\n\n  /// remove_extent\n  template&lt;typename _Tp&gt;\n    struct remove_extent\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp, std::size_t _Size&gt;\n    struct remove_extent&lt;_Tp[_Size]&gt;\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_extent&lt;_Tp[]&gt;\n    { typedef _Tp     type; };\n\n  /// remove_all_extents\n  template&lt;typename _Tp&gt;\n    struct remove_all_extents\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp, std::size_t _Size&gt;\n    struct remove_all_extents&lt;_Tp[_Size]&gt;\n    { typedef typename remove_all_extents&lt;_Tp&gt;::type     type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_all_extents&lt;_Tp[]&gt;\n    { typedef typename remove_all_extents&lt;_Tp&gt;::type     type; };\n\n#if __cplusplus &gt; 201103L\n  /// Alias template for remove_extent\n  template&lt;typename _Tp&gt;\n    using remove_extent_t = typename remove_extent&lt;_Tp&gt;::type;\n\n  /// Alias template for remove_all_extents\n  template&lt;typename _Tp&gt;\n    using remove_all_extents_t = typename remove_all_extents&lt;_Tp&gt;::type;\n#endif\n\n  // Pointer modifications.\n\n  template&lt;typename _Tp, typename&gt;\n    struct __remove_pointer_helper\n    { typedef _Tp     type; };\n\n  template&lt;typename _Tp, typename _Up&gt;\n    struct __remove_pointer_helper&lt;_Tp, _Up*&gt;\n    { typedef _Up     type; };\n\n  /// remove_pointer\n  template&lt;typename _Tp&gt;\n    struct remove_pointer\n    : public __remove_pointer_helper&lt;_Tp, __remove_cv_t&lt;_Tp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, typename = void&gt;\n    struct __add_pointer_helper\n    { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct __add_pointer_helper&lt;_Tp, __void_t&lt;_Tp*&gt;&gt;\n    { using type = _Tp*; };\n\n  /// add_pointer\n  template&lt;typename _Tp&gt;\n    struct add_pointer\n    : public __add_pointer_helper&lt;_Tp&gt;\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct add_pointer&lt;_Tp&amp;&gt;\n    { using type = _Tp*; };\n\n  template&lt;typename _Tp&gt;\n    struct add_pointer&lt;_Tp&amp;&amp;&gt;\n    { using type = _Tp*; };\n\n#if __cplusplus &gt; 201103L\n  /// Alias template for remove_pointer\n  template&lt;typename _Tp&gt;\n    using remove_pointer_t = typename remove_pointer&lt;_Tp&gt;::type;\n\n  /// Alias template for add_pointer\n  template&lt;typename _Tp&gt;\n    using add_pointer_t = typename add_pointer&lt;_Tp&gt;::type;\n#endif\n\n  template&lt;std::size_t _Len&gt;\n    struct __aligned_storage_msa\n    {\n      union __type\n      {\n\tunsigned char __data[_Len];\n\tstruct __attribute__((__aligned__)) { } __align;\n      };\n    };\n\n  /**\n   *  @brief Alignment type.\n   *\n   *  The value of _Align is a default-alignment which shall be the\n   *  most stringent alignment requirement for any C++ object type\n   *  whose size is no greater than _Len (3.9). The member typedef\n   *  type shall be a POD type suitable for use as uninitialized\n   *  storage for any object whose size is at most _Len and whose\n   *  alignment is a divisor of _Align.\n   *\n   *  @deprecated Deprecated in C++23. Uses can be replaced by an\n   *  array std::byte[_Len] declared with alignas(_Align).\n  */\n  template&lt;std::size_t _Len, std::size_t _Align =\n\t   __alignof__(typename __aligned_storage_msa&lt;_Len&gt;::__type)&gt;\n    struct\n    _GLIBCXX23_DEPRECATED\n    aligned_storage\n    {\n      union type\n      {\n\tunsigned char __data[_Len];\n\tstruct __attribute__((__aligned__((_Align)))) { } __align;\n      };\n    };\n\n  template &lt;typename... _Types&gt;\n    struct __strictest_alignment\n    {\n      static const size_t _S_alignment = 0;\n      static const size_t _S_size = 0;\n    };\n\n  template &lt;typename _Tp, typename... _Types&gt;\n    struct __strictest_alignment&lt;_Tp, _Types...&gt;\n    {\n      static const size_t _S_alignment =\n        alignof(_Tp) &gt; __strictest_alignment&lt;_Types...&gt;::_S_alignment\n\t? alignof(_Tp) : __strictest_alignment&lt;_Types...&gt;::_S_alignment;\n      static const size_t _S_size =\n        sizeof(_Tp) &gt; __strictest_alignment&lt;_Types...&gt;::_S_size\n\t? sizeof(_Tp) : __strictest_alignment&lt;_Types...&gt;::_S_size;\n    };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n\n  /**\n   *  @brief Provide aligned storage for types.\n   *\n   *  [meta.trans.other]\n   *\n   *  Provides aligned storage for any of the provided types of at\n   *  least size _Len.\n   *\n   *  @see aligned_storage\n   *\n   *  @deprecated Deprecated in C++23.\n   */\n  template &lt;size_t _Len, typename... _Types&gt;\n    struct\n    _GLIBCXX23_DEPRECATED\n    aligned_union\n    {\n    private:\n      static_assert(sizeof...(_Types) != 0, &quot;At least one type is required&quot;);\n\n      using __strictest = __strictest_alignment&lt;_Types...&gt;;\n      static const size_t _S_len = _Len &gt; __strictest::_S_size\n\t? _Len : __strictest::_S_size;\n    public:\n      /// The value of the strictest alignment of _Types.\n      static const size_t alignment_value = __strictest::_S_alignment;\n      /// The storage.\n      typedef typename aligned_storage&lt;_S_len, alignment_value&gt;::type type;\n    };\n\n  template &lt;size_t _Len, typename... _Types&gt;\n    const size_t aligned_union&lt;_Len, _Types...&gt;::alignment_value;\n#pragma GCC diagnostic pop\n\n  /// @cond undocumented\n\n  // Decay trait for arrays and functions, used for perfect forwarding\n  // in make_pair, make_tuple, etc.\n  template&lt;typename _Up&gt;\n    struct __decay_selector\n    : __conditional_t&lt;is_const&lt;const _Up&gt;::value, // false for functions\n\t\t      remove_cv&lt;_Up&gt;,\t\t  // N.B. DR 705.\n\t\t      add_pointer&lt;_Up&gt;&gt;\t\t  // function decays to pointer\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __decay_selector&lt;_Up[_Nm]&gt;\n    { using type = _Up*; };\n\n  template&lt;typename _Up&gt;\n    struct __decay_selector&lt;_Up[]&gt;\n    { using type = _Up*; };\n\n  /// @endcond\n\n  /// decay\n  template&lt;typename _Tp&gt;\n    struct decay\n    { using type = typename __decay_selector&lt;_Tp&gt;::type; };\n\n  template&lt;typename _Tp&gt;\n    struct decay&lt;_Tp&amp;&gt;\n    { using type = typename __decay_selector&lt;_Tp&gt;::type; };\n\n  template&lt;typename _Tp&gt;\n    struct decay&lt;_Tp&amp;&amp;&gt;\n    { using type = typename __decay_selector&lt;_Tp&gt;::type; };\n\n  /// @cond undocumented\n\n  // Helper which adds a reference to a type when given a reference_wrapper\n  template&lt;typename _Tp&gt;\n    struct __strip_reference_wrapper\n    {\n      typedef _Tp __type;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __strip_reference_wrapper&lt;reference_wrapper&lt;_Tp&gt; &gt;\n    {\n      typedef _Tp&amp; __type;\n    };\n\n  // __decay_t (std::decay_t for C++11).\n  template&lt;typename _Tp&gt;\n    using __decay_t = typename decay&lt;_Tp&gt;::type;\n\n  template&lt;typename _Tp&gt;\n    using __decay_and_strip = __strip_reference_wrapper&lt;__decay_t&lt;_Tp&gt;&gt;;\n  /// @endcond\n\n  /// @cond undocumented\n\n  // Helper for SFINAE constraints\n  template&lt;typename... _Cond&gt;\n    using _Require = __enable_if_t&lt;__and_&lt;_Cond...&gt;::value&gt;;\n\n  // __remove_cvref_t (std::remove_cvref_t for C++11).\n  template&lt;typename _Tp&gt;\n    using __remove_cvref_t\n     = typename remove_cv&lt;typename remove_reference&lt;_Tp&gt;::type&gt;::type;\n  /// @endcond\n\n  // Primary template.\n  /// Define a member typedef @c type to one of two argument types.\n  template&lt;bool _Cond, typename _Iftrue, typename _Iffalse&gt;\n    struct conditional\n    { typedef _Iftrue type; };\n\n  // Partial specialization for false.\n  template&lt;typename _Iftrue, typename _Iffalse&gt;\n    struct conditional&lt;false, _Iftrue, _Iffalse&gt;\n    { typedef _Iffalse type; };\n\n  /// common_type\n  template&lt;typename... _Tp&gt;\n    struct common_type;\n\n  // Sfinae-friendly common_type implementation:\n\n  /// @cond undocumented\n\n  // For several sfinae-friendly trait implementations we transport both the\n  // result information (as the member type) and the failure information (no\n  // member type). This is very similar to std::enable_if, but we cannot use\n  // that, because we need to derive from them as an implementation detail.\n\n  template&lt;typename _Tp&gt;\n    struct __success_type\n    { typedef _Tp type; };\n\n  struct __failure_type\n  { };\n\n  struct __do_common_type_impl\n  {\n    template&lt;typename _Tp, typename _Up&gt;\n      using __cond_t\n\t= decltype(true ? std::declval&lt;_Tp&gt;() : std::declval&lt;_Up&gt;());\n\n    // if decay_t&lt;decltype(false ? declval&lt;D1&gt;() : declval&lt;D2&gt;())&gt;\n    // denotes a valid type, let C denote that type.\n    template&lt;typename _Tp, typename _Up&gt;\n      static __success_type&lt;__decay_t&lt;__cond_t&lt;_Tp, _Up&gt;&gt;&gt;\n      _S_test(int);\n\n#if __cplusplus &gt; 201703L\n    // Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type,\n    // let C denote the type decay_t&lt;COND-RES(CREF(D1), CREF(D2))&gt;.\n    template&lt;typename _Tp, typename _Up&gt;\n      static __success_type&lt;__remove_cvref_t&lt;__cond_t&lt;const _Tp&amp;, const _Up&amp;&gt;&gt;&gt;\n      _S_test_2(int);\n#endif\n\n    template&lt;typename, typename&gt;\n      static __failure_type\n      _S_test_2(...);\n\n    template&lt;typename _Tp, typename _Up&gt;\n      static decltype(_S_test_2&lt;_Tp, _Up&gt;(0))\n      _S_test(...);\n  };\n\n  // If sizeof...(T) is zero, there shall be no member type.\n  template&lt;&gt;\n    struct common_type&lt;&gt;\n    { };\n\n  // If sizeof...(T) is one, the same type, if any, as common_type_t&lt;T0, T0&gt;.\n  template&lt;typename _Tp0&gt;\n    struct common_type&lt;_Tp0&gt;\n    : public common_type&lt;_Tp0, _Tp0&gt;\n    { };\n\n  // If sizeof...(T) is two, ...\n  template&lt;typename _Tp1, typename _Tp2,\n\t   typename _Dp1 = __decay_t&lt;_Tp1&gt;, typename _Dp2 = __decay_t&lt;_Tp2&gt;&gt;\n    struct __common_type_impl\n    {\n      // If is_same_v&lt;T1, D1&gt; is false or is_same_v&lt;T2, D2&gt; is false,\n      // let C denote the same type, if any, as common_type_t&lt;D1, D2&gt;.\n      using type = common_type&lt;_Dp1, _Dp2&gt;;\n    };\n\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_type_impl&lt;_Tp1, _Tp2, _Tp1, _Tp2&gt;\n    : private __do_common_type_impl\n    {\n      // Otherwise, if decay_t&lt;decltype(false ? declval&lt;D1&gt;() : declval&lt;D2&gt;())&gt;\n      // denotes a valid type, let C denote that type.\n      using type = decltype(_S_test&lt;_Tp1, _Tp2&gt;(0));\n    };\n\n  // If sizeof...(T) is two, ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct common_type&lt;_Tp1, _Tp2&gt;\n    : public __common_type_impl&lt;_Tp1, _Tp2&gt;::type\n    { };\n\n  template&lt;typename...&gt;\n    struct __common_type_pack\n    { };\n\n  template&lt;typename, typename, typename = void&gt;\n    struct __common_type_fold;\n\n  // If sizeof...(T) is greater than two, ...\n  template&lt;typename _Tp1, typename _Tp2, typename... _Rp&gt;\n    struct common_type&lt;_Tp1, _Tp2, _Rp...&gt;\n    : public __common_type_fold&lt;common_type&lt;_Tp1, _Tp2&gt;,\n\t\t\t\t__common_type_pack&lt;_Rp...&gt;&gt;\n    { };\n\n  // Let C denote the same type, if any, as common_type_t&lt;T1, T2&gt;.\n  // If there is such a type C, type shall denote the same type, if any,\n  // as common_type_t&lt;C, R...&gt;.\n  template&lt;typename _CTp, typename... _Rp&gt;\n    struct __common_type_fold&lt;_CTp, __common_type_pack&lt;_Rp...&gt;,\n\t\t\t      __void_t&lt;typename _CTp::type&gt;&gt;\n    : public common_type&lt;typename _CTp::type, _Rp...&gt;\n    { };\n\n  // Otherwise, there shall be no member type.\n  template&lt;typename _CTp, typename _Rp&gt;\n    struct __common_type_fold&lt;_CTp, _Rp, void&gt;\n    { };\n\n  template&lt;typename _Tp, bool = is_enum&lt;_Tp&gt;::value&gt;\n    struct __underlying_type_impl\n    {\n      using type = __underlying_type(_Tp);\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __underlying_type_impl&lt;_Tp, false&gt;\n    { };\n  /// @endcond\n\n  /// The underlying type of an enum.\n  template&lt;typename _Tp&gt;\n    struct underlying_type\n    : public __underlying_type_impl&lt;_Tp&gt;\n    { };\n\n  /// @cond undocumented\n  template&lt;typename _Tp&gt;\n    struct __declval_protector\n    {\n      static const bool __stop = false;\n    };\n  /// @endcond\n\n  /** Utility to simplify expressions used in unevaluated operands\n   *  @since C++11\n   *  @ingroup utilities\n   */\n  template&lt;typename _Tp&gt;\n    auto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0))\n    {\n      static_assert(__declval_protector&lt;_Tp&gt;::__stop,\n\t\t    &quot;declval() must not be used!&quot;);\n      return __declval&lt;_Tp&gt;(0);\n    }\n\n  /// result_of\n  template&lt;typename _Signature&gt;\n    struct result_of;\n\n  // Sfinae-friendly result_of implementation:\n\n#define __cpp_lib_result_of_sfinae 201210L\n\n  /// @cond undocumented\n  struct __invoke_memfun_ref { };\n  struct __invoke_memfun_deref { };\n  struct __invoke_memobj_ref { };\n  struct __invoke_memobj_deref { };\n  struct __invoke_other { };\n\n  // Associate a tag type with a specialization of __success_type.\n  template&lt;typename _Tp, typename _Tag&gt;\n    struct __result_of_success : __success_type&lt;_Tp&gt;\n    { using __invoke_type = _Tag; };\n\n  // [func.require] paragraph 1 bullet 1:\n  struct __result_of_memfun_ref_impl\n  {\n    template&lt;typename _Fp, typename _Tp1, typename... _Args&gt;\n      static __result_of_success&lt;decltype(\n      (std::declval&lt;_Tp1&gt;().*std::declval&lt;_Fp&gt;())(std::declval&lt;_Args&gt;()...)\n      ), __invoke_memfun_ref&gt; _S_test(int);\n\n    template&lt;typename...&gt;\n      static __failure_type _S_test(...);\n  };\n\n  template&lt;typename _MemPtr, typename _Arg, typename... _Args&gt;\n    struct __result_of_memfun_ref\n    : private __result_of_memfun_ref_impl\n    {\n      typedef decltype(_S_test&lt;_MemPtr, _Arg, _Args...&gt;(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 2:\n  struct __result_of_memfun_deref_impl\n  {\n    template&lt;typename _Fp, typename _Tp1, typename... _Args&gt;\n      static __result_of_success&lt;decltype(\n      ((*std::declval&lt;_Tp1&gt;()).*std::declval&lt;_Fp&gt;())(std::declval&lt;_Args&gt;()...)\n      ), __invoke_memfun_deref&gt; _S_test(int);\n\n    template&lt;typename...&gt;\n      static __failure_type _S_test(...);\n  };\n\n  template&lt;typename _MemPtr, typename _Arg, typename... _Args&gt;\n    struct __result_of_memfun_deref\n    : private __result_of_memfun_deref_impl\n    {\n      typedef decltype(_S_test&lt;_MemPtr, _Arg, _Args...&gt;(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 3:\n  struct __result_of_memobj_ref_impl\n  {\n    template&lt;typename _Fp, typename _Tp1&gt;\n      static __result_of_success&lt;decltype(\n      std::declval&lt;_Tp1&gt;().*std::declval&lt;_Fp&gt;()\n      ), __invoke_memobj_ref&gt; _S_test(int);\n\n    template&lt;typename, typename&gt;\n      static __failure_type _S_test(...);\n  };\n\n  template&lt;typename _MemPtr, typename _Arg&gt;\n    struct __result_of_memobj_ref\n    : private __result_of_memobj_ref_impl\n    {\n      typedef decltype(_S_test&lt;_MemPtr, _Arg&gt;(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 4:\n  struct __result_of_memobj_deref_impl\n  {\n    template&lt;typename _Fp, typename _Tp1&gt;\n      static __result_of_success&lt;decltype(\n      (*std::declval&lt;_Tp1&gt;()).*std::declval&lt;_Fp&gt;()\n      ), __invoke_memobj_deref&gt; _S_test(int);\n\n    template&lt;typename, typename&gt;\n      static __failure_type _S_test(...);\n  };\n\n  template&lt;typename _MemPtr, typename _Arg&gt;\n    struct __result_of_memobj_deref\n    : private __result_of_memobj_deref_impl\n    {\n      typedef decltype(_S_test&lt;_MemPtr, _Arg&gt;(0)) type;\n    };\n\n  template&lt;typename _MemPtr, typename _Arg&gt;\n    struct __result_of_memobj;\n\n  template&lt;typename _Res, typename _Class, typename _Arg&gt;\n    struct __result_of_memobj&lt;_Res _Class::*, _Arg&gt;\n    {\n      typedef __remove_cvref_t&lt;_Arg&gt; _Argval;\n      typedef _Res _Class::* _MemPtr;\n      typedef typename __conditional_t&lt;__or_&lt;is_same&lt;_Argval, _Class&gt;,\n        is_base_of&lt;_Class, _Argval&gt;&gt;::value,\n        __result_of_memobj_ref&lt;_MemPtr, _Arg&gt;,\n        __result_of_memobj_deref&lt;_MemPtr, _Arg&gt;\n      &gt;::type type;\n    };\n\n  template&lt;typename _MemPtr, typename _Arg, typename... _Args&gt;\n    struct __result_of_memfun;\n\n  template&lt;typename _Res, typename _Class, typename _Arg, typename... _Args&gt;\n    struct __result_of_memfun&lt;_Res _Class::*, _Arg, _Args...&gt;\n    {\n      typedef typename remove_reference&lt;_Arg&gt;::type _Argval;\n      typedef _Res _Class::* _MemPtr;\n      typedef typename __conditional_t&lt;is_base_of&lt;_Class, _Argval&gt;::value,\n        __result_of_memfun_ref&lt;_MemPtr, _Arg, _Args...&gt;,\n        __result_of_memfun_deref&lt;_MemPtr, _Arg, _Args...&gt;\n      &gt;::type type;\n    };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2219.  INVOKE-ing a pointer to member with a reference_wrapper\n  //        as the object expression\n\n  // Used by result_of, invoke etc. to unwrap a reference_wrapper.\n  template&lt;typename _Tp, typename _Up = __remove_cvref_t&lt;_Tp&gt;&gt;\n    struct __inv_unwrap\n    {\n      using type = _Tp;\n    };\n\n  template&lt;typename _Tp, typename _Up&gt;\n    struct __inv_unwrap&lt;_Tp, reference_wrapper&lt;_Up&gt;&gt;\n    {\n      using type = _Up&amp;;\n    };\n\n  template&lt;bool, bool, typename _Functor, typename... _ArgTypes&gt;\n    struct __result_of_impl\n    {\n      typedef __failure_type type;\n    };\n\n  template&lt;typename _MemPtr, typename _Arg&gt;\n    struct __result_of_impl&lt;true, false, _MemPtr, _Arg&gt;\n    : public __result_of_memobj&lt;__decay_t&lt;_MemPtr&gt;,\n\t\t\t\ttypename __inv_unwrap&lt;_Arg&gt;::type&gt;\n    { };\n\n  template&lt;typename _MemPtr, typename _Arg, typename... _Args&gt;\n    struct __result_of_impl&lt;false, true, _MemPtr, _Arg, _Args...&gt;\n    : public __result_of_memfun&lt;__decay_t&lt;_MemPtr&gt;,\n\t\t\t\ttypename __inv_unwrap&lt;_Arg&gt;::type, _Args...&gt;\n    { };\n\n  // [func.require] paragraph 1 bullet 5:\n  struct __result_of_other_impl\n  {\n    template&lt;typename _Fn, typename... _Args&gt;\n      static __result_of_success&lt;decltype(\n      std::declval&lt;_Fn&gt;()(std::declval&lt;_Args&gt;()...)\n      ), __invoke_other&gt; _S_test(int);\n\n    template&lt;typename...&gt;\n      static __failure_type _S_test(...);\n  };\n\n  template&lt;typename _Functor, typename... _ArgTypes&gt;\n    struct __result_of_impl&lt;false, false, _Functor, _ArgTypes...&gt;\n    : private __result_of_other_impl\n    {\n      typedef decltype(_S_test&lt;_Functor, _ArgTypes...&gt;(0)) type;\n    };\n\n  // __invoke_result (std::invoke_result for C++11)\n  template&lt;typename _Functor, typename... _ArgTypes&gt;\n    struct __invoke_result\n    : public __result_of_impl&lt;\n        is_member_object_pointer&lt;\n          typename remove_reference&lt;_Functor&gt;::type\n        &gt;::value,\n        is_member_function_pointer&lt;\n          typename remove_reference&lt;_Functor&gt;::type\n        &gt;::value,\n\t_Functor, _ArgTypes...\n      &gt;::type\n    { };\n  /// @endcond\n\n  template&lt;typename _Functor, typename... _ArgTypes&gt;\n    struct result_of&lt;_Functor(_ArgTypes...)&gt;\n    : public __invoke_result&lt;_Functor, _ArgTypes...&gt;\n    { } _GLIBCXX17_DEPRECATED_SUGGEST(&quot;std::invoke_result&quot;);\n\n#if __cplusplus &gt;= 201402L\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  /// Alias template for aligned_storage\n  template&lt;size_t _Len, size_t _Align =\n\t    __alignof__(typename __aligned_storage_msa&lt;_Len&gt;::__type)&gt;\n    using aligned_storage_t _GLIBCXX23_DEPRECATED = typename aligned_storage&lt;_Len, _Align&gt;::type;\n\n  template &lt;size_t _Len, typename... _Types&gt;\n    using aligned_union_t _GLIBCXX23_DEPRECATED = typename aligned_union&lt;_Len, _Types...&gt;::type;\n#pragma GCC diagnostic pop\n\n  /// Alias template for decay\n  template&lt;typename _Tp&gt;\n    using decay_t = typename decay&lt;_Tp&gt;::type;\n\n  /// Alias template for enable_if\n  template&lt;bool _Cond, typename _Tp = void&gt;\n    using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n\n  /// Alias template for conditional\n  template&lt;bool _Cond, typename _Iftrue, typename _Iffalse&gt;\n    using conditional_t = typename conditional&lt;_Cond, _Iftrue, _Iffalse&gt;::type;\n\n  /// Alias template for common_type\n  template&lt;typename... _Tp&gt;\n    using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n\n  /// Alias template for underlying_type\n  template&lt;typename _Tp&gt;\n    using underlying_type_t = typename underlying_type&lt;_Tp&gt;::type;\n\n  /// Alias template for result_of\n  template&lt;typename _Tp&gt;\n    using result_of_t = typename result_of&lt;_Tp&gt;::type;\n#endif // C++14\n\n#if __cplusplus &gt;= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11\n#define __cpp_lib_void_t 201411L\n  /// A metafunction that always yields void, used for detecting valid types.\n  template&lt;typename...&gt; using void_t = void;\n#endif\n\n  /// @cond undocumented\n\n  // Detection idiom.\n  // Detect whether _Op&lt;_Args...&gt; is a valid type, use default _Def if not.\n\n#if __cpp_concepts\n  // Implementation of the detection idiom (negative case).\n  template&lt;typename _Def, template&lt;typename...&gt; class _Op, typename... _Args&gt;\n    struct __detected_or\n    {\n      using type = _Def;\n      using __is_detected = false_type;\n    };\n\n  // Implementation of the detection idiom (positive case).\n  template&lt;typename _Def, template&lt;typename...&gt; class _Op, typename... _Args&gt;\n    requires requires { typename _Op&lt;_Args...&gt;; }\n    struct __detected_or&lt;_Def, _Op, _Args...&gt;\n    {\n      using type = _Op&lt;_Args...&gt;;\n      using __is_detected = true_type;\n    };\n#else\n  /// Implementation of the detection idiom (negative case).\n  template&lt;typename _Default, typename _AlwaysVoid,\n\t   template&lt;typename...&gt; class _Op, typename... _Args&gt;\n    struct __detector\n    {\n      using type = _Default;\n      using __is_detected = false_type;\n    };\n\n  /// Implementation of the detection idiom (positive case).\n  template&lt;typename _Default, template&lt;typename...&gt; class _Op,\n\t    typename... _Args&gt;\n    struct __detector&lt;_Default, __void_t&lt;_Op&lt;_Args...&gt;&gt;, _Op, _Args...&gt;\n    {\n      using type = _Op&lt;_Args...&gt;;\n      using __is_detected = true_type;\n    };\n\n  template&lt;typename _Default, template&lt;typename...&gt; class _Op,\n\t   typename... _Args&gt;\n    using __detected_or = __detector&lt;_Default, void, _Op, _Args...&gt;;\n#endif // __cpp_concepts\n\n  // _Op&lt;_Args...&gt; if that is a valid type, otherwise _Default.\n  template&lt;typename _Default, template&lt;typename...&gt; class _Op,\n\t   typename... _Args&gt;\n    using __detected_or_t\n      = typename __detected_or&lt;_Default, _Op, _Args...&gt;::type;\n\n  /**\n   *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n   *  member type _NTYPE.\n   */\n#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)\t\t\t\t\\\n  template&lt;typename _Tp, typename = __void_t&lt;&gt;&gt;\t\t\t\t\\\n    struct __has_##_NTYPE\t\t\t\t\t\t\\\n    : false_type\t\t\t\t\t\t\t\\\n    { };\t\t\t\t\t\t\t\t\\\n  template&lt;typename _Tp&gt;\t\t\t\t\t\t\\\n    struct __has_##_NTYPE&lt;_Tp, __void_t&lt;typename _Tp::_NTYPE&gt;&gt;\t\t\\\n    : true_type\t\t\t\t\t\t\t\t\\\n    { };\n\n  template &lt;typename _Tp&gt;\n    struct __is_swappable;\n\n  template &lt;typename _Tp&gt;\n    struct __is_nothrow_swappable;\n\n  template&lt;typename&gt;\n    struct __is_tuple_like_impl : false_type\n    { };\n\n  // Internal type trait that allows us to sfinae-protect tuple_cat.\n  template&lt;typename _Tp&gt;\n    struct __is_tuple_like\n    : public __is_tuple_like_impl&lt;__remove_cvref_t&lt;_Tp&gt;&gt;::type\n    { };\n  /// @endcond\n\n  template&lt;typename _Tp&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline\n    _Require&lt;__not_&lt;__is_tuple_like&lt;_Tp&gt;&gt;,\n\t     is_move_constructible&lt;_Tp&gt;,\n\t     is_move_assignable&lt;_Tp&gt;&gt;\n    swap(_Tp&amp;, _Tp&amp;)\n    noexcept(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,\n\t            is_nothrow_move_assignable&lt;_Tp&gt;&gt;::value);\n\n  template&lt;typename _Tp, size_t _Nm&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline\n    __enable_if_t&lt;__is_swappable&lt;_Tp&gt;::value&gt;\n    swap(_Tp (&amp;__a)[_Nm], _Tp (&amp;__b)[_Nm])\n    noexcept(__is_nothrow_swappable&lt;_Tp&gt;::value);\n\n  /// @cond undocumented\n  namespace __swappable_details {\n    using std::swap;\n\n    struct __do_is_swappable_impl\n    {\n      template&lt;typename _Tp, typename\n               = decltype(swap(std::declval&lt;_Tp&amp;&gt;(), std::declval&lt;_Tp&amp;&gt;()))&gt;\n        static true_type __test(int);\n\n      template&lt;typename&gt;\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_impl\n    {\n      template&lt;typename _Tp&gt;\n        static __bool_constant&lt;\n          noexcept(swap(std::declval&lt;_Tp&amp;&gt;(), std::declval&lt;_Tp&amp;&gt;()))\n        &gt; __test(int);\n\n      template&lt;typename&gt;\n        static false_type __test(...);\n    };\n\n  } // namespace __swappable_details\n\n  template&lt;typename _Tp&gt;\n    struct __is_swappable_impl\n    : public __swappable_details::__do_is_swappable_impl\n    {\n      typedef decltype(__test&lt;_Tp&gt;(0)) type;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __is_nothrow_swappable_impl\n    : public __swappable_details::__do_is_nothrow_swappable_impl\n    {\n      typedef decltype(__test&lt;_Tp&gt;(0)) type;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __is_swappable\n    : public __is_swappable_impl&lt;_Tp&gt;::type\n    { };\n\n  template&lt;typename _Tp&gt;\n    struct __is_nothrow_swappable\n    : public __is_nothrow_swappable_impl&lt;_Tp&gt;::type\n    { };\n  /// @endcond\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_is_swappable 201603L\n  /// Metafunctions used for detecting swappable types: p0185r1\n\n  /// is_swappable\n  template&lt;typename _Tp&gt;\n    struct is_swappable\n    : public __is_swappable_impl&lt;_Tp&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_swappable\n  template&lt;typename _Tp&gt;\n    struct is_nothrow_swappable\n    : public __is_nothrow_swappable_impl&lt;_Tp&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n#if __cplusplus &gt;= 201402L\n  /// is_swappable_v\n  template&lt;typename _Tp&gt;\n    _GLIBCXX17_INLINE constexpr bool is_swappable_v =\n      is_swappable&lt;_Tp&gt;::value;\n\n  /// is_nothrow_swappable_v\n  template&lt;typename _Tp&gt;\n    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_v =\n      is_nothrow_swappable&lt;_Tp&gt;::value;\n#endif // __cplusplus &gt;= 201402L\n\n  /// @cond undocumented\n  namespace __swappable_with_details {\n    using std::swap;\n\n    struct __do_is_swappable_with_impl\n    {\n      template&lt;typename _Tp, typename _Up, typename\n               = decltype(swap(std::declval&lt;_Tp&gt;(), std::declval&lt;_Up&gt;())),\n               typename\n               = decltype(swap(std::declval&lt;_Up&gt;(), std::declval&lt;_Tp&gt;()))&gt;\n        static true_type __test(int);\n\n      template&lt;typename, typename&gt;\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_with_impl\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n        static __bool_constant&lt;\n          noexcept(swap(std::declval&lt;_Tp&gt;(), std::declval&lt;_Up&gt;()))\n          &amp;&amp;\n          noexcept(swap(std::declval&lt;_Up&gt;(), std::declval&lt;_Tp&gt;()))\n        &gt; __test(int);\n\n      template&lt;typename, typename&gt;\n        static false_type __test(...);\n    };\n\n  } // namespace __swappable_with_details\n\n  template&lt;typename _Tp, typename _Up&gt;\n    struct __is_swappable_with_impl\n    : public __swappable_with_details::__do_is_swappable_with_impl\n    {\n      typedef decltype(__test&lt;_Tp, _Up&gt;(0)) type;\n    };\n\n  // Optimization for the homogenous lvalue case, not required:\n  template&lt;typename _Tp&gt;\n    struct __is_swappable_with_impl&lt;_Tp&amp;, _Tp&amp;&gt;\n    : public __swappable_details::__do_is_swappable_impl\n    {\n      typedef decltype(__test&lt;_Tp&amp;&gt;(0)) type;\n    };\n\n  template&lt;typename _Tp, typename _Up&gt;\n    struct __is_nothrow_swappable_with_impl\n    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl\n    {\n      typedef decltype(__test&lt;_Tp, _Up&gt;(0)) type;\n    };\n\n  // Optimization for the homogenous lvalue case, not required:\n  template&lt;typename _Tp&gt;\n    struct __is_nothrow_swappable_with_impl&lt;_Tp&amp;, _Tp&amp;&gt;\n    : public __swappable_details::__do_is_nothrow_swappable_impl\n    {\n      typedef decltype(__test&lt;_Tp&amp;&gt;(0)) type;\n    };\n  /// @endcond\n\n  /// is_swappable_with\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_swappable_with\n    : public __is_swappable_with_impl&lt;_Tp, _Up&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;first template argument must be a complete class or an unbounded array&quot;);\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Up&gt;{}),\n\t&quot;second template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// is_nothrow_swappable_with\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_nothrow_swappable_with\n    : public __is_nothrow_swappable_with_impl&lt;_Tp, _Up&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;first template argument must be a complete class or an unbounded array&quot;);\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Up&gt;{}),\n\t&quot;second template argument must be a complete class or an unbounded array&quot;);\n    };\n\n#if __cplusplus &gt;= 201402L\n  /// is_swappable_with_v\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX17_INLINE constexpr bool is_swappable_with_v =\n      is_swappable_with&lt;_Tp, _Up&gt;::value;\n\n  /// is_nothrow_swappable_with_v\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_with_v =\n      is_nothrow_swappable_with&lt;_Tp, _Up&gt;::value;\n#endif // __cplusplus &gt;= 201402L\n\n#endif// c++1z or gnu++11\n\n  /// @cond undocumented\n\n  // __is_invocable (std::is_invocable for C++11)\n\n  // The primary template is used for invalid INVOKE expressions.\n  template&lt;typename _Result, typename _Ret,\n\t   bool = is_void&lt;_Ret&gt;::value, typename = void&gt;\n    struct __is_invocable_impl\n    : false_type\n    {\n      using __nothrow_conv = false_type; // For is_nothrow_invocable_r\n    };\n\n  // Used for valid INVOKE and INVOKE&lt;void&gt; expressions.\n  template&lt;typename _Result, typename _Ret&gt;\n    struct __is_invocable_impl&lt;_Result, _Ret,\n\t\t\t       /* is_void&lt;_Ret&gt; = */ true,\n\t\t\t       __void_t&lt;typename _Result::type&gt;&gt;\n    : true_type\n    {\n      using __nothrow_conv = true_type; // For is_nothrow_invocable_r\n    };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wctor-dtor-privacy&quot;\n  // Used for INVOKE&lt;R&gt; expressions to check the implicit conversion to R.\n  template&lt;typename _Result, typename _Ret&gt;\n    struct __is_invocable_impl&lt;_Result, _Ret,\n\t\t\t       /* is_void&lt;_Ret&gt; = */ false,\n\t\t\t       __void_t&lt;typename _Result::type&gt;&gt;\n    {\n    private:\n      // The type of the INVOKE expression.\n      using _Res_t = typename _Result::type;\n\n      // Unlike declval, this doesn&#x27;t add_rvalue_reference, so it respects\n      // guaranteed copy elision.\n      static _Res_t _S_get() noexcept;\n\n      // Used to check if _Res_t can implicitly convert to _Tp.\n      template&lt;typename _Tp&gt;\n\tstatic void _S_conv(__type_identity_t&lt;_Tp&gt;) noexcept;\n\n      // This overload is viable if INVOKE(f, args...) can convert to _Tp.\n      template&lt;typename _Tp,\n\t       bool _Nothrow = noexcept(_S_conv&lt;_Tp&gt;(_S_get())),\n\t       typename = decltype(_S_conv&lt;_Tp&gt;(_S_get())),\n#if __has_builtin(__reference_converts_from_temporary)\n\t       bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)\n#else\n\t       bool _Dangle = false\n#endif\n\t      &gt;\n\tstatic __bool_constant&lt;_Nothrow &amp;&amp; !_Dangle&gt;\n\t_S_test(int);\n\n      template&lt;typename _Tp, bool = false&gt;\n\tstatic false_type\n\t_S_test(...);\n\n    public:\n      // For is_invocable_r\n      using type = decltype(_S_test&lt;_Ret, /* Nothrow = */ true&gt;(1));\n\n      // For is_nothrow_invocable_r\n      using __nothrow_conv = decltype(_S_test&lt;_Ret&gt;(1));\n    };\n#pragma GCC diagnostic pop\n\n  template&lt;typename _Fn, typename... _ArgTypes&gt;\n    struct __is_invocable\n    : __is_invocable_impl&lt;__invoke_result&lt;_Fn, _ArgTypes...&gt;, void&gt;::type\n    { };\n\n  template&lt;typename _Fn, typename _Tp, typename... _Args&gt;\n    constexpr bool __call_is_nt(__invoke_memfun_ref)\n    {\n      using _Up = typename __inv_unwrap&lt;_Tp&gt;::type;\n      return noexcept((std::declval&lt;_Up&gt;().*std::declval&lt;_Fn&gt;())(\n\t    std::declval&lt;_Args&gt;()...));\n    }\n\n  template&lt;typename _Fn, typename _Tp, typename... _Args&gt;\n    constexpr bool __call_is_nt(__invoke_memfun_deref)\n    {\n      return noexcept(((*std::declval&lt;_Tp&gt;()).*std::declval&lt;_Fn&gt;())(\n\t    std::declval&lt;_Args&gt;()...));\n    }\n\n  template&lt;typename _Fn, typename _Tp&gt;\n    constexpr bool __call_is_nt(__invoke_memobj_ref)\n    {\n      using _Up = typename __inv_unwrap&lt;_Tp&gt;::type;\n      return noexcept(std::declval&lt;_Up&gt;().*std::declval&lt;_Fn&gt;());\n    }\n\n  template&lt;typename _Fn, typename _Tp&gt;\n    constexpr bool __call_is_nt(__invoke_memobj_deref)\n    {\n      return noexcept((*std::declval&lt;_Tp&gt;()).*std::declval&lt;_Fn&gt;());\n    }\n\n  template&lt;typename _Fn, typename... _Args&gt;\n    constexpr bool __call_is_nt(__invoke_other)\n    {\n      return noexcept(std::declval&lt;_Fn&gt;()(std::declval&lt;_Args&gt;()...));\n    }\n\n  template&lt;typename _Result, typename _Fn, typename... _Args&gt;\n    struct __call_is_nothrow\n    : __bool_constant&lt;\n\tstd::__call_is_nt&lt;_Fn, _Args...&gt;(typename _Result::__invoke_type{})\n      &gt;\n    { };\n\n  template&lt;typename _Fn, typename... _Args&gt;\n    using __call_is_nothrow_\n      = __call_is_nothrow&lt;__invoke_result&lt;_Fn, _Args...&gt;, _Fn, _Args...&gt;;\n\n  // __is_nothrow_invocable (std::is_nothrow_invocable for C++11)\n  template&lt;typename _Fn, typename... _Args&gt;\n    struct __is_nothrow_invocable\n    : __and_&lt;__is_invocable&lt;_Fn, _Args...&gt;,\n             __call_is_nothrow_&lt;_Fn, _Args...&gt;&gt;::type\n    { };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wctor-dtor-privacy&quot;\n  struct __nonesuchbase {};\n  struct __nonesuch : private __nonesuchbase {\n    ~__nonesuch() = delete;\n    __nonesuch(__nonesuch const&amp;) = delete;\n    void operator=(__nonesuch const&amp;) = delete;\n  };\n#pragma GCC diagnostic pop\n  /// @endcond\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_is_invocable 201703L\n\n  /// std::invoke_result\n  template&lt;typename _Functor, typename... _ArgTypes&gt;\n    struct invoke_result\n    : public __invoke_result&lt;_Functor, _ArgTypes...&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Functor&gt;{}),\n\t&quot;_Functor must be a complete class or an unbounded array&quot;);\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity&lt;_ArgTypes&gt;{}) &amp;&amp; ...),\n\t&quot;each argument type must be a complete class or an unbounded array&quot;);\n    };\n\n  /// std::invoke_result_t\n  template&lt;typename _Fn, typename... _Args&gt;\n    using invoke_result_t = typename invoke_result&lt;_Fn, _Args...&gt;::type;\n\n  /// std::is_invocable\n  template&lt;typename _Fn, typename... _ArgTypes&gt;\n    struct is_invocable\n    : __is_invocable_impl&lt;__invoke_result&lt;_Fn, _ArgTypes...&gt;, void&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Fn&gt;{}),\n\t&quot;_Fn must be a complete class or an unbounded array&quot;);\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity&lt;_ArgTypes&gt;{}) &amp;&amp; ...),\n\t&quot;each argument type must be a complete class or an unbounded array&quot;);\n    };\n\n  /// std::is_invocable_r\n  template&lt;typename _Ret, typename _Fn, typename... _ArgTypes&gt;\n    struct is_invocable_r\n    : __is_invocable_impl&lt;__invoke_result&lt;_Fn, _ArgTypes...&gt;, _Ret&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Fn&gt;{}),\n\t&quot;_Fn must be a complete class or an unbounded array&quot;);\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity&lt;_ArgTypes&gt;{}) &amp;&amp; ...),\n\t&quot;each argument type must be a complete class or an unbounded array&quot;);\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Ret&gt;{}),\n\t&quot;_Ret must be a complete class or an unbounded array&quot;);\n    };\n\n  /// std::is_nothrow_invocable\n  template&lt;typename _Fn, typename... _ArgTypes&gt;\n    struct is_nothrow_invocable\n    : __and_&lt;__is_invocable_impl&lt;__invoke_result&lt;_Fn, _ArgTypes...&gt;, void&gt;,\n\t     __call_is_nothrow_&lt;_Fn, _ArgTypes...&gt;&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Fn&gt;{}),\n\t&quot;_Fn must be a complete class or an unbounded array&quot;);\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity&lt;_ArgTypes&gt;{}) &amp;&amp; ...),\n\t&quot;each argument type must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @cond undocumented\n  // This checks that the INVOKE&lt;R&gt; expression is well-formed and that the\n  // conversion to R does not throw. It does *not* check whether the INVOKE\n  // expression itself can throw. That is done by __call_is_nothrow_ instead.\n  template&lt;typename _Result, typename _Ret&gt;\n    using __is_nt_invocable_impl\n      = typename __is_invocable_impl&lt;_Result, _Ret&gt;::__nothrow_conv;\n  /// @endcond\n\n  /// std::is_nothrow_invocable_r\n  template&lt;typename _Ret, typename _Fn, typename... _ArgTypes&gt;\n    struct is_nothrow_invocable_r\n    : __and_&lt;__is_nt_invocable_impl&lt;__invoke_result&lt;_Fn, _ArgTypes...&gt;, _Ret&gt;,\n             __call_is_nothrow_&lt;_Fn, _ArgTypes...&gt;&gt;::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Fn&gt;{}),\n\t&quot;_Fn must be a complete class or an unbounded array&quot;);\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity&lt;_ArgTypes&gt;{}) &amp;&amp; ...),\n\t&quot;each argument type must be a complete class or an unbounded array&quot;);\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Ret&gt;{}),\n\t&quot;_Ret must be a complete class or an unbounded array&quot;);\n    };\n#endif // C++17\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_type_trait_variable_templates 201510L\n  /**\n   * @defgroup variable_templates Variable templates for type traits\n   * @ingroup metaprogramming\n   *\n   * Each variable `is_xxx_v&lt;T&gt;` is a boolean constant with the same value\n   * as the `value` member of the corresponding type trait `is_xxx&lt;T&gt;`.\n   *\n   * @since C++17 unless noted otherwise.\n   */\n\n  /**\n   * @{\n   * @ingroup variable_templates\n   */\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_void_v = is_void&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_null_pointer_v = is_null_pointer&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_integral_v = is_integral&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_floating_point_v = is_floating_point&lt;_Tp&gt;::value;\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_array_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_array_v&lt;_Tp[]&gt; = true;\ntemplate &lt;typename _Tp, size_t _Num&gt;\n  inline constexpr bool is_array_v&lt;_Tp[_Num]&gt; = true;\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_pointer_v = is_pointer&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_lvalue_reference_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_lvalue_reference_v&lt;_Tp&amp;&gt; = true;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_rvalue_reference_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_rvalue_reference_v&lt;_Tp&amp;&amp;&gt; = true;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_member_object_pointer_v =\n    is_member_object_pointer&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_member_function_pointer_v =\n    is_member_function_pointer&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_enum_v = __is_enum(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_union_v = __is_union(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_class_v = __is_class(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_function_v = is_function&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_reference_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_reference_v&lt;_Tp&amp;&gt; = true;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_reference_v&lt;_Tp&amp;&amp;&gt; = true;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_arithmetic_v = is_arithmetic&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_fundamental_v = is_fundamental&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_object_v = is_object&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_scalar_v = is_scalar&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_compound_v = is_compound&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_member_pointer_v = is_member_pointer&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_const_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_const_v&lt;const _Tp&gt; = true;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_volatile_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_volatile_v&lt;volatile _Tp&gt; = true;\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivial_v = __is_trivial(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);\ntemplate &lt;typename _Tp&gt;\n  _GLIBCXX20_DEPRECATED_SUGGEST(&quot;is_standard_layout_v &amp;&amp; is_trivial_v&quot;)\n  inline constexpr bool is_pod_v = __is_pod(_Tp);\ntemplate &lt;typename _Tp&gt;\n  _GLIBCXX17_DEPRECATED\n  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_empty_v = __is_empty(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_abstract_v = __is_abstract(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_final_v = __is_final(_Tp);\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_signed_v = is_signed&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_unsigned_v = is_unsigned&lt;_Tp&gt;::value;\n\ntemplate &lt;typename _Tp, typename... _Args&gt;\n  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_copy_constructible_v\n    = __is_constructible(_Tp, __add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_move_constructible_v\n    = __is_constructible(_Tp, __add_rval_ref_t&lt;_Tp&gt;);\n\ntemplate &lt;typename _Tp, typename _Up&gt;\n  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_copy_assignable_v\n    = __is_assignable(__add_lval_ref_t&lt;_Tp&gt;, __add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_move_assignable_v\n    = __is_assignable(__add_lval_ref_t&lt;_Tp&gt;, __add_rval_ref_t&lt;_Tp&gt;);\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_destructible_v = is_destructible&lt;_Tp&gt;::value;\n\ntemplate &lt;typename _Tp, typename... _Args&gt;\n  inline constexpr bool is_trivially_constructible_v\n    = __is_trivially_constructible(_Tp, _Args...);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_default_constructible_v\n    = __is_trivially_constructible(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_copy_constructible_v\n    = __is_trivially_constructible(_Tp, __add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_move_constructible_v\n    = __is_trivially_constructible(_Tp, __add_rval_ref_t&lt;_Tp&gt;);\n\ntemplate &lt;typename _Tp, typename _Up&gt;\n  inline constexpr bool is_trivially_assignable_v\n    = __is_trivially_assignable(_Tp, _Up);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_copy_assignable_v\n    = __is_trivially_assignable(__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t__add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_move_assignable_v\n    = __is_trivially_assignable(__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t\t__add_rval_ref_t&lt;_Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_trivially_destructible_v =\n    is_trivially_destructible&lt;_Tp&gt;::value;\ntemplate &lt;typename _Tp, typename... _Args&gt;\n  inline constexpr bool is_nothrow_constructible_v\n    = __is_nothrow_constructible(_Tp, _Args...);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_default_constructible_v\n    = __is_nothrow_constructible(_Tp);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_copy_constructible_v\n    = __is_nothrow_constructible(_Tp, __add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_move_constructible_v\n    = __is_nothrow_constructible(_Tp, __add_rval_ref_t&lt;_Tp&gt;);\n\ntemplate &lt;typename _Tp, typename _Up&gt;\n  inline constexpr bool is_nothrow_assignable_v\n    = __is_nothrow_assignable(_Tp, _Up);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_copy_assignable_v\n    = __is_nothrow_assignable(__add_lval_ref_t&lt;_Tp&gt;,\n\t\t\t      __add_lval_ref_t&lt;const _Tp&gt;);\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_move_assignable_v\n    = __is_nothrow_assignable(__add_lval_ref_t&lt;_Tp&gt;, __add_rval_ref_t&lt;_Tp&gt;);\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_nothrow_destructible_v =\n    is_nothrow_destructible&lt;_Tp&gt;::value;\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool has_virtual_destructor_v\n    = __has_virtual_destructor(_Tp);\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr size_t alignment_of_v = alignment_of&lt;_Tp&gt;::value;\n\ntemplate &lt;typename _Tp&gt;\n  inline constexpr size_t rank_v = 0;\ntemplate &lt;typename _Tp, size_t _Size&gt;\n  inline constexpr size_t rank_v&lt;_Tp[_Size]&gt; = 1 + rank_v&lt;_Tp&gt;;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr size_t rank_v&lt;_Tp[]&gt; = 1 + rank_v&lt;_Tp&gt;;\n\ntemplate &lt;typename _Tp, unsigned _Idx = 0&gt;\n  inline constexpr size_t extent_v = 0;\ntemplate &lt;typename _Tp, size_t _Size&gt;\n  inline constexpr size_t extent_v&lt;_Tp[_Size], 0&gt; = _Size;\ntemplate &lt;typename _Tp, unsigned _Idx, size_t _Size&gt;\n  inline constexpr size_t extent_v&lt;_Tp[_Size], _Idx&gt; = extent_v&lt;_Tp, _Idx - 1&gt;;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr size_t extent_v&lt;_Tp[], 0&gt; = 0;\ntemplate &lt;typename _Tp, unsigned _Idx&gt;\n  inline constexpr size_t extent_v&lt;_Tp[], _Idx&gt; = extent_v&lt;_Tp, _Idx - 1&gt;;\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME\ntemplate &lt;typename _Tp, typename _Up&gt;\n  inline constexpr bool is_same_v = __is_same(_Tp, _Up);\n#else\ntemplate &lt;typename _Tp, typename _Up&gt;\n  inline constexpr bool is_same_v = false;\ntemplate &lt;typename _Tp&gt;\n  inline constexpr bool is_same_v&lt;_Tp, _Tp&gt; = true;\n#endif\ntemplate &lt;typename _Base, typename _Derived&gt;\n  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);\n#if __has_builtin(__is_convertible)\ntemplate &lt;typename _From, typename _To&gt;\n  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);\n#else\ntemplate &lt;typename _From, typename _To&gt;\n  inline constexpr bool is_convertible_v = is_convertible&lt;_From, _To&gt;::value;\n#endif\ntemplate&lt;typename _Fn, typename... _Args&gt;\n  inline constexpr bool is_invocable_v = is_invocable&lt;_Fn, _Args...&gt;::value;\ntemplate&lt;typename _Fn, typename... _Args&gt;\n  inline constexpr bool is_nothrow_invocable_v\n    = is_nothrow_invocable&lt;_Fn, _Args...&gt;::value;\ntemplate&lt;typename _Ret, typename _Fn, typename... _Args&gt;\n  inline constexpr bool is_invocable_r_v\n    = is_invocable_r&lt;_Ret, _Fn, _Args...&gt;::value;\ntemplate&lt;typename _Ret, typename _Fn, typename... _Args&gt;\n  inline constexpr bool is_nothrow_invocable_r_v\n    = is_nothrow_invocable_r&lt;_Ret, _Fn, _Args...&gt;::value;\n/// @}\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP\n# define __cpp_lib_has_unique_object_representations 201606L\n  /// has_unique_object_representations\n  /// @since C++17\n  template&lt;typename _Tp&gt;\n    struct has_unique_object_representations\n    : bool_constant&lt;__has_unique_object_representations(\n      remove_cv_t&lt;remove_all_extents_t&lt;_Tp&gt;&gt;\n      )&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @ingroup variable_templates\n  template&lt;typename _Tp&gt;\n    inline constexpr bool has_unique_object_representations_v\n      = has_unique_object_representations&lt;_Tp&gt;::value;\n#endif\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE\n# define __cpp_lib_is_aggregate 201703L\n  /// is_aggregate - true if the type is an aggregate.\n  /// @since C++17\n  template&lt;typename _Tp&gt;\n    struct is_aggregate\n    : bool_constant&lt;__is_aggregate(remove_cv_t&lt;_Tp&gt;)&gt;\n    { };\n\n  /** is_aggregate_v - true if the type is an aggregate.\n   *  @ingroup variable_templates\n   *  @since C++17\n   */\n  template&lt;typename _Tp&gt;\n    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t&lt;_Tp&gt;);\n#endif\n#endif // C++17\n\n#if __cplusplus &gt;= 202002L\n\n  /** * Remove references and cv-qualifiers.\n   * @since C++20\n   * @{\n   */\n#define __cpp_lib_remove_cvref 201711L\n\n#if __has_builtin(__remove_cvref)\n  template&lt;typename _Tp&gt;\n    struct remove_cvref\n    { using type = __remove_cvref(_Tp); };\n#else\n  template&lt;typename _Tp&gt;\n    struct remove_cvref\n    { using type = typename remove_cv&lt;_Tp&gt;::type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_cvref&lt;_Tp&amp;&gt;\n    { using type = typename remove_cv&lt;_Tp&gt;::type; };\n\n  template&lt;typename _Tp&gt;\n    struct remove_cvref&lt;_Tp&amp;&amp;&gt;\n    { using type = typename remove_cv&lt;_Tp&gt;::type; };\n#endif\n\n  template&lt;typename _Tp&gt;\n    using remove_cvref_t = typename remove_cvref&lt;_Tp&gt;::type;\n  /// @}\n\n  /** * Identity metafunction.\n   * @since C++20\n   * @{\n   */\n#define __cpp_lib_type_identity 201806L\n  template&lt;typename _Tp&gt;\n    struct type_identity { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    using type_identity_t = typename type_identity&lt;_Tp&gt;::type;\n  /// @}\n\n#define __cpp_lib_unwrap_ref 201811L\n\n  /** Unwrap a reference_wrapper\n   * @since C++20\n   * @{\n   */\n  template&lt;typename _Tp&gt;\n    struct unwrap_reference { using type = _Tp; };\n\n  template&lt;typename _Tp&gt;\n    struct unwrap_reference&lt;reference_wrapper&lt;_Tp&gt;&gt; { using type = _Tp&amp;; };\n\n  template&lt;typename _Tp&gt;\n    using unwrap_reference_t = typename unwrap_reference&lt;_Tp&gt;::type;\n  /// @}\n\n  /** Decay type and if it&#x27;s a reference_wrapper, unwrap it\n   * @since C++20\n   * @{\n   */\n  template&lt;typename _Tp&gt;\n    struct unwrap_ref_decay { using type = unwrap_reference_t&lt;decay_t&lt;_Tp&gt;&gt;; };\n\n  template&lt;typename _Tp&gt;\n    using unwrap_ref_decay_t = typename unwrap_ref_decay&lt;_Tp&gt;::type;\n  /// @}\n\n#define __cpp_lib_bounded_array_traits 201902L\n\n  /// True for a type that is an array of known bound.\n  /// @ingroup variable_templates\n  /// @since C++20\n  template&lt;typename _Tp&gt;\n    inline constexpr bool is_bounded_array_v = false;\n\n  template&lt;typename _Tp, size_t _Size&gt;\n    inline constexpr bool is_bounded_array_v&lt;_Tp[_Size]&gt; = true;\n\n  /// True for a type that is an array of unknown bound.\n  /// @ingroup variable_templates\n  /// @since C++20\n  template&lt;typename _Tp&gt;\n    inline constexpr bool is_unbounded_array_v = false;\n\n  template&lt;typename _Tp&gt;\n    inline constexpr bool is_unbounded_array_v&lt;_Tp[]&gt; = true;\n\n  /// True for a type that is an array of known bound.\n  /// @since C++20\n  template&lt;typename _Tp&gt;\n    struct is_bounded_array\n    : public bool_constant&lt;is_bounded_array_v&lt;_Tp&gt;&gt;\n    { };\n\n  /// True for a type that is an array of unknown bound.\n  /// @since C++20\n  template&lt;typename _Tp&gt;\n    struct is_unbounded_array\n    : public bool_constant&lt;is_unbounded_array_v&lt;_Tp&gt;&gt;\n    { };\n\n#if __has_builtin(__is_layout_compatible)\n\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    struct is_layout_compatible\n    : bool_constant&lt;__is_layout_compatible(_Tp, _Up)&gt;\n    { };\n\n  /// @ingroup variable_templates\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr bool is_layout_compatible_v\n      = __is_layout_compatible(_Tp, _Up);\n\n#if __has_builtin(__builtin_is_corresponding_member)\n#define __cpp_lib_is_layout_compatible 201907L\n\n  /// @since C++20\n  template&lt;typename _S1, typename _S2, typename _M1, typename _M2&gt;\n    constexpr bool\n    is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept\n    { return __builtin_is_corresponding_member(__m1, __m2); }\n#endif\n#endif\n\n#if __has_builtin(__is_pointer_interconvertible_base_of)\n  /// True if `_Derived` is standard-layout and has a base class of type `_Base`\n  /// @since C++20\n  template&lt;typename _Base, typename _Derived&gt;\n    struct is_pointer_interconvertible_base_of\n    : bool_constant&lt;__is_pointer_interconvertible_base_of(_Base, _Derived)&gt;\n    { };\n\n  /// @ingroup variable_templates\n  /// @since C++20\n  template&lt;typename _Base, typename _Derived&gt;\n    constexpr bool is_pointer_interconvertible_base_of_v\n      = __is_pointer_interconvertible_base_of(_Base, _Derived);\n\n#if __has_builtin(__builtin_is_pointer_interconvertible_with_class)\n#define __cpp_lib_is_pointer_interconvertible 201907L\n\n  /// True if `__mp` points to the first member of a standard-layout type\n  /// @returns true if `s.*__mp` is pointer-interconvertible with `s`\n  /// @since C++20\n  template&lt;typename _Tp, typename _Mem&gt;\n    constexpr bool\n    is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept\n    { return __builtin_is_pointer_interconvertible_with_class(__mp); }\n#endif\n#endif\n\n#if __cplusplus &gt; 202002L\n#define __cpp_lib_is_scoped_enum 202011L\n\n  /// True if the type is a scoped enumeration type.\n  /// @since C++23\n\n  template&lt;typename _Tp&gt;\n    struct is_scoped_enum\n    : false_type\n    { };\n\n  template&lt;typename _Tp&gt;\n    requires __is_enum(_Tp)\n    &amp;&amp; requires(remove_cv_t&lt;_Tp&gt; __t) { __t = __t; } // fails if incomplete\n    struct is_scoped_enum&lt;_Tp&gt;\n    : bool_constant&lt;!requires(_Tp __t, void(*__f)(int)) { __f(__t); }&gt;\n    { };\n\n  /// @ingroup variable_templates\n  /// @since C++23\n  template&lt;typename _Tp&gt;\n    inline constexpr bool is_scoped_enum_v = is_scoped_enum&lt;_Tp&gt;::value;\n\n#if __has_builtin(__reference_constructs_from_temporary) \\\n  &amp;&amp; __has_builtin(__reference_converts_from_temporary)\n\n#define __cpp_lib_reference_from_temporary 202202L\n\n  /// True if _Tp is a reference type, a _Up value can be bound to _Tp in\n  /// direct-initialization, and a temporary object would be bound to\n  /// the reference, false otherwise.\n  /// @since C++23\n  template&lt;typename _Tp, typename _Up&gt;\n    struct reference_constructs_from_temporary\n    : public bool_constant&lt;__reference_constructs_from_temporary(_Tp, _Up)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{})\n\t\t    &amp;&amp; std::__is_complete_or_unbounded(__type_identity&lt;_Up&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// True if _Tp is a reference type, a _Up value can be bound to _Tp in\n  /// copy-initialization, and a temporary object would be bound to\n  /// the reference, false otherwise.\n  /// @since C++23\n  template&lt;typename _Tp, typename _Up&gt;\n    struct reference_converts_from_temporary\n    : public bool_constant&lt;__reference_converts_from_temporary(_Tp, _Up)&gt;\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;{})\n\t\t    &amp;&amp; std::__is_complete_or_unbounded(__type_identity&lt;_Up&gt;{}),\n\t&quot;template argument must be a complete class or an unbounded array&quot;);\n    };\n\n  /// @ingroup variable_templates\n  /// @since C++23\n  template&lt;typename _Tp, typename _Up&gt;\n    inline constexpr bool reference_constructs_from_temporary_v\n      = reference_constructs_from_temporary&lt;_Tp, _Up&gt;::value;\n\n  /// @ingroup variable_templates\n  /// @since C++23\n  template&lt;typename _Tp, typename _Up&gt;\n    inline constexpr bool reference_converts_from_temporary_v\n      = reference_converts_from_temporary&lt;_Tp, _Up&gt;::value;\n#endif // __has_builtin for reference_from_temporary\n#endif // C++23\n\n#if _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED\n#define __cpp_lib_is_constant_evaluated 201811L\n\n  /// Returns true only when called during constant evaluation.\n  /// @since C++20\n  constexpr inline bool\n  is_constant_evaluated() noexcept\n  {\n#if __cpp_if_consteval &gt;= 202106L\n    if consteval { return true; } else { return false; }\n#else\n    return __builtin_is_constant_evaluated();\n#endif\n  }\n#endif\n\n  /// @cond undocumented\n  template&lt;typename _From, typename _To&gt;\n    using __copy_cv = typename __match_cv_qualifiers&lt;_From, _To&gt;::__type;\n\n  template&lt;typename _Xp, typename _Yp&gt;\n    using __cond_res\n      = decltype(false ? declval&lt;_Xp(&amp;)()&gt;()() : declval&lt;_Yp(&amp;)()&gt;()());\n\n  template&lt;typename _Ap, typename _Bp, typename = void&gt;\n    struct __common_ref_impl\n    { };\n\n  // [meta.trans.other], COMMON-REF(A, B)\n  template&lt;typename _Ap, typename _Bp&gt;\n    using __common_ref = typename __common_ref_impl&lt;_Ap, _Bp&gt;::type;\n\n  // COND-RES(COPYCV(X, Y) &amp;, COPYCV(Y, X) &amp;)\n  template&lt;typename _Xp, typename _Yp&gt;\n    using __condres_cvref\n      = __cond_res&lt;__copy_cv&lt;_Xp, _Yp&gt;&amp;, __copy_cv&lt;_Yp, _Xp&gt;&amp;&gt;;\n\n  // If A and B are both lvalue reference types, ...\n  template&lt;typename _Xp, typename _Yp&gt;\n    struct __common_ref_impl&lt;_Xp&amp;, _Yp&amp;, __void_t&lt;__condres_cvref&lt;_Xp, _Yp&gt;&gt;&gt;\n    : enable_if&lt;is_reference_v&lt;__condres_cvref&lt;_Xp, _Yp&gt;&gt;,\n\t\t__condres_cvref&lt;_Xp, _Yp&gt;&gt;\n    { };\n\n  // let C be remove_reference_t&lt;COMMON-REF(X&amp;, Y&amp;)&gt;&amp;&amp;\n  template&lt;typename _Xp, typename _Yp&gt;\n    using __common_ref_C = remove_reference_t&lt;__common_ref&lt;_Xp&amp;, _Yp&amp;&gt;&gt;&amp;&amp;;\n\n  // If A and B are both rvalue reference types, ...\n  template&lt;typename _Xp, typename _Yp&gt;\n    struct __common_ref_impl&lt;_Xp&amp;&amp;, _Yp&amp;&amp;,\n      _Require&lt;is_convertible&lt;_Xp&amp;&amp;, __common_ref_C&lt;_Xp, _Yp&gt;&gt;,\n\t       is_convertible&lt;_Yp&amp;&amp;, __common_ref_C&lt;_Xp, _Yp&gt;&gt;&gt;&gt;\n    { using type = __common_ref_C&lt;_Xp, _Yp&gt;; };\n\n  // let D be COMMON-REF(const X&amp;, Y&amp;)\n  template&lt;typename _Xp, typename _Yp&gt;\n    using __common_ref_D = __common_ref&lt;const _Xp&amp;, _Yp&amp;&gt;;\n\n  // If A is an rvalue reference and B is an lvalue reference, ...\n  template&lt;typename _Xp, typename _Yp&gt;\n    struct __common_ref_impl&lt;_Xp&amp;&amp;, _Yp&amp;,\n      _Require&lt;is_convertible&lt;_Xp&amp;&amp;, __common_ref_D&lt;_Xp, _Yp&gt;&gt;&gt;&gt;\n    { using type = __common_ref_D&lt;_Xp, _Yp&gt;; };\n\n  // If A is an lvalue reference and B is an rvalue reference, ...\n  template&lt;typename _Xp, typename _Yp&gt;\n    struct __common_ref_impl&lt;_Xp&amp;, _Yp&amp;&amp;&gt;\n    : __common_ref_impl&lt;_Yp&amp;&amp;, _Xp&amp;&gt;\n    { };\n  /// @endcond\n\n  template&lt;typename _Tp, typename _Up,\n\t   template&lt;typename&gt; class _TQual, template&lt;typename&gt; class _UQual&gt;\n    struct basic_common_reference\n    { };\n\n  /// @cond undocumented\n  template&lt;typename _Tp&gt;\n    struct __xref\n    { template&lt;typename _Up&gt; using __type = __copy_cv&lt;_Tp, _Up&gt;; };\n\n  template&lt;typename _Tp&gt;\n    struct __xref&lt;_Tp&amp;&gt;\n    { template&lt;typename _Up&gt; using __type = __copy_cv&lt;_Tp, _Up&gt;&amp;; };\n\n  template&lt;typename _Tp&gt;\n    struct __xref&lt;_Tp&amp;&amp;&gt;\n    { template&lt;typename _Up&gt; using __type = __copy_cv&lt;_Tp, _Up&gt;&amp;&amp;; };\n\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    using __basic_common_ref\n      = typename basic_common_reference&lt;remove_cvref_t&lt;_Tp1&gt;,\n\t\t\t\t\tremove_cvref_t&lt;_Tp2&gt;,\n\t\t\t\t\t__xref&lt;_Tp1&gt;::template __type,\n\t\t\t\t\t__xref&lt;_Tp2&gt;::template __type&gt;::type;\n  /// @endcond\n\n  template&lt;typename... _Tp&gt;\n    struct common_reference;\n\n  template&lt;typename... _Tp&gt;\n    using common_reference_t = typename common_reference&lt;_Tp...&gt;::type;\n\n  // If sizeof...(T) is zero, there shall be no member type.\n  template&lt;&gt;\n    struct common_reference&lt;&gt;\n    { };\n\n  // If sizeof...(T) is one ...\n  template&lt;typename _Tp0&gt;\n    struct common_reference&lt;_Tp0&gt;\n    { using type = _Tp0; };\n\n  /// @cond undocumented\n  template&lt;typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void&gt;\n    struct __common_reference_impl\n    : __common_reference_impl&lt;_Tp1, _Tp2, _Bullet + 1&gt;\n    { };\n\n  // If sizeof...(T) is two ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct common_reference&lt;_Tp1, _Tp2&gt;\n    : __common_reference_impl&lt;_Tp1, _Tp2&gt;\n    { };\n\n  // If T1 and T2 are reference types and COMMON-REF(T1, T2) is well-formed, ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1&amp;, _Tp2&amp;, 1,\n\t\t\t\t   void_t&lt;__common_ref&lt;_Tp1&amp;, _Tp2&amp;&gt;&gt;&gt;\n    { using type = __common_ref&lt;_Tp1&amp;, _Tp2&amp;&gt;; };\n\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1&amp;&amp;, _Tp2&amp;&amp;, 1,\n\t\t\t\t   void_t&lt;__common_ref&lt;_Tp1&amp;&amp;, _Tp2&amp;&amp;&gt;&gt;&gt;\n    { using type = __common_ref&lt;_Tp1&amp;&amp;, _Tp2&amp;&amp;&gt;; };\n\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1&amp;, _Tp2&amp;&amp;, 1,\n\t\t\t\t   void_t&lt;__common_ref&lt;_Tp1&amp;, _Tp2&amp;&amp;&gt;&gt;&gt;\n    { using type = __common_ref&lt;_Tp1&amp;, _Tp2&amp;&amp;&gt;; };\n\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1&amp;&amp;, _Tp2&amp;, 1,\n\t\t\t\t   void_t&lt;__common_ref&lt;_Tp1&amp;&amp;, _Tp2&amp;&gt;&gt;&gt;\n    { using type = __common_ref&lt;_Tp1&amp;&amp;, _Tp2&amp;&gt;; };\n\n  // Otherwise, if basic_common_reference&lt;...&gt;::type is well-formed, ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1, _Tp2, 2,\n\t\t\t\t   void_t&lt;__basic_common_ref&lt;_Tp1, _Tp2&gt;&gt;&gt;\n    { using type = __basic_common_ref&lt;_Tp1, _Tp2&gt;; };\n\n  // Otherwise, if COND-RES(T1, T2) is well-formed, ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1, _Tp2, 3,\n\t\t\t\t   void_t&lt;__cond_res&lt;_Tp1, _Tp2&gt;&gt;&gt;\n    { using type = __cond_res&lt;_Tp1, _Tp2&gt;; };\n\n  // Otherwise, if common_type_t&lt;T1, T2&gt; is well-formed, ...\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1, _Tp2, 4,\n\t\t\t\t   void_t&lt;common_type_t&lt;_Tp1, _Tp2&gt;&gt;&gt;\n    { using type = common_type_t&lt;_Tp1, _Tp2&gt;; };\n\n  // Otherwise, there shall be no member type.\n  template&lt;typename _Tp1, typename _Tp2&gt;\n    struct __common_reference_impl&lt;_Tp1, _Tp2, 5, void&gt;\n    { };\n\n  // Otherwise, if sizeof...(T) is greater than two, ...\n  template&lt;typename _Tp1, typename _Tp2, typename... _Rest&gt;\n    struct common_reference&lt;_Tp1, _Tp2, _Rest...&gt;\n    : __common_type_fold&lt;common_reference&lt;_Tp1, _Tp2&gt;,\n\t\t\t __common_type_pack&lt;_Rest...&gt;&gt;\n    { };\n\n  // Reuse __common_type_fold for common_reference&lt;T1, T2, Rest...&gt;\n  template&lt;typename _Tp1, typename _Tp2, typename... _Rest&gt;\n    struct __common_type_fold&lt;common_reference&lt;_Tp1, _Tp2&gt;,\n\t\t\t      __common_type_pack&lt;_Rest...&gt;,\n\t\t\t      void_t&lt;common_reference_t&lt;_Tp1, _Tp2&gt;&gt;&gt;\n    : public common_reference&lt;common_reference_t&lt;_Tp1, _Tp2&gt;, _Rest...&gt;\n    { };\n  /// @endcond\n\n#endif // C++2a\n\n  /// @} group metaprogramming\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif  // C++11\n\n#endif  // _GLIBCXX_TYPE_TRAITS\n"}, "/usr/include/c++/13/bits/shared_ptr_base.h": {"id": "/usr/include/c++/13/bits/shared_ptr_base.h", "filePath": "/usr/include/c++/13/bits/shared_ptr_base.h", "content": "// shared_ptr and weak_ptr implementation details -*- C++ -*-\n\n// Copyright (C) 2007-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file bits/shared_ptr_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_BASE_H\n#define _SHARED_PTR_BASE_H 1\n\n#include &lt;typeinfo&gt;\n#include &lt;bits/allocated_ptr.h&gt;\n#include &lt;bits/allocator.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/refwrap.h&gt;\n#include &lt;bits/stl_function.h&gt;  // std::less\n#include &lt;bits/unique_ptr.h&gt;\n#include &lt;ext/aligned_buffer.h&gt;\n#include &lt;ext/atomicity.h&gt;\n#include &lt;ext/concurrence.h&gt;\n#if __cplusplus &gt;= 202002L\n# include &lt;bit&gt;          // __bit_floor\n# include &lt;compare&gt;\n# include &lt;bits/align.h&gt; // std::align\n# include &lt;bits/stl_uninitialized.h&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename&gt; class auto_ptr;\n#pragma GCC diagnostic pop\n#endif\n\n /**\n   *  @brief  Exception possibly thrown by @c shared_ptr.\n   *  @ingroup exceptions\n   */\n  class bad_weak_ptr : public std::exception\n  {\n  public:\n    virtual char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n  inline void\n  __throw_bad_weak_ptr()\n  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  using __gnu_cxx::_S_atomic;\n\n  // Empty helper class except when the template argument is _S_mutex.\n  template&lt;_Lock_policy _Lp&gt;\n    class _Mutex_base\n    {\n    protected:\n      // The atomic policy uses fully-fenced builtins, single doesn&#x27;t care.\n      enum { _S_need_barriers = 0 };\n    };\n\n  template&lt;&gt;\n    class _Mutex_base&lt;_S_mutex&gt;\n    : public __gnu_cxx::__mutex\n    {\n    protected:\n      // This policy is used when atomic builtins are not available.\n      // The replacement atomic operations might not have the necessary\n      // memory barriers.\n      enum { _S_need_barriers = 1 };\n    };\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class _Sp_counted_base\n    : public _Mutex_base&lt;_Lp&gt;\n    {\n    public:\n      _Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n      // Called when _M_use_count drops to zero, to release the resources\n      // managed by *this.\n      virtual void\n      _M_dispose() noexcept = 0;\n\n      // Called when _M_weak_count drops to zero.\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept = 0;\n\n      // Increment the use count (used when the count is greater than zero).\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }\n\n      // Increment the use count if it is non-zero, throw otherwise.\n      void\n      _M_add_ref_lock()\n      {\n\tif (!_M_add_ref_lock_nothrow())\n\t  __throw_bad_weak_ptr();\n      }\n\n      // Increment the use count if it is non-zero.\n      bool\n      _M_add_ref_lock_nothrow() noexcept;\n\n      // Decrement the use count.\n      void\n      _M_release() noexcept;\n\n      // Called by _M_release() when the use count reaches zero.\n      void\n      _M_release_last_use() noexcept\n      {\n\t_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t_M_dispose();\n\t// There must be a memory barrier between dispose() and destroy()\n\t// to ensure that the effects of dispose() are observed in the\n\t// thread that runs destroy().\n\t// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n\tif (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t  {\n\t    __atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t  }\n\n\t// Be race-detector-friendly.  For more info see bits/c++config.\n\t_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,\n\t\t\t\t\t\t   -1) == 1)\n\t  {\n\t    _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    _M_destroy();\n\t  }\n      }\n\n      // As above, but &#x27;noinline&#x27; to reduce code size on the cold path.\n      __attribute__((__noinline__))\n      void\n      _M_release_last_use_cold() noexcept\n      { _M_release_last_use(); }\n\n      // Increment the weak count.\n      void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }\n\n      // Decrement the weak count.\n      void\n      _M_weak_release() noexcept\n      {\n        // Be race-detector-friendly. For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t        // See _M_release(),\n\t        // destroy() must observe results of dispose()\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\t    _M_destroy();\n\t  }\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      {\n        // No memory barrier is used here so there is no synchronization\n        // with other threads.\n        return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&amp;) = delete;\n      _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete;\n\n      _Atomic_word  _M_use_count;     // #shared\n      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n    };\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_single&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      if (_M_use_count == 0)\n\treturn false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_mutex&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)\n\t{\n\t  _M_use_count = 0;\n\t  return false;\n\t}\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_atomic&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      // Perform lock-free add-if-not-zero operation.\n      _Atomic_word __count = _M_get_use_count();\n      do\n\t{\n\t  if (__count == 0)\n\t    return false;\n\t  // Replace the current counter value with the old value + 1, as\n\t  // long as it&#x27;s not changed meanwhile.\n\t}\n      while (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + 1,\n\t\t\t\t\t  true, __ATOMIC_ACQ_REL,\n\t\t\t\t\t  __ATOMIC_RELAXED));\n      return true;\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n        }\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_mutex&gt;::_M_release() noexcept\n    {\n      // Be race-detector-friendly.  For more info see bits/c++config.\n      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t{\n\t  _M_release_last_use();\n\t}\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_atomic&gt;::_M_release() noexcept\n    {\n      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n#if ! _GLIBCXX_TSAN\n      constexpr bool __lock_free\n\t= __atomic_always_lock_free(sizeof(long long), 0)\n\t&amp;&amp; __atomic_always_lock_free(sizeof(_Atomic_word), 0);\n      constexpr bool __double_word\n\t= sizeof(long long) == 2 * sizeof(_Atomic_word);\n      // The ref-count members follow the vptr, so are aligned to\n      // alignof(void*).\n      constexpr bool __aligned = __alignof(long long) &lt;= alignof(void*);\n      if _GLIBCXX17_CONSTEXPR (__lock_free &amp;&amp; __double_word &amp;&amp; __aligned)\n\t{\n\t  constexpr int __wordbits = __CHAR_BIT__ * sizeof(_Atomic_word);\n\t  constexpr int __shiftbits = __double_word ? __wordbits : 0;\n\t  constexpr long long __unique_ref = 1LL + (1LL &lt;&lt; __shiftbits);\n\t  auto __both_counts = reinterpret_cast&lt;long long*&gt;(&amp;_M_use_count);\n\n\t  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\t  if (__atomic_load_n(__both_counts, __ATOMIC_ACQUIRE) == __unique_ref)\n\t    {\n\t      // Both counts are 1, so there are no weak references and\n\t      // we are releasing the last strong reference. No other\n\t      // threads can observe the effects of this _M_release()\n\t      // call (e.g. calling use_count()) without a data race.\n\t      _M_weak_count = _M_use_count = 0;\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t      _M_dispose();\n\t      _M_destroy();\n\t      return;\n\t    }\n\t  if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t    [[__unlikely__]]\n\t    {\n\t      _M_release_last_use_cold();\n\t      return;\n\t    }\n\t}\n      else\n#endif\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t{\n\t  _M_release_last_use();\n\t}\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template&lt;&gt;\n    inline long\n    _Sp_counted_base&lt;_S_single&gt;::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n  // Forward declarations.\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __enable_shared_from_this;\n\n  template&lt;typename _Tp&gt;\n    class shared_ptr;\n\n  template&lt;typename _Tp&gt;\n    class weak_ptr;\n\n  template&lt;typename _Tp&gt;\n    struct owner_less;\n\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_count;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_count;\n\n#if __cplusplus &gt;= 202002L\n  template&lt;typename&gt;\n    class _Sp_atomic;\n#endif\n\n  // Counted ptr with no deleter or allocator support\n  template&lt;typename _Ptr, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n    public:\n      explicit\n      _Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&amp;) = delete;\n      _Sp_counted_ptr&amp; operator=(const _Sp_counted_ptr&amp;) = delete;\n\n    private:\n      _Ptr             _M_ptr;\n    };\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_single&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_mutex&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_atomic&gt;::_M_dispose() noexcept { }\n\n  // FIXME: once __has_cpp_attribute(__no_unique_address__)) is true for\n  // all supported compilers we can greatly simplify _Sp_ebo_helper.\n  // N.B. unconditionally applying the attribute could change layout for\n  // final types, which currently cannot use EBO so have a unique address.\n\n  template&lt;int _Nm, typename _Tp,\n\t   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;\n    struct _Sp_ebo_helper;\n\n  /// Specialization using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, true&gt; : private _Tp\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh) { return static_cast&lt;_Tp&amp;&gt;(__eboh); }\n    };\n\n  /// Specialization not using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, false&gt;\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n  // Support for custom deleter and/or allocator\n  template&lt;typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_deleter final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Deleter&gt;, _Sp_ebo_helper&lt;1, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Deleter&gt;\t_Del_base;\n\ttypedef _Sp_ebo_helper&lt;1, _Alloc&gt;\t_Alloc_base;\n\n      public:\n\t_Impl(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n\t: _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)\n\t{ }\n\n\t_Deleter&amp; _M_del() noexcept { return _Del_base::_S_get(*this); }\n\t_Alloc&amp; _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n\t_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_deleter();\n      }\n\n      virtual void*\n      _M_get_deleter(const type_info&amp; __ti [[__gnu__::__unused__]]) noexcept\n      {\n#if __cpp_rtti\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2400. shared_ptr&#x27;s get_deleter() should use addressof()\n        return __ti == typeid(_Deleter)\n\t  ? std::__addressof(_M_impl._M_del())\n\t  : nullptr;\n#else\n        return nullptr;\n#endif\n      }\n\n    private:\n      _Impl _M_impl;\n    };\n\n  // helpers for make_shared / allocate_shared\n\n  struct _Sp_make_shared_tag\n  {\n  private:\n    template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n      friend class _Sp_counted_ptr_inplace;\n\n    static const type_info&amp;\n    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)\n    {\n      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };\n      return reinterpret_cast&lt;const type_info&amp;&gt;(__tag);\n    }\n\n    static bool _S_eq(const type_info&amp;) noexcept;\n  };\n\n  template&lt;typename _Alloc&gt;\n    struct _Sp_alloc_shared_tag\n    {\n      const _Alloc&amp; _M_a;\n    };\n\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Alloc&gt;\t_A_base;\n\n      public:\n\texplicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n\t_Alloc&amp; _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n\t__gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      // Alloc parameter is not a reference so doesn&#x27;t alias anything in __args\n      template&lt;typename... _Args&gt;\n\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&amp;&amp;... __args)\n\t: _M_impl(__a)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2070.  allocate_shared should use allocator_traits&lt;A&gt;::construct\n\t  allocator_traits&lt;_Alloc&gt;::construct(__a, _M_ptr(),\n\t      std::forward&lt;_Args&gt;(__args)...); // might throw\n\t}\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tallocator_traits&lt;_Alloc&gt;::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      // No longer used, but code compiled against old libstdc++ headers\n      // might still call it from __shared_ptr ctor to get the pointer out.\n      virtual void*\n      _M_get_deleter(const std::type_info&amp; __ti) noexcept override\n      {\n\tauto __ptr = const_cast&lt;typename remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());\n\t// Check for the fake type_info first, so we don&#x27;t try to access it\n\t// as a real type_info object. Otherwise, check if it&#x27;s the real\n\t// type_info for this class. With RTTI enabled we can check directly,\n\t// or call a library function to do it.\n\tif (&amp;__ti == &amp;_Sp_make_shared_tag::_S_ti()\n\t    ||\n#if __cpp_rtti\n\t    __ti == typeid(_Sp_make_shared_tag)\n#else\n\t    _Sp_make_shared_tag::_S_eq(__ti)\n#endif\n\t   )\n\t  return __ptr;\n\treturn nullptr;\n      }\n\n      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n#if __cplusplus &gt;= 202002L\n# define __cpp_lib_smart_ptr_for_overwrite 202002L\n  struct _Sp_overwrite_tag { };\n\n  // Partial specialization used for make_shared_for_overwrite&lt;non-array&gt;().\n  // This partial specialization is used when the allocator&#x27;s value type\n  // is the special _Sp_overwrite_tag type.\n#if __cpp_concepts\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    requires is_same_v&lt;typename _Alloc::value_type, _Sp_overwrite_tag&gt;\n    class _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; final\n#else\n  template&lt;typename _Tp, template&lt;typename&gt; class _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace&lt;_Tp, _Alloc&lt;_Sp_overwrite_tag&gt;, _Lp&gt; final\n#endif\n    : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      [[no_unique_address]] _Alloc _M_alloc;\n\n      union {\n\t_Tp _M_obj;\n\tchar _M_unused;\n      };\n\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      _Tp* _M_ptr() noexcept { return std::__addressof(_M_obj); }\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      _Sp_counted_ptr_inplace(const _Alloc&amp; __a)\n      : _M_alloc(__a)\n      {\n\t::new((void*)_M_ptr()) _Tp; // default-initialized, for overwrite.\n      }\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\t_M_obj.~_Tp();\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\tusing pointer = typename allocator_traits&lt;__allocator_type&gt;::pointer;\n\t__allocator_type __a(_M_alloc);\n\tauto __p = pointer_traits&lt;pointer&gt;::pointer_to(*this);\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, __p };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n      void*\n      _M_get_deleter(const std::type_info&amp;) noexcept override\n      { return nullptr; }\n    };\n#endif // C++20\n\n#if __cplusplus &lt;= 201703L\n# define __cpp_lib_shared_ptr_arrays 201611L\n#else\n# define __cpp_lib_shared_ptr_arrays 201707L\n\n  struct _Sp_overwrite_tag;\n\n  // For make_shared&lt;T[]&gt;, make_shared&lt;T[N]&gt;, allocate_shared&lt;T[]&gt; etc.\n  template&lt;typename _Alloc&gt;\n    struct _Sp_counted_array_base\n    {\n      [[no_unique_address]] _Alloc _M_alloc{};\n      size_t _M_n = 0;\n      bool _M_overwrite = false;\n\n      typename allocator_traits&lt;_Alloc&gt;::pointer\n      _M_alloc_array(size_t __tail)\n      {\n\treturn allocator_traits&lt;_Alloc&gt;::allocate(_M_alloc, _M_n + __tail);\n      }\n\n      void\n      _M_dealloc_array(typename allocator_traits&lt;_Alloc&gt;::pointer __p,\n\t\t       size_t __tail)\n      {\n\tallocator_traits&lt;_Alloc&gt;::deallocate(_M_alloc, __p, _M_n + __tail);\n      }\n\n      // Init the array elements\n      template&lt;typename _Init&gt;\n\tvoid\n\t_M_init(typename allocator_traits&lt;_Alloc&gt;::value_type* __p,\n\t\t_Init __init)\n\t{\n\t  using _Tp = remove_pointer_t&lt;_Init&gt;;\n\t  using _Up = typename allocator_traits&lt;_Alloc&gt;::value_type;\n\n\t  if constexpr (is_same_v&lt;_Init, _Sp_overwrite_tag&gt;)\n\t    {\n\t      std::uninitialized_default_construct_n(__p, _M_n);\n\t      _M_overwrite = true;\n\t    }\n\t  else if (__init == nullptr)\n\t    std::__uninitialized_default_n_a(__p, _M_n, _M_alloc);\n\t  else if constexpr (!is_array_v&lt;_Tp&gt;)\n\t    std::__uninitialized_fill_n_a(__p, _M_n, *__init, _M_alloc);\n\t  else\n\t    {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wunused-local-typedefs&quot;\n\t      struct _Iter\n\t      {\n\t\tusing value_type = _Up;\n\t\tusing difference_type = ptrdiff_t;\n\t\tusing pointer = const _Up*;\n\t\tusing reference = const _Up&amp;;\n\t\tusing iterator_category = forward_iterator_tag;\n\n\t\tconst _Up* _M_p;\n\t\tsize_t _M_len;\n\t\tsize_t _M_pos;\n\n\t\t_Iter&amp; operator++() { ++_M_pos; return *this; }\n\t\t_Iter operator++(int) { auto __i(*this); ++_M_pos; return __i; }\n\n\t\treference operator*() const { return _M_p[_M_pos % _M_len]; }\n\t\tpointer operator-&gt;() const { return _M_p + (_M_pos % _M_len); }\n\n\t\tbool operator==(const _Iter&amp; __i) const\n\t\t{ return _M_pos == __i._M_pos; }\n\t      };\n#pragma GCC diagnostic pop\n\n\t      _Iter __first{_S_first_elem(__init), sizeof(_Tp) / sizeof(_Up)};\n\t      _Iter __last = __first;\n\t      __last._M_pos = _M_n;\n\t      std::__uninitialized_copy_a(__first, __last, __p, _M_alloc);\n\t    }\n\t}\n\n    protected:\n      // Destroy the array elements\n      void\n      _M_dispose_array(typename allocator_traits&lt;_Alloc&gt;::value_type* __p)\n      {\n\tif (_M_overwrite)\n\t  std::destroy_n(__p, _M_n);\n\telse\n\t  {\n\t    size_t __n = _M_n;\n\t    while (__n--)\n\t      allocator_traits&lt;_Alloc&gt;::destroy(_M_alloc, __p + __n);\n\t  }\n      }\n\n    private:\n      template&lt;typename _Tp&gt;\n\tstatic _Tp*\n\t_S_first_elem(_Tp* __p) { return __p; }\n\n      template&lt;typename _Tp, size_t _Nm&gt;\n\tstatic auto\n\t_S_first_elem(_Tp (*__p)[_Nm]) { return _S_first_elem(*__p); }\n    };\n\n  // Control block for make_shared&lt;T[]&gt;, make_shared&lt;T[N]&gt; etc. that will be\n  // placed into unused memory at the end of the array.\n  template&lt;typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_array final\n    : public _Sp_counted_base&lt;_Lp&gt;, _Sp_counted_array_base&lt;_Alloc&gt;\n    {\n      using pointer = typename allocator_traits&lt;_Alloc&gt;::pointer;\n\n      pointer _M_alloc_ptr;\n\n      auto _M_ptr() const noexcept { return std::to_address(_M_alloc_ptr); }\n\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n    public:\n      _Sp_counted_array(const _Sp_counted_array_base&lt;_Alloc&gt;&amp; __a,\n\t\t\tpointer __p) noexcept\n      : _Sp_counted_array_base&lt;_Alloc&gt;(__a), _M_alloc_ptr(__p)\n      { }\n\n      ~_Sp_counted_array() = default;\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tif (this-&gt;_M_n)\n\t  this-&gt;_M_dispose_array(_M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t_Sp_counted_array_base&lt;_Alloc&gt; __a = *this;\n\tpointer __p = _M_alloc_ptr;\n\tthis-&gt;~_Sp_counted_array();\n\t__a._M_dealloc_array(__p, _S_tail());\n      }\n\n      // Returns the number of additional array elements that must be\n      // allocated in order to store a _Sp_counted_array at the end.\n      static constexpr size_t\n      _S_tail()\n      {\n\t// The array elemenent type.\n\tusing _Tp = typename allocator_traits&lt;_Alloc&gt;::value_type;\n\n\t// The space needed to store a _Sp_counted_array object.\n\tsize_t __bytes = sizeof(_Sp_counted_array);\n\n\t// Add any padding needed for manual alignment within the buffer.\n\tif constexpr (alignof(_Tp) &lt; alignof(_Sp_counted_array))\n\t  __bytes += alignof(_Sp_counted_array) - alignof(_Tp);\n\n\treturn (__bytes + sizeof(_Tp) - 1) / sizeof(_Tp);\n      }\n\n      void*\n      _M_get_deleter(const std::type_info&amp;) noexcept override\n      { return nullptr; }\n    };\n#endif // C++20\n\n  // The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  struct __sp_array_delete\n  {\n    template&lt;typename _Yp&gt;\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __shared_count\n    {\n      // Prevent _Sp_alloc_shared_tag from matching the shared_ptr(P, D) ctor.\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag { using type = void; };\n\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_alloc_shared_tag&lt;_Tp&gt;&gt; { };\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n      template&lt;typename _Alloc&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_counted_array_base&lt;_Alloc&gt;&gt; { };\n#endif\n\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      template&lt;typename _Ptr&gt;\n        explicit\n\t__shared_count(_Ptr __p) : _M_pi(0)\n\t{\n\t  __try\n\t    {\n\t      _M_pi = new _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete __p;\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n\t: __shared_count(__p)\n\t{ }\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n\t: __shared_count(__p, __sp_array_delete{}, allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d)\n\t: __shared_count(__p, std::move(__d), allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter, typename _Alloc,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n\t{\n\t  typedef _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;\n\t  __try\n\t    {\n\t      typename _Sp_cd_type::__allocator_type __a2(__a);\n\t      auto __guard = std::__allocate_guarded(__a2);\n\t      _Sp_cd_type* __mem = __guard.get();\n\t      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));\n\t      _M_pi = __mem;\n\t      __guard = nullptr;\n\t    }\n\t  __catch(...)\n\t    {\n\t      __d(__p); // Call _Deleter on __p.\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n\t__shared_count(_Tp*&amp; __p, _Sp_alloc_shared_tag&lt;_Alloc&gt; __a,\n\t\t       _Args&amp;&amp;... __args)\n\t{\n\t  typedef _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;\n\t  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n\t  auto __guard = std::__allocate_guarded(__a2);\n\t  _Sp_cp_type* __mem = __guard.get();\n\t  auto __pi = ::new (__mem)\n\t    _Sp_cp_type(__a._M_a, std::forward&lt;_Args&gt;(__args)...);\n\t  __guard = nullptr;\n\t  _M_pi = __pi;\n\t  __p = __pi-&gt;_M_ptr();\n\t}\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n      template&lt;typename _Tp, typename _Alloc, typename _Init&gt;\n\t__shared_count(_Tp*&amp; __p, const _Sp_counted_array_base&lt;_Alloc&gt;&amp; __a,\n\t\t       _Init __init)\n\t{\n\t  using _Up = remove_all_extents_t&lt;_Tp&gt;;\n\t  static_assert(is_same_v&lt;_Up, typename _Alloc::value_type&gt;);\n\n\t  using _Sp_ca_type = _Sp_counted_array&lt;_Alloc, _Lp&gt;;\n\t  const size_t __tail = _Sp_ca_type::_S_tail();\n\n\t  struct _Guarded_ptr : _Sp_counted_array_base&lt;_Alloc&gt;\n\t  {\n\t    typename allocator_traits&lt;_Alloc&gt;::pointer _M_ptr;\n\n\t    _Guarded_ptr(_Sp_counted_array_base&lt;_Alloc&gt; __a)\n\t    : _Sp_counted_array_base&lt;_Alloc&gt;(__a),\n\t      _M_ptr(this-&gt;_M_alloc_array(_Sp_ca_type::_S_tail()))\n\t    { }\n\n\t    ~_Guarded_ptr()\n\t    {\n\t      if (_M_ptr)\n\t\tthis-&gt;_M_dealloc_array(_M_ptr, _Sp_ca_type::_S_tail());\n\t    }\n\t  };\n\n\t  _Guarded_ptr __guard{__a};\n\t  _Up* const __raw = std::to_address(__guard._M_ptr);\n\t  __guard._M_init(__raw, __init); // might throw\n\n\t  void* __c = __raw + __a._M_n;\n\t  if constexpr (alignof(_Up) &lt; alignof(_Sp_ca_type))\n\t    {\n\t      size_t __space = sizeof(_Up) * __tail;\n\t      __c = std::align(alignof(_Sp_ca_type), sizeof(_Sp_ca_type),\n\t\t\t       __c, __space);\n\t    }\n\t  auto __pi = ::new(__c) _Sp_ca_type(__guard, __guard._M_ptr);\n\t  __guard._M_ptr = nullptr;\n\t  _M_pi = __pi;\n\t  __p = reinterpret_cast&lt;_Tp*&gt;(__raw);\n\t}\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Special case for auto_ptr&lt;_Tp&gt; to provide the strong guarantee.\n      template&lt;typename _Tp&gt;\n        explicit\n\t__shared_count(std::auto_ptr&lt;_Tp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // Special case for unique_ptr&lt;_Tp,_Del&gt; to provide the strong guarantee.\n      template&lt;typename _Tp, typename _Del&gt;\n        explicit\n\t__shared_count(std::unique_ptr&lt;_Tp, _Del&gt;&amp;&amp; __r) : _M_pi(0)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2415. Inconsistency between unique_ptr and shared_ptr\n\t  if (__r.get() == nullptr)\n\t    return;\n\n\t  using _Ptr = typename unique_ptr&lt;_Tp, _Del&gt;::pointer;\n\t  using _Del2 = __conditional_t&lt;is_reference&lt;_Del&gt;::value,\n\t      reference_wrapper&lt;typename remove_reference&lt;_Del&gt;::type&gt;,\n\t      _Del&gt;;\n\t  using _Sp_cd_type\n\t    = _Sp_counted_deleter&lt;_Ptr, _Del2, allocator&lt;void&gt;, _Lp&gt;;\n\t  using _Alloc = allocator&lt;_Sp_cd_type&gt;;\n\t  using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;\n\t  _Alloc __a;\n\t  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3548. shared_ptr construction from unique_ptr should move\n\t  // (not copy) the deleter\n\t  _Alloc_traits::construct(__a, __mem, __r.release(),\n\t\t\t\t   std::forward&lt;_Del&gt;(__r.get_deleter()));\n\t  _M_pi = __mem;\n\t}\n\n      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n      explicit __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r);\n\n      // Does not throw if __r._M_get_use_count() == 0, caller must check.\n      explicit\n      __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept;\n\n      ~__shared_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_release();\n      }\n\n      __shared_count(const __shared_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_add_ref_copy();\n      }\n\n      __shared_count&amp;\n      operator=(const __shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != _M_pi)\n\t  {\n\t    if (__tmp != nullptr)\n\t      __tmp-&gt;_M_add_ref_copy();\n\t    if (_M_pi != nullptr)\n\t      _M_pi-&gt;_M_release();\n\t    _M_pi = __tmp;\n\t  }\n\treturn *this;\n      }\n\n      void\n      _M_swap(__shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this-&gt;_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __shared_count&amp; __a, const __shared_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count&lt;_Lp&gt;;\n#if __cplusplus &gt;= 202002L\n      template&lt;typename&gt; friend class _Sp_atomic;\n#endif\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&amp;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n      }\n\n      __weak_count&amp;\n      operator=(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(const __weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(__weak_count&amp;&amp; __r) noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n\treturn *this;\n      }\n\n      void\n      _M_swap(__weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __weak_count&amp; __a, const __weak_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;;\n#if __cplusplus &gt;= 202002L\n      template&lt;typename&gt; friend class _Sp_atomic;\n#endif\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::__shared_count(const __weak_count&lt;_Lp&gt;&amp; __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi == nullptr || !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t__throw_bad_weak_ptr();\n    }\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::\n    __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi &amp;&amp; !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t_M_pi = nullptr;\n    }\n\n  // Helper traits for shared_ptr of array:\n\n  // A pointer type Y* is said to be compatible with a pointer type T* when\n  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n  template&lt;typename _Yp_ptr, typename _Tp_ptr&gt;\n    struct __sp_compatible_with\n    : false_type\n    { };\n\n  template&lt;typename _Yp, typename _Tp&gt;\n    struct __sp_compatible_with&lt;_Yp*, _Tp*&gt;\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n  template&lt;typename _Up, size_t _Nm, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arrN\n    : false_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp, __void_t&lt;_Yp[_Nm]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[_Nm], _Up(*)[_Nm]&gt;::type\n    { };\n\n  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n  template&lt;typename _Up, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arr\n    : false_type\n    { };\n\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible_arr&lt;_Up, _Yp, __void_t&lt;_Yp[]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[], _Up(*)[]&gt;::type\n    { };\n\n  // Trait to check if shared_ptr&lt;T&gt; can be constructed from Y*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible;\n\n  // When T is U[N], Y(*)[N] shall be convertible to T*;\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[_Nm], _Yp&gt;\n    : __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp&gt;::type\n    { };\n\n  // when T is U[], Y(*)[] shall be convertible to T*;\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[], _Yp&gt;\n    : __sp_is_constructible_arr&lt;_Up, _Yp&gt;::type\n    { };\n\n  // otherwise, Y* shall be convertible to T*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n\n  // Define operator* and operator-&gt; for shared_ptr&lt;T&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp,\n\t   bool = is_array&lt;_Tp&gt;::value, bool = is_void&lt;_Tp&gt;::value&gt;\n    class __shared_ptr_access\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  // Define operator-&gt; for shared_ptr&lt;cv void&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, false, true&gt;\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\tauto __ptr = static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get();\n\t_GLIBCXX_DEBUG_PEDASSERT(__ptr != nullptr);\n\treturn __ptr;\n      }\n    };\n\n  // Define operator[] for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, true, false&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n#if __cplusplus &lt;= 201402L\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator* is absent from C++17&quot;)]]\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator-&gt; is absent from C++17&quot;)]]\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n#endif\n\n      element_type&amp;\n      operator[](ptrdiff_t __i) const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\t__glibcxx_assert(!extent&lt;_Tp&gt;::value || __i &lt; extent&lt;_Tp&gt;::value);\n\treturn _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n    : public __shared_ptr_access&lt;_Tp, _Lp&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n    private:\n      // Constraint for taking ownership of a pointer of type _Yp*:\n      template&lt;typename _Yp&gt;\n\tusing _SafeConv\n\t  = typename enable_if&lt;__sp_is_constructible&lt;_Tp, _Yp&gt;::value&gt;::type;\n\n      // Constraint for construction from shared_ptr and weak_ptr:\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __shared_ptr&amp;&gt;;\n\n      // Constraint for construction from unique_ptr:\n      template&lt;typename _Yp, typename _Del, typename _Res = void,\n\t       typename _Ptr = typename unique_ptr&lt;_Yp, _Del&gt;::pointer&gt;\n\tusing _UniqCompatible = __enable_if_t&lt;__and_&lt;\n\t  __sp_compatible_with&lt;_Yp*, _Tp*&gt;,\n\t  is_convertible&lt;_Ptr, element_type*&gt;,\n\t  is_move_constructible&lt;_Del&gt;\n\t  &gt;::value, _Res&gt;;\n\n      // Constraint for assignment from unique_ptr:\n      template&lt;typename _Yp, typename _Del&gt;\n\tusing _UniqAssignable = _UniqCompatible&lt;_Yp, _Del, __shared_ptr&amp;&gt;;\n\n    public:\n\n#if __cplusplus &gt; 201402L\n      using weak_type = __weak_ptr&lt;_Tp, _Lp&gt;;\n#endif\n\n      constexpr __shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template&lt;typename _Yp, typename = _SafeConv&lt;_Yp&gt;&gt;\n\texplicit\n\t__shared_ptr(_Yp* __p)\n\t: _M_ptr(__p), _M_refcount(__p, typename is_array&lt;_Tp&gt;::type())\n\t{\n\t  static_assert( !is_void&lt;_Yp&gt;::value, &quot;incomplete type&quot; );\n\t  static_assert( sizeof(_Yp) &gt; 0, &quot;incomplete type&quot; );\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Deleter&gt;\n\t__shared_ptr(nullptr_t __p, _Deleter __d)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d))\n\t{ }\n\n      template&lt;typename _Deleter, typename _Alloc&gt;\n        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      __shared_ptr(const __shared_ptr&amp;) noexcept = default;\n      __shared_ptr&amp; operator=(const __shared_ptr&amp;) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n\t_M_refcount._M_swap(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n      }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\texplicit __shared_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r)\n\t: _M_refcount(__r._M_refcount) // may throw\n\t{\n\t  // It is now safe to copy __r._M_ptr, as\n\t  // _M_refcount(__r._M_refcount) did not throw.\n\t  _M_ptr = __r._M_ptr;\n\t}\n\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _UniqCompatible&lt;_Yp, _Del&gt;&gt;\n\t__shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n    protected:\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Tp1, typename _Del,\n\t       typename enable_if&lt;__and_&lt;\n\t\t __not_&lt;is_array&lt;_Tp&gt;&gt;, is_array&lt;_Tp1&gt;,\n\t         is_convertible&lt;typename unique_ptr&lt;_Tp1, _Del&gt;::pointer, _Tp*&gt;\n\t       &gt;::value, bool&gt;::type = true&gt;\n\t__shared_ptr(unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r, __sp_array_delete)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n    public:\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Postcondition: use_count() == 1 and __r.get() == 0\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn&#x27;t throw\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      __shared_ptr&amp;\n      operator=(__shared_ptr&amp;&amp; __r) noexcept\n      {\n\t__shared_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_UniqAssignable&lt;_Yp, _Del&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template&lt;typename _Yp&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p) // _Yp must be complete.\n\t{\n\t  // Catch self-reset errors.\n\t  __glibcxx_assert(__p == nullptr || __p != _M_ptr);\n\t  __shared_ptr(__p).swap(*this);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d)\n\t{ __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      /// Return the stored pointer.\n      element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      /// Return true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return _M_ptr != nullptr; }\n\n      /// Return true if use_count() == 1.\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      /// If *this owns a pointer, return the number of owners, otherwise zero.\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      /// Exchange both the owned pointer and the stored pointer.\n      void\n      swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept\n      {\n\tstd::swap(_M_ptr, __other._M_ptr);\n\t_M_refcount._M_swap(__other._M_refcount);\n      }\n\n      /** @brief Define an ordering based on ownership.\n       *\n       * This function defines a strict weak ordering between two shared_ptr\n       * or weak_ptr objects, such that one object is less than the other\n       * unless they share ownership of the same pointer, or are both empty.\n       * @{\n      */\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__shared_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__weak_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n      /// @}\n\n    protected:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\t__shared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ _M_enable_shared_from_this_with(_M_ptr); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n\t       typename... _Args&gt;\n\tfriend __shared_ptr&lt;_Tp1, _Lp1&gt;\n\t__allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n      // This constructor is non-standard, it is used by allocate_shared&lt;T[]&gt;.\n      template&lt;typename _Alloc, typename _Init = const remove_extent_t&lt;_Tp&gt;*&gt;\n\t__shared_ptr(const _Sp_counted_array_base&lt;_Alloc&gt;&amp; __a,\n\t\t     _Init __init = nullptr)\n\t: _M_ptr(), _M_refcount(_M_ptr, __a, __init)\n\t{ }\n#endif\n\n      // This constructor is used by __weak_ptr::lock() and\n      // shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).\n      __shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) noexcept\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n\t_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n      friend class __weak_ptr&lt;_Tp, _Lp&gt;;\n\n    private:\n\n      template&lt;typename _Yp&gt;\n\tusing __esft_base_t = decltype(__enable_shared_from_this_base(\n\t      std::declval&lt;const __shared_count&lt;_Lp&gt;&amp;&gt;(),\n\t      std::declval&lt;_Yp*&gt;()));\n\n      // Detect an accessible and unambiguous enable_shared_from_this base.\n      template&lt;typename _Yp, typename = void&gt;\n\tstruct __has_esft_base\n\t: false_type { };\n\n      template&lt;typename _Yp&gt;\n\tstruct __has_esft_base&lt;_Yp, __void_t&lt;__esft_base_t&lt;_Yp&gt;&gt;&gt;\n\t: __not_&lt;is_array&lt;_Tp&gt;&gt; { }; // No enable shared_from_this for arrays\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp* __p) noexcept\n\t{\n\t  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n\t    __base-&gt;_M_weak_assign(const_cast&lt;_Yp2*&gt;(__p), _M_refcount);\n\t}\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;!__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp*) noexcept\n\t{ }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n\n      template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt;\n\tfriend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept;\n\n      template&lt;typename _Del, typename _Tp1&gt;\n\tfriend _Del* get_deleter(const shared_ptr&lt;_Tp1&gt;&amp;) noexcept;\n\n#if __cplusplus &gt;= 202002L\n      friend _Sp_atomic&lt;shared_ptr&lt;_Tp&gt;&gt;;\n#endif\n\n      element_type*\t   _M_ptr;         // Contained pointer.\n      __shared_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n\n  // 20.7.2.2.7 shared_ptr comparisons\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t\tconst __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      using _Up_elt = typename __shared_ptr&lt;_Up, _Lp&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif // three-way comparison\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, __shared_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(static_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// static_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    static_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(const_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// const_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    const_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(dynamic_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// dynamic_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    dynamic_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt; 201402L\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    reinterpret_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __weak_ptr\n    {\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __weak_ptr&amp;&gt;;\n\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n      constexpr __weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&amp;) noexcept = default;\n\n      ~__weak_ptr() = default;\n\n      // The &quot;obvious&quot; converting constructor implementation:\n      //\n      //  template&lt;typename _Tp1&gt;\n      //    __weak_ptr(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)\n      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n      //    { }\n      //\n      // has a serious problem.\n      //\n      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n      //\n      // It is not possible to avoid spurious access violations since\n      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __weak_ptr(__weak_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&amp;\n      operator=(const __weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      __weak_ptr&amp;\n      operator=(__weak_ptr&amp;&amp; __r) noexcept\n      {\n\t__weak_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = std::move(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t  return *this;\n\t}\n\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      lock() const noexcept\n      { return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr&amp; __s) noexcept\n      {\n\tstd::swap(_M_ptr, __s._M_ptr);\n\t_M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n      // Used by __enable_shared_from_this.\n      void\n      _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept\n      {\n\tif (use_count() == 0)\n\t  {\n\t    _M_ptr = __ptr;\n\t    _M_refcount = __refcount;\n\t  }\n      }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n      friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;;\n      friend class enable_shared_from_this&lt;_Tp&gt;;\n#if __cplusplus &gt;= 202002L\n      friend _Sp_atomic&lt;weak_ptr&lt;_Tp&gt;&gt;;\n#endif\n\n      element_type*\t _M_ptr;         // Contained pointer.\n      __weak_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__weak_ptr&lt;_Tp, _Lp&gt;&amp; __a, __weak_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename _Tp, typename _Tp1&gt;\n    struct _Sp_owner_less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp1&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n#pragma GCC diagnostic pop\n\n  template&lt;&gt;\n    struct _Sp_owner_less&lt;void, void&gt;\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n\tauto\n\toperator()(const _Tp&amp; __lhs, const _Up&amp; __rhs) const noexcept\n\t-&gt; decltype(__lhs.owner_before(__rhs))\n\t{ return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;, __weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n    protected:\n      constexpr __enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&amp;) noexcept { }\n\n      __enable_shared_from_this&amp;\n      operator=(const __enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      shared_from_this()\n      { return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n      __shared_ptr&lt;const _Tp, _Lp&gt;\n      shared_from_this() const\n      { return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n      __weak_ptr&lt;_Tp, _Lp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      __weak_ptr&lt;const _Tp, _Lp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;_Lp&gt;&amp;,\n\t\t\t\t     const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable __weak_ptr&lt;_Tp, _Lp&gt;  _M_weak_this;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename _Alloc, typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return __shared_ptr&lt;_Tp, _Lp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc;\n      return std::__allocate_shared&lt;_Tp, _Lp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t\t      std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for __shared_ptr.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct hash&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public __hash_base&lt;size_t, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    {\n      size_t\n      operator()(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __s) const noexcept\n      {\n\treturn hash&lt;typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*&gt;()(\n\t    __s.get());\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_BASE_H\n"}, "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h": {"id": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "filePath": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "content": "#ifndef SRC_CONTINUOUS_AND_ODE_ODEINT_STEP_SOLVER\n#define SRC_CONTINUOUS_AND_ODE_ODEINT_STEP_SOLVER\n\n\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include &quot;IOdeStepSolver.h&quot;\n#include &lt;boost/numeric/odeint.hpp&gt;\n\nnamespace PySysLinkBase\n{\n    template &lt;typename T&gt; \n    class OdeintStepSolver : public IOdeStepSolver\n    {\n        private:\n            T controlledStepper;\n        public:\n            OdeintStepSolver(T controlledStepper)\n            {\n                this-&gt;controlledStepper = controlledStepper;\n            }\n            std::tuple&lt;bool, std::vector&lt;double&gt;, double&gt; SolveStep(std::function&lt;std::vector&lt;double&gt;(std::vector&lt;double&gt;, double)&gt; system, \n                                                                    std::vector&lt;double&gt; states_0, double currentTime, double timeStep)\n            {\n                // Define the system function in the format expected by ODEINT\n                auto systemFunction = [&amp;system](const std::vector&lt;double&gt; &amp;x, std::vector&lt;double&gt; &amp;dxdt, double t) {\n                    std::vector&lt;double&gt; gradient = system(x, t);\n                    dxdt = gradient; // Assign the computed derivative\n                };\n                \n                \n                // Create the stepper\n                // Stepper stepper;\n\n                // Integrate a single step\n                std::vector&lt;double&gt; newStates = states_0; // Initial state\n                double dt = timeStep;\n\n                boost::numeric::odeint::controlled_step_result result = this-&gt;controlledStepper.try_step(systemFunction, newStates, currentTime, dt);\n                // controlled_step_result result = stepper.try_step(systemFunction, newStates, currentTime, dt);\n\n                system(states_0, currentTime); // Set initial states again, may be optimized\n\n                // Debug log output\n                if (result == boost::numeric::odeint::success)\n                {\n                    return {true, newStates, dt};\n                }\n                else\n                {\n                    return {false, newStates, dt};\n                }\n            }\n    };\n} // namespace PySysLinkBase\n\n#endif /* SRC_CONTINUOUS_AND_ODE_ODEINT_STEP_SOLVER */\n"}, "/usr/include/c++/13/bits/stl_construct.h": {"id": "/usr/include/c++/13/bits/stl_construct.h", "filePath": "/usr/include/c++/13/bits/stl_construct.h", "content": "// nonstandard construct and destroy functions -*- C++ -*-\n\n// Copyright (C) 2001-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided &quot;as is&quot; without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided &quot;as is&quot; without express or implied warranty.\n */\n\n/** @file bits/stl_construct.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _STL_CONSTRUCT_H\n#define _STL_CONSTRUCT_H 1\n\n#include &lt;new&gt;\n#include &lt;bits/move.h&gt;\n#include &lt;bits/stl_iterator_base_types.h&gt; // for iterator_traits\n#include &lt;bits/stl_iterator_base_funcs.h&gt; // for advance\n\n/* This file provides the C++17 functions std::destroy_at, std::destroy, and\n * std::destroy_n, and the C++20 function std::construct_at.\n * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions\n * which are defined in all standard modes and so can be used in C++98-14 code.\n * The _Destroy functions will dispatch to destroy_at during constant\n * evaluation, because calls to that function are intercepted by the compiler\n * to allow use in constant expressions.\n */\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201703L\n  template &lt;typename _Tp&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy_at(_Tp* __location)\n    {\n      if constexpr (__cplusplus &gt; 201703L &amp;&amp; is_array_v&lt;_Tp&gt;)\n\t{\n\t  for (auto&amp; __x : *__location)\n\t    std::destroy_at(std::__addressof(__x));\n\t}\n      else\n\t__location-&gt;~_Tp();\n    }\n\n#if __cplusplus &gt;= 202002L\n  template&lt;typename _Tp, typename... _Args&gt;\n    constexpr auto\n    construct_at(_Tp* __location, _Args&amp;&amp;... __args)\n    noexcept(noexcept(::new((void*)0) _Tp(std::declval&lt;_Args&gt;()...)))\n    -&gt; decltype(::new((void*)0) _Tp(std::declval&lt;_Args&gt;()...))\n    { return ::new((void*)__location) _Tp(std::forward&lt;_Args&gt;(__args)...); }\n#endif // C++20\n#endif// C++17\n\n  /**\n   * Constructs an object in existing memory by invoking an allocated\n   * object&#x27;s constructor with an initializer.\n   */\n#if __cplusplus &gt;= 201103L\n  template&lt;typename _Tp, typename... _Args&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    _Construct(_Tp* __p, _Args&amp;&amp;... __args)\n    {\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\t{\n\t  // Allow std::_Construct to be used in constant expressions.\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n\t  return;\n\t}\n#endif\n      ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n    }\n#else\n  template&lt;typename _T1, typename _T2&gt;\n    inline void\n    _Construct(_T1* __p, const _T2&amp; __value)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_]allocator::construct\n      ::new(static_cast&lt;void*&gt;(__p)) _T1(__value);\n    }\n#endif\n\n  template&lt;typename _T1&gt;\n    inline void\n    _Construct_novalue(_T1* __p)\n    { ::new((void*)__p) _T1; }\n\n  template&lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last);\n\n  /**\n   * Destroy the object pointed to by a pointer type.\n   */\n  template&lt;typename _Tp&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    _Destroy(_Tp* __pointer)\n    {\n#if __cplusplus &gt; 201703L\n      std::destroy_at(__pointer);\n#else\n      __pointer-&gt;~_Tp();\n#endif\n    }\n\n  template&lt;bool&gt;\n    struct _Destroy_aux\n    {\n      template&lt;typename _ForwardIterator&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\t__destroy(_ForwardIterator __first, _ForwardIterator __last)\n\t{\n\t  for (; __first != __last; ++__first)\n\t    std::_Destroy(std::__addressof(*__first));\n\t}\n    };\n\n  template&lt;&gt;\n    struct _Destroy_aux&lt;true&gt;\n    {\n      template&lt;typename _ForwardIterator&gt;\n        static void\n        __destroy(_ForwardIterator, _ForwardIterator) { }\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects&#x27; destructors must be invoked.\n   */\n  template&lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type\n                       _Value_type;\n#if __cplusplus &gt;= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible&lt;_Value_type&gt;::value,\n\t\t    &quot;value type is destructible&quot;);\n#endif\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\treturn std::_Destroy_aux&lt;false&gt;::__destroy(__first, __last);\n#endif\n      std::_Destroy_aux&lt;__has_trivial_destructor(_Value_type)&gt;::\n\t__destroy(__first, __last);\n    }\n\n  template&lt;bool&gt;\n    struct _Destroy_n_aux\n    {\n      template&lt;typename _ForwardIterator, typename _Size&gt;\n\tstatic _GLIBCXX20_CONSTEXPR _ForwardIterator\n\t__destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  for (; __count &gt; 0; (void)++__first, --__count)\n\t    std::_Destroy(std::__addressof(*__first));\n\t  return __first;\n\t}\n    };\n\n  template&lt;&gt;\n    struct _Destroy_n_aux&lt;true&gt;\n    {\n      template&lt;typename _ForwardIterator, typename _Size&gt;\n        static _ForwardIterator\n        __destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  std::advance(__first, __count);\n\t  return __first;\n\t}\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects&#x27; destructors must be invoked.\n   */\n  template&lt;typename _ForwardIterator, typename _Size&gt;\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    _Destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type\n                       _Value_type;\n#if __cplusplus &gt;= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible&lt;_Value_type&gt;::value,\n\t\t    &quot;value type is destructible&quot;);\n#endif\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\treturn std::_Destroy_n_aux&lt;false&gt;::__destroy_n(__first, __count);\n#endif\n      return std::_Destroy_n_aux&lt;__has_trivial_destructor(_Value_type)&gt;::\n\t__destroy_n(__first, __count);\n    }\n\n#if __cplusplus &gt;= 201703L\n  template &lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      std::_Destroy(__first, __last);\n    }\n\n  template &lt;typename _ForwardIterator, typename _Size&gt;\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      return std::_Destroy_n(__first, __count);\n    }\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif /* _STL_CONSTRUCT_H */\n"}, "/usr/include/c++/13/bits/alloc_traits.h": {"id": "/usr/include/c++/13/bits/alloc_traits.h", "filePath": "/usr/include/c++/13/bits/alloc_traits.h", "content": "// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/memoryfwd.h&gt;\n#if __cplusplus &gt;= 201103L\n# include &lt;bits/ptr_traits.h&gt;\n# include &lt;ext/numeric_traits.h&gt;\n# if _GLIBCXX_HOSTED\n#  include &lt;bits/allocator.h&gt;\n# endif\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411L\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template&lt;typename _Tp, typename _Up, typename = void&gt;\n      struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt;\n      {\n\tstatic_assert(is_same&lt;\n\t  typename __replace_first_arg&lt;_Tp, typename _Tp::value_type&gt;::type,\n\t\t\t_Tp&gt;::value,\n\t  &quot;allocator_traits&lt;A&gt;::rebind_alloc&lt;A::value_type&gt; must be A&quot;);\n      };\n\n    template&lt;typename _Tp, typename _Up&gt;\n      struct __rebind&lt;_Tp, _Up,\n\t\t      __void_t&lt;typename _Tp::template rebind&lt;_Up&gt;::other&gt;&gt;\n      {\n\tusing type = typename _Tp::template rebind&lt;_Up&gt;::other;\n\n\tstatic_assert(is_same&lt;\n\t  typename _Tp::template rebind&lt;typename _Tp::value_type&gt;::other,\n\t\t\t_Tp&gt;::value,\n\t  &quot;allocator_traits&lt;A&gt;::rebind_alloc&lt;A::value_type&gt; must be A&quot;);\n      };\n\n  protected:\n    template&lt;typename _Tp&gt;\n      using __pointer = typename _Tp::pointer;\n    template&lt;typename _Tp&gt;\n      using __c_pointer = typename _Tp::const_pointer;\n    template&lt;typename _Tp&gt;\n      using __v_pointer = typename _Tp::void_pointer;\n    template&lt;typename _Tp&gt;\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template&lt;typename _Tp&gt;\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template&lt;typename _Tp&gt;\n      using __equal = __type_identity&lt;typename _Tp::is_always_equal&gt;;\n  };\n\n  template&lt;typename _Alloc, typename _Up&gt;\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind&lt;_Alloc, _Up&gt;::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template&lt;typename _Alloc&gt;\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator&#x27;s pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t&lt;value_type*, __pointer, _Alloc&gt;;\n\n    private:\n      // Select _Func&lt;_Alloc&gt; or pointer_traits&lt;pointer&gt;::rebind&lt;_Tp&gt;\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp, typename = void&gt;\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits&lt;pointer&gt;::template rebind&lt;_Tp&gt;;\n\t};\n\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp&gt;\n\tstruct _Ptr&lt;_Func, _Tp, __void_t&lt;_Func&lt;_Alloc&gt;&gt;&gt;\n\t{\n\t  using type = _Func&lt;_Alloc&gt;;\n\t};\n\n      // Select _A2::difference_type or pointer_traits&lt;_Ptr&gt;::difference_type\n      template&lt;typename _A2, typename _PtrT, typename = void&gt;\n\tstruct _Diff\n\t{ using type = typename pointer_traits&lt;_PtrT&gt;::difference_type; };\n\n      template&lt;typename _A2, typename _PtrT&gt;\n\tstruct _Diff&lt;_A2, _PtrT, __void_t&lt;typename _A2::difference_type&gt;&gt;\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned&lt;_DiffT&gt;::type\n      template&lt;typename _A2, typename _DiffT, typename = void&gt;\n\tstruct _Size : make_unsigned&lt;_DiffT&gt; { };\n\n      template&lt;typename _A2, typename _DiffT&gt;\n\tstruct _Size&lt;_A2, _DiffT, __void_t&lt;typename _A2::size_type&gt;&gt;\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator&#x27;s const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;\n      */\n      using const_pointer = typename _Ptr&lt;__c_pointer, const value_type&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;\n      */\n      using void_pointer = typename _Ptr&lt;__v_pointer, void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;\n      */\n      using const_void_pointer = typename _Ptr&lt;__cv_pointer, const void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;\n      */\n      using difference_type = typename _Diff&lt;_Alloc, pointer&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;\n      */\n      using size_type = typename _Size&lt;_Alloc, difference_type&gt;::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t&lt;false_type, __pocca, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t&lt;false_type, __pocma, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t&lt;false_type, __pocs, _Alloc&gt;;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty&lt;Alloc&gt;::type\n      */\n      using is_always_equal\n\t= typename __detected_or_t&lt;is_empty&lt;_Alloc&gt;, __equal, _Alloc&gt;::type;\n\n      template&lt;typename _Tp&gt;\n\tusing rebind_alloc = __alloc_rebind&lt;_Alloc, _Tp&gt;;\n      template&lt;typename _Tp&gt;\n\tusing rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;\n\n    private:\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint, int)\n\t-&gt; decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstruct __construct_helper\n\t{\n\t  template&lt;typename _Alloc2,\n\t    typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(\n\t\t  std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;\n\t    static true_type __test(int);\n\n\t  template&lt;typename&gt;\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test&lt;_Alloc&gt;(0));\n\t};\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tusing __has_construct\n\t  = typename __construct_helper&lt;_Tp, _Args...&gt;::type;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR _Require&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;\n\t_S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))\n\t{ __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require&lt;__and_&lt;__not_&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;,\n\t\t\t       is_constructible&lt;_Tp, _Args...&gt;&gt;&gt;\n\t_S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Tp, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2&amp; __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-&gt; decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&amp;, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible&lt;_Tp&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&amp;, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max\n\t    / sizeof(value_type);\n\t}\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_select(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2&amp; __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...)))\n\t-&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))\n\t{ _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p-&gt;~_Tp()\n      */\n      template&lt;typename _Tp&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc&amp; __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc&amp; __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc&amp; __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if _GLIBCXX_HOSTED\n\n#if __cplusplus &gt; 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template&lt;typename _Tp&gt;\n    struct allocator_traits&lt;allocator&lt;_Tp&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;_Tp&gt;;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      [[__nodiscard__,__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt;\n      */\n      [[__nodiscard__,__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n,\n\t       [[maybe_unused]] const_void_pointer __hint)\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      [[__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\t[[__gnu__::__always_inline__]]\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template&lt;typename _Up&gt;\n\t[[__gnu__::__always_inline__]]\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      [[__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type&amp; __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      [[__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator&lt;void&gt;.\n  template&lt;&gt;\n    struct allocator_traits&lt;allocator&lt;void&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;void&gt;;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = void*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /// allocate is ill-formed for allocator&lt;void&gt;\n      static void*\n      allocate(allocator_type&amp;, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator&lt;void&gt;\n      static void\n      deallocate(allocator_type&amp;, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\t[[__gnu__::__always_inline__]]\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp;, _Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ std::_Construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template&lt;typename _Up&gt;\n\t[[__gnu__::__always_inline__]]\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp;, _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator&lt;void&gt;\n      static size_type\n      max_size(const allocator_type&amp;) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      [[__gnu__::__always_inline__]]\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n#endif\n\n  /// @cond undocumented\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void\n    __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)\n    { __one = __two; }\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void\n    __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)\n    {\n      using __traits = allocator_traits&lt;_Alloc&gt;;\n      using __pocca =\n\ttypename __traits::propagate_on_container_copy_assignment::type;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc&amp; __a)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    { __one = std::move(__two); }\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      using __traits = allocator_traits&lt;_Alloc&gt;;\n      using __pocma\n\t= typename __traits::propagate_on_container_move_assignment::type;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    [[__gnu__::__always_inline__]]\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      using __traits = allocator_traits&lt;_Alloc&gt;;\n      using __pocs = typename __traits::propagate_on_container_swap::type;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template&lt;typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t&lt;typename _Alloc::value_type&gt;,\n\t   typename = void&gt;\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template&lt;typename _Alloc, typename _Tp, typename _ValueT&gt;\n    struct __is_alloc_insertable_impl&lt;_Alloc, _Tp, _ValueT,\n      __void_t&lt;decltype(allocator_traits&lt;_Alloc&gt;::construct(\n\t\t   std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_ValueT*&gt;(),\n\t\t   std::declval&lt;_Tp&gt;()))&gt;&gt;\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc,\n\t\t\t\t typename _Alloc::value_type const&amp;&gt;::type\n    { };\n\n#if _GLIBCXX_HOSTED\n  // std::allocator&lt;_Tp&gt; just requires CopyConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_copy_constructible&lt;_Tp&gt;\n    { };\n#endif\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc, typename _Alloc::value_type&gt;::type\n    { };\n\n#if _GLIBCXX_HOSTED\n  // std::allocator&lt;_Tp&gt; just requires MoveConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_move_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_move_constructible&lt;_Tp&gt;\n    { };\n#endif\n\n  // Trait to detect Allocator-like types.\n  template&lt;typename _Alloc, typename = void&gt;\n    struct __is_allocator : false_type { };\n\n  template&lt;typename _Alloc&gt;\n    struct __is_allocator&lt;_Alloc,\n      __void_t&lt;typename _Alloc::value_type,\n\t       decltype(std::declval&lt;_Alloc&amp;&gt;().allocate(size_t{}))&gt;&gt;\n    : true_type { };\n\n  template&lt;typename _Alloc&gt;\n    using _RequireAllocator\n      = typename enable_if&lt;__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n  template&lt;typename _Alloc&gt;\n    using _RequireNotAllocator\n      = typename enable_if&lt;!__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n#if __cpp_concepts &gt;= 201907L\n  template&lt;typename _Alloc&gt;\n    concept __allocator_like = requires (_Alloc&amp; __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n  /// @endcond\n#endif // C++11\n\n  /// @cond undocumented\n\n  // To implement Option 3 of DR 431.\n  template&lt;typename _Alloc, bool = __is_empty(_Alloc)&gt;\n    struct __alloc_swap\n    { static void _S_do_it(_Alloc&amp;, _Alloc&amp;) _GLIBCXX_NOEXCEPT { } };\n\n  template&lt;typename _Alloc&gt;\n    struct __alloc_swap&lt;_Alloc, false&gt;\n    {\n      static void\n      _S_do_it(_Alloc&amp; __one, _Alloc&amp; __two) _GLIBCXX_NOEXCEPT\n      {\n\t// Precondition: swappable allocators.\n\tif (__one != __two)\n\t  swap(__one, __two);\n      }\n    };\n\n#if __cplusplus &gt;= 201103L\n  template&lt;typename _Tp, bool\n    = __or_&lt;is_copy_constructible&lt;typename _Tp::value_type&gt;,\n            is_nothrow_move_constructible&lt;typename _Tp::value_type&gt;&gt;::value&gt;\n    struct __shrink_to_fit_aux\n    { static bool _S_do_it(_Tp&amp;) noexcept { return false; } };\n\n  template&lt;typename _Tp&gt;\n    struct __shrink_to_fit_aux&lt;_Tp, true&gt;\n    {\n      _GLIBCXX20_CONSTEXPR\n      static bool\n      _S_do_it(_Tp&amp; __c) noexcept\n      {\n#if __cpp_exceptions\n\ttry\n\t  {\n\t    _Tp(__make_move_if_noexcept_iterator(__c.begin()),\n\t\t__make_move_if_noexcept_iterator(__c.end()),\n\t\t__c.get_allocator()).swap(__c);\n\t    return true;\n\t  }\n\tcatch(...)\n\t  { return false; }\n#else\n\treturn false;\n#endif\n      }\n    };\n#endif\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    _GLIBCXX20_CONSTEXPR\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator&amp; __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus &lt; 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits&lt;_Allocator&gt;::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n#if _GLIBCXX_HOSTED\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    __attribute__((__always_inline__)) _GLIBCXX20_CONSTEXPR\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator&lt;_Tp&gt;&amp;)\n    {\n      std::_Destroy(__first, __last);\n    }\n#endif\n  /// @endcond\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}, "/usr/include/c++/13/bits/shared_ptr.h": {"id": "/usr/include/c++/13/bits/shared_ptr.h", "filePath": "/usr/include/c++/13/bits/shared_ptr.h", "content": "// shared_ptr and weak_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2007-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_H\n#define _SHARED_PTR_H 1\n\n#include &lt;iosfwd&gt;           \t  // std::basic_ostream\n#include &lt;bits/shared_ptr_base.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n  // 20.7.2.2.11 shared_ptr I/O\n\n  /// Write the stored pointer to an ostream.\n  /// @relates shared_ptr\n  template&lt;typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp&gt;\n    inline std::basic_ostream&lt;_Ch, _Tr&gt;&amp;\n    operator&lt;&lt;(std::basic_ostream&lt;_Ch, _Tr&gt;&amp; __os,\n\t       const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p)\n    {\n      __os &lt;&lt; __p.get();\n      return __os;\n    }\n\n  template&lt;typename _Del, typename _Tp, _Lock_policy _Lp&gt;\n    inline _Del*\n    get_deleter(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// 20.7.2.2.10 shared_ptr get_deleter\n\n  /// If `__p` has a deleter of type `_Del`, return a pointer to it.\n  /// @relates shared_ptr\n  template&lt;typename _Del, typename _Tp&gt;\n    inline _Del*\n    get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// @cond undocumented\n\n  // Constraint for overloads taking non-array types.\n#if __cpp_concepts &amp;&amp; __cpp_lib_type_trait_variable_templates\n  template&lt;typename _Tp&gt;\n    requires (!is_array_v&lt;_Tp&gt;)\n    using _NonArray = _Tp;\n#else\n  template&lt;typename _Tp&gt;\n    using _NonArray = __enable_if_t&lt;!is_array&lt;_Tp&gt;::value, _Tp&gt;;\n#endif\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n  // Constraint for overloads taking array types with unknown bound, U[].\n#if __cpp_concepts\n  template&lt;typename _Tp&gt;\n    requires is_array_v&lt;_Tp&gt; &amp;&amp; (extent_v&lt;_Tp&gt; == 0)\n    using _UnboundedArray = _Tp;\n#else\n  template&lt;typename _Tp&gt;\n    using _UnboundedArray\n      = __enable_if_t&lt;__is_array_unknown_bounds&lt;_Tp&gt;::value, _Tp&gt;;\n#endif\n\n  // Constraint for overloads taking array types with known bound, U[N].\n#if __cpp_concepts\n  template&lt;typename _Tp&gt;\n    requires (extent_v&lt;_Tp&gt; != 0)\n    using _BoundedArray = _Tp;\n#else\n  template&lt;typename _Tp&gt;\n    using _BoundedArray\n      = __enable_if_t&lt;__is_array_known_bounds&lt;_Tp&gt;::value, _Tp&gt;;\n#endif\n\n#if __cpp_lib_smart_ptr_for_overwrite\n  // Constraint for overloads taking either non-array or bounded array, U[N].\n#if __cpp_concepts\n  template&lt;typename _Tp&gt;\n    requires (!is_array_v&lt;_Tp&gt;) || (extent_v&lt;_Tp&gt; != 0)\n    using _NotUnboundedArray = _Tp;\n#else\n  template&lt;typename _Tp&gt;\n    using _NotUnboundedArray\n      = __enable_if_t&lt;!__is_array_unknown_bounds&lt;_Tp&gt;::value, _Tp&gt;;\n#endif\n#endif // smart_ptr_for_overwrite\n#endif // shared_ptr_arrays\n\n  /// @endcond\n\n  /**\n   *  @brief  A smart pointer with reference-counted copy semantics.\n   *  @headerfile memory\n   *  @since C++11\n   *\n   * A `shared_ptr` object is either empty or _owns_ a pointer passed\n   * to the constructor. Copies of a `shared_ptr` share ownership of\n   * the same pointer. When the last `shared_ptr` that owns the pointer\n   * is destroyed or reset, the owned pointer is freed (either by `delete`\n   * or by invoking a custom deleter that was passed to the constructor).\n   *\n   * A `shared_ptr` also stores another pointer, which is usually\n   * (but not always) the same pointer as it owns. The stored pointer\n   * can be retrieved by calling the `get()` member function.\n   *\n   * The equality and relational operators for `shared_ptr` only compare\n   * the stored pointer returned by `get()`, not the owned pointer.\n   * To test whether two `shared_ptr` objects share ownership of the same\n   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.\n  */\n  template&lt;typename _Tp&gt;\n    class shared_ptr : public __shared_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__shared_ptr&lt;_Tp&gt;, _Args...&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__shared_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, shared_ptr&amp;\n\t&gt;::type;\n\n    public:\n\n      /// The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;\n      using element_type = typename __shared_ptr&lt;_Tp&gt;::element_type;\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_shared_ptr_weak_type 201606L\n      /// The corresponding weak_ptr type for this shared_ptr\n      /// @since C++17\n      using weak_type = weak_ptr&lt;_Tp&gt;;\n#endif\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count()==0 &amp;&amp; get()==0\n       */\n      constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() { }\n\n      shared_ptr(const shared_ptr&amp;) noexcept = default; ///&lt; Copy constructor\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n       *  @param  __p  A pointer that is convertible to element_type*.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;_Yp*&gt;&gt;\n\texplicit\n\tshared_ptr(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter,\n\t       typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _Constructible&lt;_Yp*, _Deleter, _Alloc&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter, typename _Alloc&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      // Aliasing constructor\n\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; use_count() == __r.use_count()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(__r, __p) { }\n\n#if __cplusplus &gt; 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2996. Missing rvalue overloads for shared_ptr operations\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()`\n       *  @since C++17\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);\n       * assert(pii.use_count() == 0);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __p) { }\n#endif\n      /**\n       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n       *          otherwise construct a %shared_ptr that shares ownership\n       *          with @a __r.\n       *  @param  __r  A %shared_ptr.\n       *  @post   get() == __r.get() &amp;&amp; use_count() == __r.use_count()\n       */\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n        : __shared_ptr&lt;_Tp&gt;(__r) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n       *          and stores a copy of the pointer stored in @a __r.\n       *  @param  __r  A weak_ptr.\n       *  @post   use_count() == __r.use_count()\n       *  @throw  bad_weak_ptr when __r.expired(),\n       *          in which case the constructor has no effect.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\texplicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(__r) { }\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp, typename = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2399. shared_ptr&#x27;s constructor from unique_ptr should be constrained\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n      // This non-standard constructor exists to support conversions that\n      // were possible in C++11 and C++14 but are ill-formed in C++17.\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t\t_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;, __sp_array_delete&gt;* = 0&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __sp_array_delete()) { }\n#endif\n\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count() == 0 &amp;&amp; get() == nullptr\n       */\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr&amp; operator=(const shared_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;auto_ptr&lt;_Yp&gt;&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      shared_ptr&amp;\n      operator=(shared_ptr&amp;&amp; __r) noexcept\n      {\n\tthis-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;shared_ptr&lt;_Yp&gt;&gt;\n\toperator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_Assignable&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n    private:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\tshared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: __shared_ptr&lt;_Tp&gt;(__tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc, typename... _Args&gt;\n\tfriend shared_ptr&lt;_NonArray&lt;_Yp&gt;&gt;\n\tallocate_shared(const _Alloc&amp;, _Args&amp;&amp;...);\n\n      template&lt;typename _Yp, typename... _Args&gt;\n\tfriend shared_ptr&lt;_NonArray&lt;_Yp&gt;&gt;\n\tmake_shared(_Args&amp;&amp;...);\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n      // This constructor is non-standard, it is used by allocate_shared&lt;T[]&gt;.\n      template&lt;typename _Alloc, typename _Init = const remove_extent_t&lt;_Tp&gt;*&gt;\n\tshared_ptr(const _Sp_counted_array_base&lt;_Alloc&gt;&amp; __a,\n\t\t   _Init __init = nullptr)\n\t: __shared_ptr&lt;_Tp&gt;(__a, __init)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared(const _Alloc&amp;, size_t);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tmake_shared(size_t);\n\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared(const _Alloc&amp;, size_t, const remove_extent_t&lt;_Yp&gt;&amp;);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tmake_shared(size_t, const remove_extent_t&lt;_Yp&gt;&amp;);\n\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_BoundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared(const _Alloc&amp;);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_BoundedArray&lt;_Yp&gt;&gt;\n\tmake_shared();\n\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_BoundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared(const _Alloc&amp;, const remove_extent_t&lt;_Yp&gt;&amp;);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_BoundedArray&lt;_Yp&gt;&gt;\n\tmake_shared(const remove_extent_t&lt;_Yp&gt;&amp;);\n\n#if __cpp_lib_smart_ptr_for_overwrite\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_NotUnboundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared_for_overwrite(const _Alloc&amp;);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_NotUnboundedArray&lt;_Yp&gt;&gt;\n\tmake_shared_for_overwrite();\n\n      template&lt;typename _Yp, typename _Alloc&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tallocate_shared_for_overwrite(const _Alloc&amp;, size_t);\n\n      template&lt;typename _Yp&gt;\n\tfriend shared_ptr&lt;_UnboundedArray&lt;_Yp&gt;&gt;\n\tmake_shared_for_overwrite(size_t);\n#endif\n#endif\n\n      // This constructor is non-standard, it is used by weak_ptr::lock().\n      shared_ptr(const weak_ptr&lt;_Tp&gt;&amp; __r, std::nothrow_t) noexcept\n      : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) { }\n\n      friend class weak_ptr&lt;_Tp&gt;;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    shared_ptr(weak_ptr&lt;_Tp&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n  template&lt;typename _Tp, typename _Del&gt;\n    shared_ptr(unique_ptr&lt;_Tp, _Del&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.2.7 shared_ptr comparisons\n\n  /// @relates shared_ptr @{\n\n  /// Equality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a,\n\t\tconst shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename shared_ptr&lt;_Tp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  /// Inequality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      using _Up_elt = typename shared_ptr&lt;_Up&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n\n  /// Swap overload for shared_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(shared_ptr&lt;_Tp&gt;&amp; __a, shared_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts.\n\n  /// Convert type of `shared_ptr`, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt;= 201703L\n  /// Convert type of `shared_ptr`, via `reinterpret_cast`\n  /// @since C++17\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n#if __cplusplus &gt; 201703L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2996. Missing rvalue overloads for shared_ptr operations\n\n  /// Convert type of `shared_ptr` rvalue, via `static_cast`\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `const_cast`\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(std::move(__r), __p);\n      return _Sp();\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`\n  /// @since C++20\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif // C++20\n#endif // C++17\n\n  /// @}\n\n  /**\n   * @brief  A non-owning observer for a pointer owned by a shared_ptr\n   * @headerfile memory\n   * @since C++11\n   *\n   * A weak_ptr provides a safe alternative to a raw pointer when you want\n   * a non-owning reference to an object that is managed by a shared_ptr.\n   *\n   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr\n   * that shares ownership with every other shared_ptr that already owns\n   * the pointer. In other words you can upgrade from a non-owning &quot;weak&quot;\n   * reference to an owning shared_ptr, without having access to any of\n   * the existing shared_ptr objects.\n   *\n   * Also unlike a raw pointer, a weak_ptr does not become &quot;dangling&quot; after\n   * the object it points to has been destroyed. Instead, a weak_ptr\n   * becomes _expired_ and can no longer be converted to a shared_ptr that\n   * owns the freed pointer, so you cannot accidentally access the pointed-to\n   * object after it has been destroyed.\n   */\n  template&lt;typename _Tp&gt;\n    class weak_ptr : public __weak_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename _Arg&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__weak_ptr&lt;_Tp&gt;, _Arg&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__weak_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, weak_ptr&amp;\n\t&gt;::type;\n\n    public:\n      constexpr weak_ptr() noexcept = default;\n\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(const weak_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(weak_ptr&amp;&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;weak_ptr&lt;_Yp&gt;&gt;&gt;\n\tweak_ptr(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      weak_ptr&amp;\n      operator=(const weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      weak_ptr&amp;\n      operator=(weak_ptr&amp;&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;weak_ptr&lt;_Yp&gt;&gt;\n\toperator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      shared_ptr&lt;_Tp&gt;\n      lock() const noexcept\n      { return shared_ptr&lt;_Tp&gt;(*this, std::nothrow); }\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    weak_ptr(shared_ptr&lt;_Tp&gt;) -&gt;  weak_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  /// Swap overload for weak_ptr\n  /// @relates weak_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(weak_ptr&lt;_Tp&gt;&amp; __a, weak_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n\n  /// Primary template owner_less\n  template&lt;typename _Tp = void&gt;\n    struct owner_less;\n\n  /// Void specialization of owner_less compares either shared_ptr or weak_ptr\n  template&lt;&gt;\n    struct owner_less&lt;void&gt; : _Sp_owner_less&lt;void, void&gt;\n    { };\n\n  /// Partial specialization of owner_less for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;shared_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /// Partial specialization of owner_less for weak_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;weak_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;weak_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /**\n   * @brief Base class allowing use of the member function `shared_from_this`.\n   * @headerfile memory\n   * @since C++11\n   */\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    {\n    protected:\n      constexpr enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept { }\n\n      enable_shared_from_this&amp;\n      operator=(const enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603L\n      /** @{\n       * Get a `weak_ptr` referring to the object that has `*this` as its base.\n       * @since C++17\n       */\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n      /// @}\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      // Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    };\n\n  /// @relates shared_ptr @{\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __a     An allocator.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n   *          constructor of @a _Tp.\n   *\n   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n   *  and the new object.\n   */\n  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_NonArray&lt;_Tp&gt;&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  std::bad_alloc, or an exception thrown from the\n   *          constructor of @a _Tp.\n   */\n  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_NonArray&lt;_Tp&gt;&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      using _Alloc = allocator&lt;void&gt;;\n      _Alloc __a;\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n#if __cpp_lib_shared_ptr_arrays &gt;= 201707L\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Alloc = allocator&lt;void&gt;&gt;\n    auto\n    __make_shared_arr_tag(size_t __n, const _Alloc&amp; __a = _Alloc()) noexcept\n    {\n      using _Up = remove_all_extents_t&lt;_Tp&gt;;\n      using _UpAlloc = __alloc_rebind&lt;_Alloc, _Up&gt;;\n      size_t __s = sizeof(remove_extent_t&lt;_Tp&gt;) / sizeof(_Up);\n      if (__builtin_mul_overflow(__s, __n, &amp;__n))\n\tstd::__throw_bad_array_new_length();\n      return _Sp_counted_array_base&lt;_UpAlloc&gt;{_UpAlloc(__a), __n};\n    }\n  /// @endcond\n\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    allocate_shared(const _Alloc&amp; __a, size_t __n)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n, __a));\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    make_shared(size_t __n)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n));\n    }\n\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    allocate_shared(const _Alloc&amp; __a, size_t __n,\n\t\t    const remove_extent_t&lt;_Tp&gt;&amp; __u)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n, __a),\n\t\t\t     std::__addressof(__u));\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    make_shared(size_t __n, const remove_extent_t&lt;_Tp&gt;&amp; __u)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n),\n\t\t\t     std::__addressof(__u));\n    }\n\n  /// @cond undocumented\n  template&lt;typename _Tp, typename _Alloc = allocator&lt;void&gt;&gt;\n    auto\n    __make_shared_arrN_tag(const _Alloc&amp; __a = _Alloc()) noexcept\n    {\n      using _Up = remove_all_extents_t&lt;_Tp&gt;;\n      using _UpAlloc = __alloc_rebind&lt;_Alloc, _Up&gt;;\n      size_t __n = sizeof(_Tp) / sizeof(_Up);\n      return _Sp_counted_array_base&lt;_UpAlloc&gt;{_UpAlloc(__a), __n};\n    }\n  /// @endcond\n\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_BoundedArray&lt;_Tp&gt;&gt;\n    allocate_shared(const _Alloc&amp; __a)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;(__a));\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_BoundedArray&lt;_Tp&gt;&gt;\n    make_shared()\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;());\n    }\n\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_BoundedArray&lt;_Tp&gt;&gt;\n    allocate_shared(const _Alloc&amp; __a, const remove_extent_t&lt;_Tp&gt;&amp; __u)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;(__a),\n\t\t\t     std::__addressof(__u));\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_BoundedArray&lt;_Tp&gt;&gt;\n    make_shared(const remove_extent_t&lt;_Tp&gt;&amp; __u)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;(),\n\t\t\t     std::__addressof(__u));\n    }\n\n#if __cpp_lib_smart_ptr_for_overwrite\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_NotUnboundedArray&lt;_Tp&gt;&gt;\n    allocate_shared_for_overwrite(const _Alloc&amp; __a)\n    {\n      if constexpr (is_array_v&lt;_Tp&gt;)\n\treturn shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;(__a),\n\t\t\t       _Sp_overwrite_tag{});\n      else\n\t{\n\t  // Rebind the allocator to _Sp_overwrite_tag, so that the\n\t  // relevant _Sp_counted_ptr_inplace specialization is used.\n\t  using _Alloc2 = __alloc_rebind&lt;_Alloc, _Sp_overwrite_tag&gt;;\n\t  _Alloc2 __a2 = __a;\n\t  return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc2&gt;{__a2});\n\t}\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_NotUnboundedArray&lt;_Tp&gt;&gt;\n    make_shared_for_overwrite()\n    {\n      if constexpr (is_array_v&lt;_Tp&gt;)\n\treturn shared_ptr&lt;_Tp&gt;(std::__make_shared_arrN_tag&lt;_Tp&gt;(),\n\t\t\t       _Sp_overwrite_tag{});\n      else\n\t{\n\t  using _Alloc = allocator&lt;_Sp_overwrite_tag&gt;;\n\t  return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{{}});\n\t}\n    }\n\n  template&lt;typename _Tp, typename _Alloc&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    allocate_shared_for_overwrite(const _Alloc&amp; __a, size_t __n)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n, __a),\n\t\t\t     _Sp_overwrite_tag{});\n    }\n\n  template&lt;typename _Tp&gt;\n    inline shared_ptr&lt;_UnboundedArray&lt;_Tp&gt;&gt;\n    make_shared_for_overwrite(size_t __n)\n    {\n      return shared_ptr&lt;_Tp&gt;(std::__make_shared_arr_tag&lt;_Tp&gt;(__n),\n\t\t\t     _Sp_overwrite_tag{});\n    }\n#endif // smart_ptr_for_overwrite\n#endif // shared_ptr_arrays\n\n  /// std::hash specialization for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct hash&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public __hash_base&lt;size_t, shared_ptr&lt;_Tp&gt;&gt;\n    {\n      size_t\n      operator()(const shared_ptr&lt;_Tp&gt;&amp; __s) const noexcept\n      {\n\treturn std::hash&lt;typename shared_ptr&lt;_Tp&gt;::element_type*&gt;()(__s.get());\n      }\n    };\n\n  /// @} relates shared_ptr\n  /// @} group pointer_abstractions\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // shared_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::shared_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // weak_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::weak_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_H\n"}, "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp": {"id": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "filePath": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "content": "#include &quot;SolverFactory.h&quot;\n#include &quot;OdeintStepSolver.h&quot;\n#include &quot;EulerForwardStepSolver.h&quot;\n#include &quot;EulerBackwardStepSolver.h&quot;\n#include &quot;OdeintImplicitStepSolver.h&quot;\n#include &quot;spdlog/spdlog.h&quot;\n\nnamespace PySysLinkBase\n{\n    std::shared_ptr&lt;IOdeStepSolver&gt; SolverFactory::CreateOdeStepSolver(std::map&lt;std::string, ConfigurationValue&gt; solverConfiguration)\n    {\n        std::string solverType = ConfigurationValueManager::TryGetConfigurationValue&lt;std::string&gt;(&quot;Type&quot;, solverConfiguration);\n\n        if (solverType == &quot;odeint&quot;)\n        {\n            std::string controlledSolver = ConfigurationValueManager::TryGetConfigurationValue&lt;std::string&gt;(&quot;ControlledSolver&quot;, solverConfiguration);\n\n            double absoluteTolerance = 1e-8;\n            double relativeTolerance = 1e-8;\n            try\n            {\n                absoluteTolerance = ConfigurationValueManager::TryGetConfigurationValue&lt;double&gt;(&quot;AbsoluteTolerance&quot;, solverConfiguration);\n            }\n            catch (std::out_of_range const&amp; ex)\n            {\n                spdlog::get(&quot;default_pysyslink&quot;)-&gt;debug(&quot;Absolute tolerance not found in configuration, using default value: {}&quot;, absoluteTolerance);\n            }\n            try\n            {\n                relativeTolerance = ConfigurationValueManager::TryGetConfigurationValue&lt;double&gt;(&quot;RelativeTolerance&quot;, solverConfiguration);\n            }\n            catch (std::out_of_range const&amp; ex)\n            {\n                spdlog::get(&quot;default_pysyslink&quot;)-&gt;debug(&quot;Relative tolerance not found in configuration, using default value: {}&quot;, relativeTolerance);\n            }\n\n            if (controlledSolver == &quot;runge_kutta_cash_karp54&quot;)\n            {\n                auto controlledStepper = boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_cash_karp54&lt;std::vector&lt;double&gt;&gt;());\n                using controlledStepperType = decltype(boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_cash_karp54&lt;std::vector&lt;double&gt;&gt;()));\n                return std::make_shared&lt;OdeintStepSolver&lt;controlledStepperType&gt;&gt;(controlledStepper);\n            }\n            else if (controlledSolver == &quot;runge_kutta_dopri5&quot;)\n            {\n                auto controlledStepper = boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_dopri5&lt;std::vector&lt;double&gt;&gt;());\n                using controlledStepperType = decltype(boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_dopri5&lt;std::vector&lt;double&gt;&gt;()));\n                return std::make_shared&lt;OdeintStepSolver&lt;controlledStepperType&gt;&gt;(controlledStepper);\n            }\n            else if (controlledSolver == &quot;runge_kutta_fehlberg78&quot;)\n            {\n                auto controlledStepper = boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_fehlberg78&lt;std::vector&lt;double&gt;&gt;());\n                using controlledStepperType = decltype(boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::runge_kutta_fehlberg78&lt;std::vector&lt;double&gt;&gt;()));\n                return std::make_shared&lt;OdeintStepSolver&lt;controlledStepperType&gt;&gt;(controlledStepper);\n            }\n            else if (controlledSolver == &quot;rosenbrock4_controller&quot;) // TODO: this does not seem to work\n            {\n                auto controlledStepper = std::make_shared&lt;boost::numeric::odeint::rosenbrock4_controller&lt;boost::numeric::odeint::rosenbrock4&lt;double&gt;&gt;&gt;(absoluteTolerance, relativeTolerance);\n                using controlledStepperType = decltype(boost::numeric::odeint::rosenbrock4_controller&lt;boost::numeric::odeint::rosenbrock4&lt;double&gt;&gt;());\n                return std::make_shared&lt;OdeintImplicitStepSolver&lt;controlledStepperType&gt;&gt;(controlledStepper);\n            }\n            // else if (controlledSolver == &quot;bulirsch_stoer&quot;)\n            // {\n            //     auto controlledStepper = boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::bulirsch_stoer&lt;std::vector&lt;double&gt;&gt;());\n            //     using controlledStepperType = decltype(boost::numeric::odeint::make_controlled(absoluteTolerance, relativeTolerance, boost::numeric::odeint::bulirsch_stoer&lt;std::vector&lt;double&gt;&gt;()));\n            //     return std::make_shared&lt;OdeintStepSolver&lt;controlledStepperType&gt;&gt;(controlledStepper);\n            // }\n            else\n            {\n                throw std::invalid_argument(&quot;Controlled solver not recognized&quot;);\n            }\n        }\n        else if (solverType == &quot;EulerForward&quot;)\n        {\n            return std::make_shared&lt;EulerForwardStepSolver&gt;();\n        }\n        else if (solverType == &quot;EulerBackward&quot;)\n        {\n            double maximumIterations = 50;\n            double tolerance = 1e-6;\n            try\n            {\n                maximumIterations = ConfigurationValueManager::TryGetConfigurationValue&lt;double&gt;(&quot;MaximumIterations&quot;, solverConfiguration);\n            }\n            catch (std::out_of_range const&amp; ex)\n            {\n                spdlog::get(&quot;default_pysyslink&quot;)-&gt;debug(&quot;Maximum iterations not found in configuration, using default value: {}&quot;, maximumIterations);\n            }\n            try\n            {\n                tolerance = ConfigurationValueManager::TryGetConfigurationValue&lt;double&gt;(&quot;Tolerance&quot;, solverConfiguration);\n            }\n            catch (std::out_of_range const&amp; ex)\n            {\n                spdlog::get(&quot;default_pysyslink&quot;)-&gt;debug(&quot;Tolerance not found in configuration, using default value: {}&quot;, tolerance);\n            }\n            return std::make_shared&lt;EulerBackwardStepSolver&gt;(maximumIterations, tolerance);\n        }\n        else\n        {\n            throw std::invalid_argument(&quot;Solver type not recognized&quot;);\n        }\n    }\n} // namespace PySysLinkBase\n"}}, "reports": [{"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "1d0db78f457b7e4c71542f8a571d172b", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 16, "column": 11, "message": "'PySysLinkBase::EulerBackwardStepSolver' has virtual functions but non-virtual destructor", "events": [{"message": "'PySysLinkBase::EulerBackwardStepSolver' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 16, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "23ad9520fb34f5561c0003ac3617f113", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 16, "column": 11, "message": "destructor of 'EulerBackwardStepSolver' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 16, "column": 11}, {"message": "destructor of 'EulerBackwardStepSolver' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 16, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "13b77e074939549f3ba55bc9f3bbd08e", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 23, "column": 141, "message": "unused parameter 'system'", "events": [{"message": "unused parameter 'system'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 23, "column": 141}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "2a78999be69b3cc18eee7fb06ecfbd19", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 24, "column": 89, "message": "unused parameter 'states_0'", "events": [{"message": "unused parameter 'states_0'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 24, "column": 89}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "a373bce011c524803a827bde47288012", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 24, "column": 106, "message": "unused parameter 'currentTime'", "events": [{"message": "unused parameter 'currentTime'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 24, "column": 106}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "reportHash": "57c2c27bf9e86aeac9176c9e0fd254bf", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 24, "column": 126, "message": "unused parameter 'timeStep'", "events": [{"message": "unused parameter 'timeStep'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerBackwardStepSolver.h", "line": 24, "column": 126}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "fa9bb100908691337caa2e601ef7103c", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 12, "column": 11, "message": "'PySysLinkBase::EulerForwardStepSolver' has virtual functions but non-virtual destructor", "events": [{"message": "'PySysLinkBase::EulerForwardStepSolver' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 12, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "7229156e6df6d56c31afba49738512af", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 11, "message": "destructor of 'EulerForwardStepSolver' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 12, "column": 11}, {"message": "destructor of 'EulerForwardStepSolver' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 12, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "713828e18d84796f47f47d35c8e0464b", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 21, "column": 141, "message": "unused parameter 'systemDerivatives'", "events": [{"message": "unused parameter 'systemDerivatives'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 21, "column": 141}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "2c3a40c153629b17a726efc3388b76a5", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 22, "column": 146, "message": "unused parameter 'systemJacobian'", "events": [{"message": "unused parameter 'systemJacobian'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 22, "column": 146}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "1210f6130fa52a312c5dd05fa28b0064", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 23, "column": 89, "message": "unused parameter 'states_0'", "events": [{"message": "unused parameter 'states_0'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 23, "column": 89}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "4d72f153a6d5e7e31704ada4960e450b", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 23, "column": 106, "message": "unused parameter 'currentTime'", "events": [{"message": "unused parameter 'currentTime'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 23, "column": 106}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "reportHash": "7981c0861651df2a7b194d49749d9e5c", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 23, "column": 126, "message": "unused parameter 'timeStep'", "events": [{"message": "unused parameter 'timeStep'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/EulerForwardStepSolver.h", "line": 23, "column": 126}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "dec4758aed5d4fd65c3224cc40a41905", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 17, "column": 11, "message": "'PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of template class 'PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' requested here", "fileId": "/usr/include/c++/13/type_traits", "line": 1417, "column": 57}, {"message": "in instantiation of template class 'std::is_convertible<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1270, "column": 7}, {"message": "in instantiation of template class 'std::__sp_compatible_with<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1437, "column": 14}, {"message": "in instantiation of template type alias '_Compatible' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1526, "column": 41}, {"message": "in instantiation of default argument for '__shared_ptr<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>>' required here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1527, "column": 2}, {"message": "'PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 17, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "5d1429636d2cb68ea0d7d677f06edfc7", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 11, "message": "destructor of 'OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 17, "column": 11}, {"message": "destructor of 'OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 17, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "48a497c38f82af5873150f231ba8789f", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 63, "column": 141, "message": "unused parameter 'system'", "events": [{"message": "unused parameter 'system'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 63, "column": 141}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "02e2ba9dffaa20d3b0d79c7a26960bef", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 64, "column": 89, "message": "unused parameter 'states_0'", "events": [{"message": "unused parameter 'states_0'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 64, "column": 89}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "2c679911b8ddfdd4088441ae88a6b6f8", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 64, "column": 106, "message": "unused parameter 'currentTime'", "events": [{"message": "unused parameter 'currentTime'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 64, "column": 106}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "reportHash": "53adb81f7a7154a2e5809dee2a35c47b", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "checker": {"name": "clang-diagnostic-unused-parameter", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wunused-parameter"}, "analyzerName": "clang-tidy", "line": 64, "column": 126, "message": "unused parameter 'timeStep'", "events": [{"message": "unused parameter 'timeStep'", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintImplicitStepSolver.h", "line": 64, "column": 126}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "37fe1185a6d7c19ceb258af95f5f8789", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of template class 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' requested here", "fileId": "/usr/include/c++/13/type_traits", "line": 1417, "column": 57}, {"message": "in instantiation of template class 'std::is_convertible<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1270, "column": 7}, {"message": "in instantiation of template class 'std::__sp_compatible_with<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1437, "column": 14}, {"message": "in instantiation of template type alias '_Compatible' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1526, "column": 41}, {"message": "in instantiation of default argument for '__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>>' required here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1527, "column": 2}, {"message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "ce07fde1453766fc4a515a5bc452bec1", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of template class 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' requested here", "fileId": "/usr/include/c++/13/type_traits", "line": 1417, "column": 57}, {"message": "in instantiation of template class 'std::is_convertible<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1270, "column": 7}, {"message": "in instantiation of template class 'std::__sp_compatible_with<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1437, "column": 14}, {"message": "in instantiation of template type alias '_Compatible' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1526, "column": 41}, {"message": "in instantiation of default argument for '__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>>' required here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1527, "column": 2}, {"message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "ef78f11fe4348d1f28040c2a229591ea", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "clang-diagnostic-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wnon-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of template class 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' requested here", "fileId": "/usr/include/c++/13/type_traits", "line": 1417, "column": 57}, {"message": "in instantiation of template class 'std::is_convertible<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1270, "column": 7}, {"message": "in instantiation of template class 'std::__sp_compatible_with<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>> *, PySysLinkBase::IOdeStepSolver *>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1437, "column": 14}, {"message": "in instantiation of template type alias '_Compatible' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1526, "column": 41}, {"message": "in instantiation of default argument for '__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>>' required here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1527, "column": 2}, {"message": "'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' has virtual functions but non-virtual destructor", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "ae690f3aebc78384be968ef515c90808", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}, {"message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "bcc74b1f75cd922d45f8b4cb9bee7ef8", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}, {"message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "reportHash": "3ea014a20fe8b269d8dbe197865e8d84", "path": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 11, "message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}, {"message": "destructor of 'OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' is public and non-virtual", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/OdeintStepSolver.h", "line": 14, "column": 11}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "3b76278ff470bb904fb708a6e7603d13", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::EulerBackwardStepSolver' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::EulerBackwardStepSolver>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::EulerBackwardStepSolver>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::EulerBackwardStepSolver, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::EulerBackwardStepSolver, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<double &, double &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::EulerBackwardStepSolver, std::allocator<void>, double &, double &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::EulerBackwardStepSolver>::__shared_ptr<std::allocator<void>, double &, double &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::EulerBackwardStepSolver>::shared_ptr<std::allocator<void>, double &, double &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::EulerBackwardStepSolver, double &, double &>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 96, "column": 25}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::EulerBackwardStepSolver' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "f6cc8ff24a23ab792319281235713d4f", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::EulerForwardStepSolver' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::EulerForwardStepSolver>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::EulerForwardStepSolver>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::EulerForwardStepSolver, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::EulerForwardStepSolver, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::EulerForwardStepSolver, std::allocator<void>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::EulerForwardStepSolver>::__shared_ptr<std::allocator<void>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::EulerForwardStepSolver>::shared_ptr<std::allocator<void>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::EulerForwardStepSolver>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 74, "column": 25}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::EulerForwardStepSolver' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "e2ff4cb92852d5041d5362a7726cf0a5", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<std::shared_ptr<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>, std::allocator<void>, std::shared_ptr<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>>::__shared_ptr<std::allocator<void>, std::shared_ptr<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>>::shared_ptr<std::allocator<void>, std::shared_ptr<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>, std::shared_ptr<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>> &>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 59, "column": 29}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::OdeintImplicitStepSolver<boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>>>' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "5d2a85aa7a32376d8c1d2601be4f0b21", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>, std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>>::__shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>>::shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>> &>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 41, "column": 29}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "308bb919e8a7fa6fa18b9ac6fd6b833d", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>, std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>>::__shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>>::shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>> &>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 47, "column": 29}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_dopri5<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/usr/include/c++/13/bits/stl_construct.h", "reportHash": "b865a2a56e9fd5e88b7358943e0af11e", "path": "/usr/include/c++/13/bits/stl_construct.h", "checker": {"name": "clang-diagnostic-delete-non-abstract-non-virtual-dtor", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdelete-non-abstract-non-virtual-dtor"}, "analyzerName": "clang-tidy", "line": 151, "column": 7, "message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "events": [{"message": "in instantiation of function template specialization 'std::_Destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/alloc_traits.h", "line": 675, "column": 9}, {"message": "in instantiation of function template specialization 'std::allocator_traits<std::allocator<void>>::destroy<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 613, "column": 28}, {"message": "in instantiation of member function 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_M_dispose' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 599, "column": 2}, {"message": "in instantiation of function template specialization 'std::_Sp_counted_ptr_inplace<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>, std::allocator<void>, __gnu_cxx::_S_atomic>::_Sp_counted_ptr_inplace<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 972, "column": 6}, {"message": "in instantiation of function template specialization 'std::__shared_count<>::__shared_count<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>, std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr_base.h", "line": 1712, "column": 14}, {"message": "in instantiation of function template specialization 'std::__shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>>::__shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 464, "column": 4}, {"message": "in instantiation of function template specialization 'std::shared_ptr<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>>::shared_ptr<std::allocator<void>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>> &>' requested here", "fileId": "/usr/include/c++/13/bits/shared_ptr.h", "line": 1009, "column": 14}, {"message": "in instantiation of function template specialization 'std::make_shared<PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>, boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>> &>' requested here", "fileId": "/home/pello/PySysLinkBase/src/ContinuousAndOde/SolverFactory.cpp", "line": 53, "column": 29}, {"message": "qualify call to silence this warning", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 19}, {"message": "destructor called on non-final 'PySysLinkBase::OdeintStepSolver<boost::numeric::odeint::controlled_runge_kutta<boost::numeric::odeint::runge_kutta_fehlberg78<std::vector<double>>>>' that has virtual functions but non-virtual destructor", "fileId": "/usr/include/c++/13/bits/stl_construct.h", "line": 151, "column": 7}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
