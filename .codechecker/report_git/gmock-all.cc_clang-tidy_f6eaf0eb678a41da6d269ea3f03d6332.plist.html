<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(report.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
    // If there are no events, or the last event does not match
    // the main warning message we print the warning message as a separate
    // error node.
    var lastEvent = null
    if (currentEvents.length > 0)
      lastEvent =currentEvents[currentEvents.length - 1];
    if (!lastEvent ||
          lastEvent.message != this._currentReport.message ||
          lastEvent.line != this._currentReport.line){
        var element = document.createElement('div');
        var left = that._codeMirror.defaultCharWidth() * lastEvent.column + 'px';
        element.setAttribute('style', 'margin-left: ' + left);
        element.setAttribute('class', 'check-msg ' + "error");
        var error_tag = document.createElement('span');
        error_tag.setAttribute('class', 'checker-enum error');
        error_tag.innerHTML = "E";
        element.appendChild(error_tag);
        var msg = document.createElement('span');
        msg.innerHTML = that.escapeHTML(this._currentReport.message)
          .replace(/(?:\r\n|\r|\n)/g, '<br>');
        element.appendChild(msg);
        that._lineWidgets.push(that._codeMirror.addLineWidget(
          this._currentReport.line - 1, element));
      }
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// The ACTION* family of macros can be used in a namespace scope to\n// define custom actions easily.  The syntax:\n//\n//   ACTION(name) { statements; }\n//\n// will define an action with the given name that executes the\n// statements.  The value returned by the statements will be used as\n// the return value of the action.  Inside the statements, you can\n// refer to the K-th (0-based) argument of the mock function by\n// &#x27;argK&#x27;, and refer to its type by &#x27;argK_type&#x27;.  For example:\n//\n//   ACTION(IncrementArg1) {\n//     arg1_type temp = arg1;\n//     return ++(*temp);\n//   }\n//\n// allows you to write\n//\n//   ...WillOnce(IncrementArg1());\n//\n// You can also refer to the entire argument tuple and its type by\n// &#x27;args&#x27; and &#x27;args_type&#x27;, and refer to the mock function type and its\n// return type by &#x27;function_type&#x27; and &#x27;return_type&#x27;.\n//\n// Note that you don&#x27;t need to specify the types of the mock function\n// arguments.  However rest assured that your code is still type-safe:\n// you&#x27;ll get a compiler error if *arg1 doesn&#x27;t support the ++\n// operator, or if the type of ++(*arg1) isn&#x27;t compatible with the\n// mock function&#x27;s return type, for example.\n//\n// Sometimes you&#x27;ll want to parameterize the action.   For that you can use\n// another macro:\n//\n//   ACTION_P(name, param_name) { statements; }\n//\n// For example:\n//\n//   ACTION_P(Add, n) { return arg0 + n; }\n//\n// will allow you to write:\n//\n//   ...WillOnce(Add(5));\n//\n// Note that you don&#x27;t need to provide the type of the parameter\n// either.  If you need to reference the type of a parameter named\n// &#x27;foo&#x27;, you can write &#x27;foo_type&#x27;.  For example, in the body of\n// ACTION_P(Add, n) above, you can write &#x27;n_type&#x27; to refer to the type\n// of &#x27;n&#x27;.\n//\n// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support\n// multi-parameter actions.\n//\n// For the purpose of typing, you can view\n//\n//   ACTION_Pk(Foo, p1, ..., pk) { ... }\n//\n// as shorthand for\n//\n//   template &lt;typename p1_type, ..., typename pk_type&gt;\n//   FooActionPk&lt;p1_type, ..., pk_type&gt; Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// In particular, you can provide the template type arguments\n// explicitly when invoking Foo(), as in Foo&lt;long, bool&gt;(5, false);\n// although usually you can rely on the compiler to infer the types\n// for you automatically.  You can assign the result of expression\n// Foo(p1, ..., pk) to a variable of type FooActionPk&lt;p1_type, ...,\n// pk_type&gt;.  This can be useful when composing actions.\n//\n// You can also overload actions with different numbers of parameters:\n//\n//   ACTION_P(Plus, a) { ... }\n//   ACTION_P2(Plus, a, b) { ... }\n//\n// While it&#x27;s tempting to always use the ACTION* macros when defining\n// a new action, you should also consider implementing ActionInterface\n// or using MakePolymorphicAction() instead, especially if you need to\n// use the action a lot.  While these approaches require more work,\n// they give you more control on the types of the mock function\n// arguments and the action parameters, which in general leads to\n// better compiler error messages that pay off in the long run.  They\n// also allow overloading actions based on parameter types (as opposed\n// to just based on the number of parameters).\n//\n// CAVEAT:\n//\n// ACTION*() can only be used in a namespace scope as templates cannot be\n// declared inside of a local class.\n// Users can, however, define any local functors (e.g. a lambda) that\n// can be used as actions.\n//\n// MORE INFORMATION:\n//\n// To learn more about using these macros, please search for &#x27;ACTION&#x27; on\n// https://github.com/google/googletest/blob/master/docs/gmock_cook_book.md\n\n// IWYU pragma: private, include &quot;gmock/gmock.h&quot;\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n\n#ifndef _WIN32_WCE\n#include &lt;errno.h&gt;\n#endif\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\n#include &quot;gmock/internal/gmock-internal-utils.h&quot;\n#include &quot;gmock/internal/gmock-port.h&quot;\n#include &quot;gmock/internal/gmock-pp.h&quot;\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4100)\n#endif\n\nnamespace testing {\n\n// To implement an action Foo, define:\n//   1. a class FooAction that implements the ActionInterface interface, and\n//   2. a factory function that creates an Action object from a\n//      const FooAction*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Action objects can now be copied like plain values.\n\nnamespace internal {\n\n// BuiltInDefaultValueGetter&lt;T, true&gt;::Get() returns a\n// default-constructed T value.  BuiltInDefaultValueGetter&lt;T,\n// false&gt;::Get() crashes with an error.\n//\n// This primary template is used when kDefaultConstructible is true.\ntemplate &lt;typename T, bool kDefaultConstructible&gt;\nstruct BuiltInDefaultValueGetter {\n  static T Get() { return T(); }\n};\ntemplate &lt;typename T&gt;\nstruct BuiltInDefaultValueGetter&lt;T, false&gt; {\n  static T Get() {\n    Assert(false, __FILE__, __LINE__,\n           &quot;Default action undefined for the function return type.&quot;);\n    return internal::Invalid&lt;T&gt;();\n    // The above statement will never be reached, but is required in\n    // order for this function to compile.\n  }\n};\n\n// BuiltInDefaultValue&lt;T&gt;::Get() returns the &quot;built-in&quot; default value\n// for type T, which is NULL when T is a raw pointer type, 0 when T is\n// a numeric type, false when T is bool, or &quot;&quot; when T is string or\n// std::string.  In addition, in C++11 and above, it turns a\n// default-constructed T value if T is default constructible.  For any\n// other type T, the built-in default T value is undefined, and the\n// function will abort the process.\ntemplate &lt;typename T&gt;\nclass BuiltInDefaultValue {\n public:\n  // This function returns true if and only if type T has a built-in default\n  // value.\n  static bool Exists() { return ::std::is_default_constructible&lt;T&gt;::value; }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter&lt;\n        T, ::std::is_default_constructible&lt;T&gt;::value&gt;::Get();\n  }\n};\n\n// This partial specialization says that we use the same built-in\n// default value for T and const T.\ntemplate &lt;typename T&gt;\nclass BuiltInDefaultValue&lt;const T&gt; {\n public:\n  static bool Exists() { return BuiltInDefaultValue&lt;T&gt;::Exists(); }\n  static T Get() { return BuiltInDefaultValue&lt;T&gt;::Get(); }\n};\n\n// This partial specialization defines the default values for pointer\n// types.\ntemplate &lt;typename T&gt;\nclass BuiltInDefaultValue&lt;T*&gt; {\n public:\n  static bool Exists() { return true; }\n  static T* Get() { return nullptr; }\n};\n\n// The following specializations define the default values for\n// specific types we care about.\n#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \\\n  template &lt;&gt;                                                     \\\n  class BuiltInDefaultValue&lt;type&gt; {                               \\\n   public:                                                        \\\n    static bool Exists() { return true; }                         \\\n    static type Get() { return value; }                           \\\n  }\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, &quot;&quot;);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, &#x27;\\0&#x27;);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, &#x27;\\0&#x27;);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, &#x27;\\0&#x27;);\n\n// There&#x27;s no need for a default action for signed wchar_t, as that\n// type is the same as wchar_t for gcc, and invalid for MSVC.\n//\n// There&#x27;s also no need for a default action for unsigned wchar_t, as\n// that type is the same as unsigned int for gcc, and invalid for\n// MSVC.\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT\n#endif\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);        // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long long, 0);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long long, 0);    // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);\n\n#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_\n\n// Partial implementations of metaprogramming types from the standard library\n// not available in C++11.\n\ntemplate &lt;typename P&gt;\nstruct negation\n    // NOLINTNEXTLINE\n    : std::integral_constant&lt;bool, bool(!P::value)&gt; {};\n\n// Base case: with zero predicates the answer is always true.\ntemplate &lt;typename...&gt;\nstruct conjunction : std::true_type {};\n\n// With a single predicate, the answer is that predicate.\ntemplate &lt;typename P1&gt;\nstruct conjunction&lt;P1&gt; : P1 {};\n\n// With multiple predicates the answer is the first predicate if that is false,\n// and we recurse otherwise.\ntemplate &lt;typename P1, typename... Ps&gt;\nstruct conjunction&lt;P1, Ps...&gt;\n    : std::conditional&lt;bool(P1::value), conjunction&lt;Ps...&gt;, P1&gt;::type {};\n\ntemplate &lt;typename...&gt;\nstruct disjunction : std::false_type {};\n\ntemplate &lt;typename P1&gt;\nstruct disjunction&lt;P1&gt; : P1 {};\n\ntemplate &lt;typename P1, typename... Ps&gt;\nstruct disjunction&lt;P1, Ps...&gt;\n    // NOLINTNEXTLINE\n    : std::conditional&lt;!bool(P1::value), disjunction&lt;Ps...&gt;, P1&gt;::type {};\n\ntemplate &lt;typename...&gt;\nusing void_t = void;\n\n// Detects whether an expression of type `From` can be implicitly converted to\n// `To` according to [conv]. In C++17, [conv]/3 defines this as follows:\n//\n//     An expression e can be implicitly converted to a type T if and only if\n//     the declaration T t=e; is well-formed, for some invented temporary\n//     variable t ([dcl.init]).\n//\n// [conv]/2 implies we can use function argument passing to detect whether this\n// initialization is valid.\n//\n// Note that this is distinct from is_convertible, which requires this be valid:\n//\n//     To test() {\n//       return declval&lt;From&gt;();\n//     }\n//\n// In particular, is_convertible doesn&#x27;t give the correct answer when `To` and\n// `From` are the same non-moveable type since `declval&lt;From&gt;` will be an rvalue\n// reference, defeating the guaranteed copy elision that would otherwise make\n// this function work.\n//\n// REQUIRES: `From` is not cv void.\ntemplate &lt;typename From, typename To&gt;\nstruct is_implicitly_convertible {\n private:\n  // A function that accepts a parameter of type T. This can be called with type\n  // U successfully only if U is implicitly convertible to T.\n  template &lt;typename T&gt;\n  static void Accept(T);\n\n  // A function that creates a value of type T.\n  template &lt;typename T&gt;\n  static T Make();\n\n  // An overload be selected when implicit conversion from T to To is possible.\n  template &lt;typename T, typename = decltype(Accept&lt;To&gt;(Make&lt;T&gt;()))&gt;\n  static std::true_type TestImplicitConversion(int);\n\n  // A fallback overload selected in all other cases.\n  template &lt;typename T&gt;\n  static std::false_type TestImplicitConversion(...);\n\n public:\n  using type = decltype(TestImplicitConversion&lt;From&gt;(0));\n  static constexpr bool value = type::value;\n};\n\n// Like std::invoke_result_t from C++17, but works only for objects with call\n// operators (not e.g. member function pointers, which we don&#x27;t need specific\n// support for in OnceAction because std::function deals with them).\ntemplate &lt;typename F, typename... Args&gt;\nusing call_result_t = decltype(std::declval&lt;F&gt;()(std::declval&lt;Args&gt;()...));\n\ntemplate &lt;typename Void, typename R, typename F, typename... Args&gt;\nstruct is_callable_r_impl : std::false_type {};\n\n// Specialize the struct for those template arguments where call_result_t is\n// well-formed. When it&#x27;s not, the generic template above is chosen, resulting\n// in std::false_type.\ntemplate &lt;typename R, typename F, typename... Args&gt;\nstruct is_callable_r_impl&lt;void_t&lt;call_result_t&lt;F, Args...&gt;&gt;, R, F, Args...&gt;\n    : std::conditional&lt;\n          std::is_void&lt;R&gt;::value,  //\n          std::true_type,          //\n          is_implicitly_convertible&lt;call_result_t&lt;F, Args...&gt;, R&gt;&gt;::type {};\n\n// Like std::is_invocable_r from C++17, but works only for objects with call\n// operators. See the note on call_result_t.\ntemplate &lt;typename R, typename F, typename... Args&gt;\nusing is_callable_r = is_callable_r_impl&lt;void, R, F, Args...&gt;;\n\n// Like std::as_const from C++17.\ntemplate &lt;typename T&gt;\ntypename std::add_const&lt;T&gt;::type&amp; as_const(T&amp; t) {\n  return t;\n}\n\n}  // namespace internal\n\n// Specialized for function types below.\ntemplate &lt;typename F&gt;\nclass OnceAction;\n\n// An action that can only be used once.\n//\n// This is accepted by WillOnce, which doesn&#x27;t require the underlying action to\n// be copy-constructible (only move-constructible), and promises to invoke it as\n// an rvalue reference. This allows the action to work with move-only types like\n// std::move_only_function in a type-safe manner.\n//\n// For example:\n//\n//     // Assume we have some API that needs to accept a unique pointer to some\n//     // non-copyable object Foo.\n//     void AcceptUniquePointer(std::unique_ptr&lt;Foo&gt; foo);\n//\n//     // We can define an action that provides a Foo to that API. Because It\n//     // has to give away its unique pointer, it must not be called more than\n//     // once, so its call operator is &amp;&amp;-qualified.\n//     struct ProvideFoo {\n//       std::unique_ptr&lt;Foo&gt; foo;\n//\n//       void operator()() &amp;&amp; {\n//         AcceptUniquePointer(std::move(Foo));\n//       }\n//     };\n//\n//     // This action can be used with WillOnce.\n//     EXPECT_CALL(mock, Call)\n//         .WillOnce(ProvideFoo{std::make_unique&lt;Foo&gt;(...)});\n//\n//     // But a call to WillRepeatedly will fail to compile. This is correct,\n//     // since the action cannot correctly be used repeatedly.\n//     EXPECT_CALL(mock, Call)\n//         .WillRepeatedly(ProvideFoo{std::make_unique&lt;Foo&gt;(...)});\n//\n// A less-contrived example would be an action that returns an arbitrary type,\n// whose &amp;&amp;-qualified call operator is capable of dealing with move-only types.\ntemplate &lt;typename Result, typename... Args&gt;\nclass OnceAction&lt;Result(Args...)&gt; final {\n private:\n  // True iff we can use the given callable type (or lvalue reference) directly\n  // via StdFunctionAdaptor.\n  template &lt;typename Callable&gt;\n  using IsDirectlyCompatible = internal::conjunction&lt;\n      // It must be possible to capture the callable in StdFunctionAdaptor.\n      std::is_constructible&lt;typename std::decay&lt;Callable&gt;::type, Callable&gt;,\n      // The callable must be compatible with our signature.\n      internal::is_callable_r&lt;Result, typename std::decay&lt;Callable&gt;::type,\n                              Args...&gt;&gt;;\n\n  // True iff we can use the given callable type via StdFunctionAdaptor once we\n  // ignore incoming arguments.\n  template &lt;typename Callable&gt;\n  using IsCompatibleAfterIgnoringArguments = internal::conjunction&lt;\n      // It must be possible to capture the callable in a lambda.\n      std::is_constructible&lt;typename std::decay&lt;Callable&gt;::type, Callable&gt;,\n      // The callable must be invocable with zero arguments, returning something\n      // convertible to Result.\n      internal::is_callable_r&lt;Result, typename std::decay&lt;Callable&gt;::type&gt;&gt;;\n\n public:\n  // Construct from a callable that is directly compatible with our mocked\n  // signature: it accepts our function type&#x27;s arguments and returns something\n  // convertible to our result type.\n  template &lt;typename Callable,\n            typename std::enable_if&lt;\n                internal::conjunction&lt;\n                    // Teach clang on macOS that we&#x27;re not talking about a\n                    // copy/move constructor here. Otherwise it gets confused\n                    // when checking the is_constructible requirement of our\n                    // traits above.\n                    internal::negation&lt;std::is_same&lt;\n                        OnceAction, typename std::decay&lt;Callable&gt;::type&gt;&gt;,\n                    IsDirectlyCompatible&lt;Callable&gt;&gt;  //\n                ::value,\n                int&gt;::type = 0&gt;\n  OnceAction(Callable&amp;&amp; callable)  // NOLINT\n      : function_(StdFunctionAdaptor&lt;typename std::decay&lt;Callable&gt;::type&gt;(\n            {}, std::forward&lt;Callable&gt;(callable))) {}\n\n  // As above, but for a callable that ignores the mocked function&#x27;s arguments.\n  template &lt;typename Callable,\n            typename std::enable_if&lt;\n                internal::conjunction&lt;\n                    // Teach clang on macOS that we&#x27;re not talking about a\n                    // copy/move constructor here. Otherwise it gets confused\n                    // when checking the is_constructible requirement of our\n                    // traits above.\n                    internal::negation&lt;std::is_same&lt;\n                        OnceAction, typename std::decay&lt;Callable&gt;::type&gt;&gt;,\n                    // Exclude callables for which the overload above works.\n                    // We&#x27;d rather provide the arguments if possible.\n                    internal::negation&lt;IsDirectlyCompatible&lt;Callable&gt;&gt;,\n                    IsCompatibleAfterIgnoringArguments&lt;Callable&gt;&gt;::value,\n                int&gt;::type = 0&gt;\n  OnceAction(Callable&amp;&amp; callable)  // NOLINT\n                                   // Call the constructor above with a callable\n                                   // that ignores the input arguments.\n      : OnceAction(IgnoreIncomingArguments&lt;typename std::decay&lt;Callable&gt;::type&gt;{\n            std::forward&lt;Callable&gt;(callable)}) {}\n\n  // We are naturally copyable because we store only an std::function, but\n  // semantically we should not be copyable.\n  OnceAction(const OnceAction&amp;) = delete;\n  OnceAction&amp; operator=(const OnceAction&amp;) = delete;\n  OnceAction(OnceAction&amp;&amp;) = default;\n\n  // Invoke the underlying action callable with which we were constructed,\n  // handing it the supplied arguments.\n  Result Call(Args... args) &amp;&amp; {\n    return function_(std::forward&lt;Args&gt;(args)...);\n  }\n\n private:\n  // An adaptor that wraps a callable that is compatible with our signature and\n  // being invoked as an rvalue reference so that it can be used as an\n  // StdFunctionAdaptor. This throws away type safety, but that&#x27;s fine because\n  // this is only used by WillOnce, which we know calls at most once.\n  //\n  // Once we have something like std::move_only_function from C++23, we can do\n  // away with this.\n  template &lt;typename Callable&gt;\n  class StdFunctionAdaptor final {\n   public:\n    // A tag indicating that the (otherwise universal) constructor is accepting\n    // the callable itself, instead of e.g. stealing calls for the move\n    // constructor.\n    struct CallableTag final {};\n\n    template &lt;typename F&gt;\n    explicit StdFunctionAdaptor(CallableTag, F&amp;&amp; callable)\n        : callable_(std::make_shared&lt;Callable&gt;(std::forward&lt;F&gt;(callable))) {}\n\n    // Rather than explicitly returning Result, we return whatever the wrapped\n    // callable returns. This allows for compatibility with existing uses like\n    // the following, when the mocked function returns void:\n    //\n    //     EXPECT_CALL(mock_fn_, Call)\n    //         .WillOnce([&amp;] {\n    //            [...]\n    //            return 0;\n    //         });\n    //\n    // Such a callable can be turned into std::function&lt;void()&gt;. If we use an\n    // explicit return type of Result here then it *doesn&#x27;t* work with\n    // std::function, because we&#x27;ll get a &quot;void function should not return a\n    // value&quot; error.\n    //\n    // We need not worry about incompatible result types because the SFINAE on\n    // OnceAction already checks this for us. std::is_invocable_r_v itself makes\n    // the same allowance for void result types.\n    template &lt;typename... ArgRefs&gt;\n    internal::call_result_t&lt;Callable, ArgRefs...&gt; operator()(\n        ArgRefs&amp;&amp;... args) const {\n      return std::move(*callable_)(std::forward&lt;ArgRefs&gt;(args)...);\n    }\n\n   private:\n    // We must put the callable on the heap so that we are copyable, which\n    // std::function needs.\n    std::shared_ptr&lt;Callable&gt; callable_;\n  };\n\n  // An adaptor that makes a callable that accepts zero arguments callable with\n  // our mocked arguments.\n  template &lt;typename Callable&gt;\n  struct IgnoreIncomingArguments {\n    internal::call_result_t&lt;Callable&gt; operator()(Args&amp;&amp;...) {\n      return std::move(callable)();\n    }\n\n    Callable callable;\n  };\n\n  std::function&lt;Result(Args...)&gt; function_;\n};\n\n// When an unexpected function call is encountered, Google Mock will\n// let it return a default value if the user has specified one for its\n// return type, or if the return type has a built-in default value;\n// otherwise Google Mock won&#x27;t know what value to return and will have\n// to abort the process.\n//\n// The DefaultValue&lt;T&gt; class allows a user to specify the\n// default value for a type T that is both copyable and publicly\n// destructible (i.e. anything that can be used as a function return\n// type).  The usage is:\n//\n//   // Sets the default value for type T to be foo.\n//   DefaultValue&lt;T&gt;::Set(foo);\ntemplate &lt;typename T&gt;\nclass DefaultValue {\n public:\n  // Sets the default value for type T; requires T to be\n  // copy-constructable and have a public destructor.\n  static void Set(T x) {\n    delete producer_;\n    producer_ = new FixedValueProducer(x);\n  }\n\n  // Provides a factory function to be called to generate the default value.\n  // This method can be used even if T is only move-constructible, but it is not\n  // limited to that case.\n  typedef T (*FactoryFunction)();\n  static void SetFactory(FactoryFunction factory) {\n    delete producer_;\n    producer_ = new FactoryValueProducer(factory);\n  }\n\n  // Unsets the default value for type T.\n  static void Clear() {\n    delete producer_;\n    producer_ = nullptr;\n  }\n\n  // Returns true if and only if the user has set the default value for type T.\n  static bool IsSet() { return producer_ != nullptr; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue&lt;T&gt;::Exists();\n  }\n\n  // Returns the default value for type T if the user has set one;\n  // otherwise returns the built-in default value. Requires that Exists()\n  // is true, which ensures that the return value is well-defined.\n  static T Get() {\n    return producer_ == nullptr ? internal::BuiltInDefaultValue&lt;T&gt;::Get()\n                                : producer_-&gt;Produce();\n  }\n\n private:\n  class ValueProducer {\n   public:\n    virtual ~ValueProducer() {}\n    virtual T Produce() = 0;\n  };\n\n  class FixedValueProducer : public ValueProducer {\n   public:\n    explicit FixedValueProducer(T value) : value_(value) {}\n    T Produce() override { return value_; }\n\n   private:\n    const T value_;\n    FixedValueProducer(const FixedValueProducer&amp;) = delete;\n    FixedValueProducer&amp; operator=(const FixedValueProducer&amp;) = delete;\n  };\n\n  class FactoryValueProducer : public ValueProducer {\n   public:\n    explicit FactoryValueProducer(FactoryFunction factory)\n        : factory_(factory) {}\n    T Produce() override { return factory_(); }\n\n   private:\n    const FactoryFunction factory_;\n    FactoryValueProducer(const FactoryValueProducer&amp;) = delete;\n    FactoryValueProducer&amp; operator=(const FactoryValueProducer&amp;) = delete;\n  };\n\n  static ValueProducer* producer_;\n};\n\n// This partial specialization allows a user to set default values for\n// reference types.\ntemplate &lt;typename T&gt;\nclass DefaultValue&lt;T&amp;&gt; {\n public:\n  // Sets the default value for type T&amp;.\n  static void Set(T&amp; x) {  // NOLINT\n    address_ = &amp;x;\n  }\n\n  // Unsets the default value for type T&amp;.\n  static void Clear() { address_ = nullptr; }\n\n  // Returns true if and only if the user has set the default value for type T&amp;.\n  static bool IsSet() { return address_ != nullptr; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue&lt;T&amp;&gt;::Exists();\n  }\n\n  // Returns the default value for type T&amp; if the user has set one;\n  // otherwise returns the built-in default value if there is one;\n  // otherwise aborts the process.\n  static T&amp; Get() {\n    return address_ == nullptr ? internal::BuiltInDefaultValue&lt;T&amp;&gt;::Get()\n                               : *address_;\n  }\n\n private:\n  static T* address_;\n};\n\n// This specialization allows DefaultValue&lt;void&gt;::Get() to\n// compile.\ntemplate &lt;&gt;\nclass DefaultValue&lt;void&gt; {\n public:\n  static bool Exists() { return true; }\n  static void Get() {}\n};\n\n// Points to the user-set default value for type T.\ntemplate &lt;typename T&gt;\ntypename DefaultValue&lt;T&gt;::ValueProducer* DefaultValue&lt;T&gt;::producer_ = nullptr;\n\n// Points to the user-set default value for type T&amp;.\ntemplate &lt;typename T&gt;\nT* DefaultValue&lt;T&amp;&gt;::address_ = nullptr;\n\n// Implement this interface to define an action for function type F.\ntemplate &lt;typename F&gt;\nclass ActionInterface {\n public:\n  typedef typename internal::Function&lt;F&gt;::Result Result;\n  typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n  ActionInterface() {}\n  virtual ~ActionInterface() {}\n\n  // Performs the action.  This method is not const, as in general an\n  // action can have side effects and be stateful.  For example, a\n  // get-the-next-element-from-the-collection action will need to\n  // remember the current element.\n  virtual Result Perform(const ArgumentTuple&amp; args) = 0;\n\n private:\n  ActionInterface(const ActionInterface&amp;) = delete;\n  ActionInterface&amp; operator=(const ActionInterface&amp;) = delete;\n};\n\ntemplate &lt;typename F&gt;\nclass Action;\n\n// An Action&lt;R(Args...)&gt; is a copyable and IMMUTABLE (except by assignment)\n// object that represents an action to be taken when a mock function of type\n// R(Args...) is called. The implementation of Action&lt;T&gt; is just a\n// std::shared_ptr to const ActionInterface&lt;T&gt;. Don&#x27;t inherit from Action! You\n// can view an object implementing ActionInterface&lt;F&gt; as a concrete action\n// (including its current state), and an Action&lt;F&gt; object as a handle to it.\ntemplate &lt;typename R, typename... Args&gt;\nclass Action&lt;R(Args...)&gt; {\n private:\n  using F = R(Args...);\n\n  // Adapter class to allow constructing Action from a legacy ActionInterface.\n  // New code should create Actions from functors instead.\n  struct ActionAdapter {\n    // Adapter must be copyable to satisfy std::function requirements.\n    ::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt; impl_;\n\n    template &lt;typename... InArgs&gt;\n    typename internal::Function&lt;F&gt;::Result operator()(InArgs&amp;&amp;... args) {\n      return impl_-&gt;Perform(\n          ::std::forward_as_tuple(::std::forward&lt;InArgs&gt;(args)...));\n    }\n  };\n\n  template &lt;typename G&gt;\n  using IsCompatibleFunctor = std::is_constructible&lt;std::function&lt;F&gt;, G&gt;;\n\n public:\n  typedef typename internal::Function&lt;F&gt;::Result Result;\n  typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n  // Constructs a null Action.  Needed for storing Action objects in\n  // STL containers.\n  Action() {}\n\n  // Construct an Action from a specified callable.\n  // This cannot take std::function directly, because then Action would not be\n  // directly constructible from lambda (it would require two conversions).\n  template &lt;\n      typename G,\n      typename = typename std::enable_if&lt;internal::disjunction&lt;\n          IsCompatibleFunctor&lt;G&gt;, std::is_constructible&lt;std::function&lt;Result()&gt;,\n                                                        G&gt;&gt;::value&gt;::type&gt;\n  Action(G&amp;&amp; fun) {  // NOLINT\n    Init(::std::forward&lt;G&gt;(fun), IsCompatibleFunctor&lt;G&gt;());\n  }\n\n  // Constructs an Action from its implementation.\n  explicit Action(ActionInterface&lt;F&gt;* impl)\n      : fun_(ActionAdapter{::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt;(impl)}) {}\n\n  // This constructor allows us to turn an Action&lt;Func&gt; object into an\n  // Action&lt;F&gt;, as long as F&#x27;s arguments can be implicitly converted\n  // to Func&#x27;s and Func&#x27;s return type can be implicitly converted to F&#x27;s.\n  template &lt;typename Func&gt;\n  Action(const Action&lt;Func&gt;&amp; action)  // NOLINT\n      : fun_(action.fun_) {}\n\n  // Returns true if and only if this is the DoDefault() action.\n  bool IsDoDefault() const { return fun_ == nullptr; }\n\n  // Performs the action.  Note that this method is const even though\n  // the corresponding method in ActionInterface is not.  The reason\n  // is that a const Action&lt;F&gt; means that it cannot be re-bound to\n  // another concrete action, not that the concrete action it binds to\n  // cannot change state.  (Think of the difference between a const\n  // pointer and a pointer to const.)\n  Result Perform(ArgumentTuple args) const {\n    if (IsDoDefault()) {\n      internal::IllegalDoDefault(__FILE__, __LINE__);\n    }\n    return internal::Apply(fun_, ::std::move(args));\n  }\n\n  // An action can be used as a OnceAction, since it&#x27;s obviously safe to call it\n  // once.\n  operator OnceAction&lt;F&gt;() const {  // NOLINT\n    // Return a OnceAction-compatible callable that calls Perform with the\n    // arguments it is provided. We could instead just return fun_, but then\n    // we&#x27;d need to handle the IsDoDefault() case separately.\n    struct OA {\n      Action&lt;F&gt; action;\n\n      R operator()(Args... args) &amp;&amp; {\n        return action.Perform(\n            std::forward_as_tuple(std::forward&lt;Args&gt;(args)...));\n      }\n    };\n\n    return OA{*this};\n  }\n\n private:\n  template &lt;typename G&gt;\n  friend class Action;\n\n  template &lt;typename G&gt;\n  void Init(G&amp;&amp; g, ::std::true_type) {\n    fun_ = ::std::forward&lt;G&gt;(g);\n  }\n\n  template &lt;typename G&gt;\n  void Init(G&amp;&amp; g, ::std::false_type) {\n    fun_ = IgnoreArgs&lt;typename ::std::decay&lt;G&gt;::type&gt;{::std::forward&lt;G&gt;(g)};\n  }\n\n  template &lt;typename FunctionImpl&gt;\n  struct IgnoreArgs {\n    template &lt;typename... InArgs&gt;\n    Result operator()(const InArgs&amp;...) const {\n      return function_impl();\n    }\n\n    FunctionImpl function_impl;\n  };\n\n  // fun_ is an empty function if and only if this is the DoDefault() action.\n  ::std::function&lt;F&gt; fun_;\n};\n\n// The PolymorphicAction class template makes it easy to implement a\n// polymorphic action (i.e. an action that can be used in mock\n// functions of than one type, e.g. Return()).\n//\n// To define a polymorphic action, a user first provides a COPYABLE\n// implementation class that has a Perform() method template:\n//\n//   class FooAction {\n//    public:\n//     template &lt;typename Result, typename ArgumentTuple&gt;\n//     Result Perform(const ArgumentTuple&amp; args) const {\n//       // Processes the arguments and returns a result, using\n//       // std::get&lt;N&gt;(args) to get the N-th (0-based) argument in the tuple.\n//     }\n//     ...\n//   };\n//\n// Then the user creates the polymorphic action using\n// MakePolymorphicAction(object) where object has type FooAction.  See\n// the definition of Return(void) and SetArgumentPointee&lt;N&gt;(value) for\n// complete examples.\ntemplate &lt;typename Impl&gt;\nclass PolymorphicAction {\n public:\n  explicit PolymorphicAction(const Impl&amp; impl) : impl_(impl) {}\n\n  template &lt;typename F&gt;\n  operator Action&lt;F&gt;() const {\n    return Action&lt;F&gt;(new MonomorphicImpl&lt;F&gt;(impl_));\n  }\n\n private:\n  template &lt;typename F&gt;\n  class MonomorphicImpl : public ActionInterface&lt;F&gt; {\n   public:\n    typedef typename internal::Function&lt;F&gt;::Result Result;\n    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n    explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}\n\n    Result Perform(const ArgumentTuple&amp; args) override {\n      return impl_.template Perform&lt;Result&gt;(args);\n    }\n\n   private:\n    Impl impl_;\n  };\n\n  Impl impl_;\n};\n\n// Creates an Action from its implementation and returns it.  The\n// created Action object owns the implementation.\ntemplate &lt;typename F&gt;\nAction&lt;F&gt; MakeAction(ActionInterface&lt;F&gt;* impl) {\n  return Action&lt;F&gt;(impl);\n}\n\n// Creates a polymorphic action from its implementation.  This is\n// easier to use than the PolymorphicAction&lt;Impl&gt; constructor as it\n// doesn&#x27;t require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicAction(foo);\n// vs\n//   PolymorphicAction&lt;TypeOfFoo&gt;(foo);\ntemplate &lt;typename Impl&gt;\ninline PolymorphicAction&lt;Impl&gt; MakePolymorphicAction(const Impl&amp; impl) {\n  return PolymorphicAction&lt;Impl&gt;(impl);\n}\n\nnamespace internal {\n\n// Helper struct to specialize ReturnAction to execute a move instead of a copy\n// on return. Useful for move-only types, but could be used on any type.\ntemplate &lt;typename T&gt;\nstruct ByMoveWrapper {\n  explicit ByMoveWrapper(T value) : payload(std::move(value)) {}\n  T payload;\n};\n\n// The general implementation of Return(R). Specializations follow below.\ntemplate &lt;typename R&gt;\nclass ReturnAction final {\n public:\n  explicit ReturnAction(R value) : value_(std::move(value)) {}\n\n  template &lt;typename U, typename... Args,\n            typename = typename std::enable_if&lt;conjunction&lt;\n                // See the requirements documented on Return.\n                negation&lt;std::is_same&lt;void, U&gt;&gt;,  //\n                negation&lt;std::is_reference&lt;U&gt;&gt;,   //\n                std::is_convertible&lt;R, U&gt;,        //\n                std::is_move_constructible&lt;U&gt;&gt;::value&gt;::type&gt;\n  operator OnceAction&lt;U(Args...)&gt;() &amp;&amp; {  // NOLINT\n    return Impl&lt;U&gt;(std::move(value_));\n  }\n\n  template &lt;typename U, typename... Args,\n            typename = typename std::enable_if&lt;conjunction&lt;\n                // See the requirements documented on Return.\n                negation&lt;std::is_same&lt;void, U&gt;&gt;,   //\n                negation&lt;std::is_reference&lt;U&gt;&gt;,    //\n                std::is_convertible&lt;const R&amp;, U&gt;,  //\n                std::is_copy_constructible&lt;U&gt;&gt;::value&gt;::type&gt;\n  operator Action&lt;U(Args...)&gt;() const {  // NOLINT\n    return Impl&lt;U&gt;(value_);\n  }\n\n private:\n  // Implements the Return(x) action for a mock function that returns type U.\n  template &lt;typename U&gt;\n  class Impl final {\n   public:\n    // The constructor used when the return value is allowed to move from the\n    // input value (i.e. we are converting to OnceAction).\n    explicit Impl(R&amp;&amp; input_value)\n        : state_(new State(std::move(input_value))) {}\n\n    // The constructor used when the return value is not allowed to move from\n    // the input value (i.e. we are converting to Action).\n    explicit Impl(const R&amp; input_value) : state_(new State(input_value)) {}\n\n    U operator()() &amp;&amp; { return std::move(state_-&gt;value); }\n    U operator()() const&amp; { return state_-&gt;value; }\n\n   private:\n    // We put our state on the heap so that the compiler-generated copy/move\n    // constructors work correctly even when U is a reference-like type. This is\n    // necessary only because we eagerly create State::value (see the note on\n    // that symbol for details). If we instead had only the input value as a\n    // member then the default constructors would work fine.\n    //\n    // For example, when R is std::string and U is std::string_view, value is a\n    // reference to the string backed by input_value. The copy constructor would\n    // copy both, so that we wind up with a new input_value object (with the\n    // same contents) and a reference to the *old* input_value object rather\n    // than the new one.\n    struct State {\n      explicit State(const R&amp; input_value_in)\n          : input_value(input_value_in),\n            // Make an implicit conversion to Result before initializing the U\n            // object we store, avoiding calling any explicit constructor of U\n            // from R.\n            //\n            // This simulates the language rules: a function with return type U\n            // that does `return R()` requires R to be implicitly convertible to\n            // U, and uses that path for the conversion, even U Result has an\n            // explicit constructor from R.\n            value(ImplicitCast_&lt;U&gt;(internal::as_const(input_value))) {}\n\n      // As above, but for the case where we&#x27;re moving from the ReturnAction\n      // object because it&#x27;s being used as a OnceAction.\n      explicit State(R&amp;&amp; input_value_in)\n          : input_value(std::move(input_value_in)),\n            // For the same reason as above we make an implicit conversion to U\n            // before initializing the value.\n            //\n            // Unlike above we provide the input value as an rvalue to the\n            // implicit conversion because this is a OnceAction: it&#x27;s fine if it\n            // wants to consume the input value.\n            value(ImplicitCast_&lt;U&gt;(std::move(input_value))) {}\n\n      // A copy of the value originally provided by the user. We retain this in\n      // addition to the value of the mock function&#x27;s result type below in case\n      // the latter is a reference-like type. See the std::string_view example\n      // in the documentation on Return.\n      R input_value;\n\n      // The value we actually return, as the type returned by the mock function\n      // itself.\n      //\n      // We eagerly initialize this here, rather than lazily doing the implicit\n      // conversion automatically each time Perform is called, for historical\n      // reasons: in 2009-11, commit a070cbd91c (Google changelist 13540126)\n      // made the Action&lt;U()&gt; conversion operator eagerly convert the R value to\n      // U, but without keeping the R alive. This broke the use case discussed\n      // in the documentation for Return, making reference-like types such as\n      // std::string_view not safe to use as U where the input type R is a\n      // value-like type such as std::string.\n      //\n      // The example the commit gave was not very clear, nor was the issue\n      // thread (https://github.com/google/googlemock/issues/86), but it seems\n      // the worry was about reference-like input types R that flatten to a\n      // value-like type U when being implicitly converted. An example of this\n      // is std::vector&lt;bool&gt;::reference, which is often a proxy type with an\n      // reference to the underlying vector:\n      //\n      //     // Helper method: have the mock function return bools according\n      //     // to the supplied script.\n      //     void SetActions(MockFunction&lt;bool(size_t)&gt;&amp; mock,\n      //                     const std::vector&lt;bool&gt;&amp; script) {\n      //       for (size_t i = 0; i &lt; script.size(); ++i) {\n      //         EXPECT_CALL(mock, Call(i)).WillOnce(Return(script[i]));\n      //       }\n      //     }\n      //\n      //     TEST(Foo, Bar) {\n      //       // Set actions using a temporary vector, whose operator[]\n      //       // returns proxy objects that references that will be\n      //       // dangling once the call to SetActions finishes and the\n      //       // vector is destroyed.\n      //       MockFunction&lt;bool(size_t)&gt; mock;\n      //       SetActions(mock, {false, true});\n      //\n      //       EXPECT_FALSE(mock.AsStdFunction()(0));\n      //       EXPECT_TRUE(mock.AsStdFunction()(1));\n      //     }\n      //\n      // This eager conversion helps with a simple case like this, but doesn&#x27;t\n      // fully make these types work in general. For example the following still\n      // uses a dangling reference:\n      //\n      //     TEST(Foo, Baz) {\n      //       MockFunction&lt;std::vector&lt;std::string&gt;()&gt; mock;\n      //\n      //       // Return the same vector twice, and then the empty vector\n      //       // thereafter.\n      //       auto action = Return(std::initializer_list&lt;std::string&gt;{\n      //           &quot;taco&quot;, &quot;burrito&quot;,\n      //       });\n      //\n      //       EXPECT_CALL(mock, Call)\n      //           .WillOnce(action)\n      //           .WillOnce(action)\n      //           .WillRepeatedly(Return(std::vector&lt;std::string&gt;{}));\n      //\n      //       EXPECT_THAT(mock.AsStdFunction()(),\n      //                   ElementsAre(&quot;taco&quot;, &quot;burrito&quot;));\n      //       EXPECT_THAT(mock.AsStdFunction()(),\n      //                   ElementsAre(&quot;taco&quot;, &quot;burrito&quot;));\n      //       EXPECT_THAT(mock.AsStdFunction()(), IsEmpty());\n      //     }\n      //\n      U value;\n    };\n\n    const std::shared_ptr&lt;State&gt; state_;\n  };\n\n  R value_;\n};\n\n// A specialization of ReturnAction&lt;R&gt; when R is ByMoveWrapper&lt;T&gt; for some T.\n//\n// This version applies the type system-defeating hack of moving from T even in\n// the const call operator, checking at runtime that it isn&#x27;t called more than\n// once, since the user has declared their intent to do so by using ByMove.\ntemplate &lt;typename T&gt;\nclass ReturnAction&lt;ByMoveWrapper&lt;T&gt;&gt; final {\n public:\n  explicit ReturnAction(ByMoveWrapper&lt;T&gt; wrapper)\n      : state_(new State(std::move(wrapper.payload))) {}\n\n  T operator()() const {\n    GTEST_CHECK_(!state_-&gt;called)\n        &lt;&lt; &quot;A ByMove() action must be performed at most once.&quot;;\n\n    state_-&gt;called = true;\n    return std::move(state_-&gt;value);\n  }\n\n private:\n  // We store our state on the heap so that we are copyable as required by\n  // Action, despite the fact that we are stateful and T may not be copyable.\n  struct State {\n    explicit State(T&amp;&amp; value_in) : value(std::move(value_in)) {}\n\n    T value;\n    bool called = false;\n  };\n\n  const std::shared_ptr&lt;State&gt; state_;\n};\n\n// Implements the ReturnNull() action.\nclass ReturnNullAction {\n public:\n  // Allows ReturnNull() to be used in any pointer-returning function. In C++11\n  // this is enforced by returning nullptr, and in non-C++11 by asserting a\n  // pointer type on compile time.\n  template &lt;typename Result, typename ArgumentTuple&gt;\n  static Result Perform(const ArgumentTuple&amp;) {\n    return nullptr;\n  }\n};\n\n// Implements the Return() action.\nclass ReturnVoidAction {\n public:\n  // Allows Return() to be used in any void-returning function.\n  template &lt;typename Result, typename ArgumentTuple&gt;\n  static void Perform(const ArgumentTuple&amp;) {\n    static_assert(std::is_void&lt;Result&gt;::value, &quot;Result should be void.&quot;);\n  }\n};\n\n// Implements the polymorphic ReturnRef(x) action, which can be used\n// in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate &lt;typename T&gt;\nclass ReturnRefAction {\n public:\n  // Constructs a ReturnRefAction object from the reference to be returned.\n  explicit ReturnRefAction(T&amp; ref) : ref_(ref) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRef(x) to be\n  // used in ANY function that returns a reference to x&#x27;s type.\n  template &lt;typename F&gt;\n  operator Action&lt;F&gt;() const {\n    typedef typename Function&lt;F&gt;::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRef(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    static_assert(std::is_reference&lt;Result&gt;::value,\n                  &quot;use Return instead of ReturnRef to return a value&quot;);\n    return Action&lt;F&gt;(new Impl&lt;F&gt;(ref_));\n  }\n\n private:\n  // Implements the ReturnRef(x) action for a particular function type F.\n  template &lt;typename F&gt;\n  class Impl : public ActionInterface&lt;F&gt; {\n   public:\n    typedef typename Function&lt;F&gt;::Result Result;\n    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(T&amp; ref) : ref_(ref) {}  // NOLINT\n\n    Result Perform(const ArgumentTuple&amp;) override { return ref_; }\n\n   private:\n    T&amp; ref_;\n  };\n\n  T&amp; ref_;\n};\n\n// Implements the polymorphic ReturnRefOfCopy(x) action, which can be\n// used in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate &lt;typename T&gt;\nclass ReturnRefOfCopyAction {\n public:\n  // Constructs a ReturnRefOfCopyAction object from the reference to\n  // be returned.\n  explicit ReturnRefOfCopyAction(const T&amp; value) : value_(value) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRefOfCopy(x) to be\n  // used in ANY function that returns a reference to x&#x27;s type.\n  template &lt;typename F&gt;\n  operator Action&lt;F&gt;() const {\n    typedef typename Function&lt;F&gt;::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRefOfCopy(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    static_assert(std::is_reference&lt;Result&gt;::value,\n                  &quot;use Return instead of ReturnRefOfCopy to return a value&quot;);\n    return Action&lt;F&gt;(new Impl&lt;F&gt;(value_));\n  }\n\n private:\n  // Implements the ReturnRefOfCopy(x) action for a particular function type F.\n  template &lt;typename F&gt;\n  class Impl : public ActionInterface&lt;F&gt; {\n   public:\n    typedef typename Function&lt;F&gt;::Result Result;\n    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const T&amp; value) : value_(value) {}  // NOLINT\n\n    Result Perform(const ArgumentTuple&amp;) override { return value_; }\n\n   private:\n    T value_;\n  };\n\n  const T value_;\n};\n\n// Implements the polymorphic ReturnRoundRobin(v) action, which can be\n// used in any function that returns the element_type of v.\ntemplate &lt;typename T&gt;\nclass ReturnRoundRobinAction {\n public:\n  explicit ReturnRoundRobinAction(std::vector&lt;T&gt; values) {\n    GTEST_CHECK_(!values.empty())\n        &lt;&lt; &quot;ReturnRoundRobin requires at least one element.&quot;;\n    state_-&gt;values = std::move(values);\n  }\n\n  template &lt;typename... Args&gt;\n  T operator()(Args&amp;&amp;...) const {\n    return state_-&gt;Next();\n  }\n\n private:\n  struct State {\n    T Next() {\n      T ret_val = values[i++];\n      if (i == values.size()) i = 0;\n      return ret_val;\n    }\n\n    std::vector&lt;T&gt; values;\n    size_t i = 0;\n  };\n  std::shared_ptr&lt;State&gt; state_ = std::make_shared&lt;State&gt;();\n};\n\n// Implements the polymorphic DoDefault() action.\nclass DoDefaultAction {\n public:\n  // This template type conversion operator allows DoDefault() to be\n  // used in any function.\n  template &lt;typename F&gt;\n  operator Action&lt;F&gt;() const {\n    return Action&lt;F&gt;();\n  }  // NOLINT\n};\n\n// Implements the Assign action to set a given pointer referent to a\n// particular value.\ntemplate &lt;typename T1, typename T2&gt;\nclass AssignAction {\n public:\n  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}\n\n  template &lt;typename Result, typename ArgumentTuple&gt;\n  void Perform(const ArgumentTuple&amp; /* args */) const {\n    *ptr_ = value_;\n  }\n\n private:\n  T1* const ptr_;\n  const T2 value_;\n};\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetErrnoAndReturn action to simulate return from\n// various system calls and libc functions.\ntemplate &lt;typename T&gt;\nclass SetErrnoAndReturnAction {\n public:\n  SetErrnoAndReturnAction(int errno_value, T result)\n      : errno_(errno_value), result_(result) {}\n  template &lt;typename Result, typename ArgumentTuple&gt;\n  Result Perform(const ArgumentTuple&amp; /* args */) const {\n    errno = errno_;\n    return result_;\n  }\n\n private:\n  const int errno_;\n  const T result_;\n};\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetArgumentPointee&lt;N&gt;(x) action for any function\n// whose N-th argument (0-based) is a pointer to x&#x27;s type.\ntemplate &lt;size_t N, typename A, typename = void&gt;\nstruct SetArgumentPointeeAction {\n  A value;\n\n  template &lt;typename... Args&gt;\n  void operator()(const Args&amp;... args) const {\n    *::std::get&lt;N&gt;(std::tie(args...)) = value;\n  }\n};\n\n// Implements the Invoke(object_ptr, &amp;Class::Method) action.\ntemplate &lt;class Class, typename MethodPtr&gt;\nstruct InvokeMethodAction {\n  Class* const obj_ptr;\n  const MethodPtr method_ptr;\n\n  template &lt;typename... Args&gt;\n  auto operator()(Args&amp;&amp;... args) const\n      -&gt; decltype((obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...)) {\n    return (obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...);\n  }\n};\n\n// Implements the InvokeWithoutArgs(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an\n// Action&lt;F&gt; as long as f&#x27;s type is compatible with F.\ntemplate &lt;typename FunctionImpl&gt;\nstruct InvokeWithoutArgsAction {\n  FunctionImpl function_impl;\n\n  // Allows InvokeWithoutArgs(f) to be used as any action whose type is\n  // compatible with f.\n  template &lt;typename... Args&gt;\n  auto operator()(const Args&amp;...) -&gt; decltype(function_impl()) {\n    return function_impl();\n  }\n};\n\n// Implements the InvokeWithoutArgs(object_ptr, &amp;Class::Method) action.\ntemplate &lt;class Class, typename MethodPtr&gt;\nstruct InvokeMethodWithoutArgsAction {\n  Class* const obj_ptr;\n  const MethodPtr method_ptr;\n\n  using ReturnType =\n      decltype((std::declval&lt;Class*&gt;()-&gt;*std::declval&lt;MethodPtr&gt;())());\n\n  template &lt;typename... Args&gt;\n  ReturnType operator()(const Args&amp;...) const {\n    return (obj_ptr-&gt;*method_ptr)();\n  }\n};\n\n// Implements the IgnoreResult(action) action.\ntemplate &lt;typename A&gt;\nclass IgnoreResultAction {\n public:\n  explicit IgnoreResultAction(const A&amp; action) : action_(action) {}\n\n  template &lt;typename F&gt;\n  operator Action&lt;F&gt;() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can&#x27;t\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename internal::Function&lt;F&gt;::Result Result;\n\n    // Asserts at compile time that F returns void.\n    static_assert(std::is_void&lt;Result&gt;::value, &quot;Result type should be void.&quot;);\n\n    return Action&lt;F&gt;(new Impl&lt;F&gt;(action_));\n  }\n\n private:\n  template &lt;typename F&gt;\n  class Impl : public ActionInterface&lt;F&gt; {\n   public:\n    typedef typename internal::Function&lt;F&gt;::Result Result;\n    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const A&amp; action) : action_(action) {}\n\n    void Perform(const ArgumentTuple&amp; args) override {\n      // Performs the action and ignores its result.\n      action_.Perform(args);\n    }\n\n   private:\n    // Type OriginalFunction is the same as F except that its return\n    // type is IgnoredValue.\n    typedef\n        typename internal::Function&lt;F&gt;::MakeResultIgnoredValue OriginalFunction;\n\n    const Action&lt;OriginalFunction&gt; action_;\n  };\n\n  const A action_;\n};\n\ntemplate &lt;typename InnerAction, size_t... I&gt;\nstruct WithArgsAction {\n  InnerAction inner_action;\n\n  // The signature of the function as seen by the inner action, given an out\n  // action with the given result and argument types.\n  template &lt;typename R, typename... Args&gt;\n  using InnerSignature =\n      R(typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type...);\n\n  // Rather than a call operator, we must define conversion operators to\n  // particular action types. This is necessary for embedded actions like\n  // DoDefault(), which rely on an action conversion operators rather than\n  // providing a call operator because even with a particular set of arguments\n  // they don&#x27;t have a fixed return type.\n\n  template &lt;typename R, typename... Args,\n            typename std::enable_if&lt;\n                std::is_convertible&lt;\n                    InnerAction,\n                    // Unfortunately we can&#x27;t use the InnerSignature alias here;\n                    // MSVC complains about the I parameter pack not being\n                    // expanded (error C3520) despite it being expanded in the\n                    // type alias.\n                    OnceAction&lt;R(typename std::tuple_element&lt;\n                                 I, std::tuple&lt;Args...&gt;&gt;::type...)&gt;&gt;::value,\n                int&gt;::type = 0&gt;\n  operator OnceAction&lt;R(Args...)&gt;() &amp;&amp; {  // NOLINT\n    struct OA {\n      OnceAction&lt;InnerSignature&lt;R, Args...&gt;&gt; inner_action;\n\n      R operator()(Args&amp;&amp;... args) &amp;&amp; {\n        return std::move(inner_action)\n            .Call(std::get&lt;I&gt;(\n                std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))...);\n      }\n    };\n\n    return OA{std::move(inner_action)};\n  }\n\n  template &lt;typename R, typename... Args,\n            typename std::enable_if&lt;\n                std::is_convertible&lt;\n                    const InnerAction&amp;,\n                    // Unfortunately we can&#x27;t use the InnerSignature alias here;\n                    // MSVC complains about the I parameter pack not being\n                    // expanded (error C3520) despite it being expanded in the\n                    // type alias.\n                    Action&lt;R(typename std::tuple_element&lt;\n                             I, std::tuple&lt;Args...&gt;&gt;::type...)&gt;&gt;::value,\n                int&gt;::type = 0&gt;\n  operator Action&lt;R(Args...)&gt;() const {  // NOLINT\n    Action&lt;InnerSignature&lt;R, Args...&gt;&gt; converted(inner_action);\n\n    return [converted](Args&amp;&amp;... args) -&gt; R {\n      return converted.Perform(std::forward_as_tuple(\n          std::get&lt;I&gt;(std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))...));\n    };\n  }\n};\n\ntemplate &lt;typename... Actions&gt;\nclass DoAllAction;\n\n// Base case: only a single action.\ntemplate &lt;typename FinalAction&gt;\nclass DoAllAction&lt;FinalAction&gt; {\n public:\n  struct UserConstructorTag {};\n\n  template &lt;typename T&gt;\n  explicit DoAllAction(UserConstructorTag, T&amp;&amp; action)\n      : final_action_(std::forward&lt;T&gt;(action)) {}\n\n  // Rather than a call operator, we must define conversion operators to\n  // particular action types. This is necessary for embedded actions like\n  // DoDefault(), which rely on an action conversion operators rather than\n  // providing a call operator because even with a particular set of arguments\n  // they don&#x27;t have a fixed return type.\n\n  template &lt;typename R, typename... Args,\n            typename std::enable_if&lt;\n                std::is_convertible&lt;FinalAction, OnceAction&lt;R(Args...)&gt;&gt;::value,\n                int&gt;::type = 0&gt;\n  operator OnceAction&lt;R(Args...)&gt;() &amp;&amp; {  // NOLINT\n    return std::move(final_action_);\n  }\n\n  template &lt;\n      typename R, typename... Args,\n      typename std::enable_if&lt;\n          std::is_convertible&lt;const FinalAction&amp;, Action&lt;R(Args...)&gt;&gt;::value,\n          int&gt;::type = 0&gt;\n  operator Action&lt;R(Args...)&gt;() const {  // NOLINT\n    return final_action_;\n  }\n\n private:\n  FinalAction final_action_;\n};\n\n// Recursive case: support N actions by calling the initial action and then\n// calling through to the base class containing N-1 actions.\ntemplate &lt;typename InitialAction, typename... OtherActions&gt;\nclass DoAllAction&lt;InitialAction, OtherActions...&gt;\n    : private DoAllAction&lt;OtherActions...&gt; {\n private:\n  using Base = DoAllAction&lt;OtherActions...&gt;;\n\n  // The type of reference that should be provided to an initial action for a\n  // mocked function parameter of type T.\n  //\n  // There are two quirks here:\n  //\n  //  *  Unlike most forwarding functions, we pass scalars through by value.\n  //     This isn&#x27;t strictly necessary because an lvalue reference would work\n  //     fine too and be consistent with other non-reference types, but it&#x27;s\n  //     perhaps less surprising.\n  //\n  //     For example if the mocked function has signature void(int), then it\n  //     might seem surprising for the user&#x27;s initial action to need to be\n  //     convertible to Action&lt;void(const int&amp;)&gt;. This is perhaps less\n  //     surprising for a non-scalar type where there may be a performance\n  //     impact, or it might even be impossible, to pass by value.\n  //\n  //  *  More surprisingly, `const T&amp;` is often not a const reference type.\n  //     By the reference collapsing rules in C++17 [dcl.ref]/6, if T refers to\n  //     U&amp; or U&amp;&amp; for some non-scalar type U, then InitialActionArgType&lt;T&gt; is\n  //     U&amp;. In other words, we may hand over a non-const reference.\n  //\n  //     So for example, given some non-scalar type Obj we have the following\n  //     mappings:\n  //\n  //            T               InitialActionArgType&lt;T&gt;\n  //         -------            -----------------------\n  //         Obj                const Obj&amp;\n  //         Obj&amp;               Obj&amp;\n  //         Obj&amp;&amp;              Obj&amp;\n  //         const Obj          const Obj&amp;\n  //         const Obj&amp;         const Obj&amp;\n  //         const Obj&amp;&amp;        const Obj&amp;\n  //\n  //     In other words, the initial actions get a mutable view of an non-scalar\n  //     argument if and only if the mock function itself accepts a non-const\n  //     reference type. They are never given an rvalue reference to an\n  //     non-scalar type.\n  //\n  //     This situation makes sense if you imagine use with a matcher that is\n  //     designed to write through a reference. For example, if the caller wants\n  //     to fill in a reference argument and then return a canned value:\n  //\n  //         EXPECT_CALL(mock, Call)\n  //             .WillOnce(DoAll(SetArgReferee&lt;0&gt;(17), Return(19)));\n  //\n  template &lt;typename T&gt;\n  using InitialActionArgType =\n      typename std::conditional&lt;std::is_scalar&lt;T&gt;::value, T, const T&amp;&gt;::type;\n\n public:\n  struct UserConstructorTag {};\n\n  template &lt;typename T, typename... U&gt;\n  explicit DoAllAction(UserConstructorTag, T&amp;&amp; initial_action,\n                       U&amp;&amp;... other_actions)\n      : Base({}, std::forward&lt;U&gt;(other_actions)...),\n        initial_action_(std::forward&lt;T&gt;(initial_action)) {}\n\n  template &lt;typename R, typename... Args,\n            typename std::enable_if&lt;\n                conjunction&lt;\n                    // Both the initial action and the rest must support\n                    // conversion to OnceAction.\n                    std::is_convertible&lt;\n                        InitialAction,\n                        OnceAction&lt;void(InitialActionArgType&lt;Args&gt;...)&gt;&gt;,\n                    std::is_convertible&lt;Base, OnceAction&lt;R(Args...)&gt;&gt;&gt;::value,\n                int&gt;::type = 0&gt;\n  operator OnceAction&lt;R(Args...)&gt;() &amp;&amp; {  // NOLINT\n    // Return an action that first calls the initial action with arguments\n    // filtered through InitialActionArgType, then forwards arguments directly\n    // to the base class to deal with the remaining actions.\n    struct OA {\n      OnceAction&lt;void(InitialActionArgType&lt;Args&gt;...)&gt; initial_action;\n      OnceAction&lt;R(Args...)&gt; remaining_actions;\n\n      R operator()(Args... args) &amp;&amp; {\n        std::move(initial_action)\n            .Call(static_cast&lt;InitialActionArgType&lt;Args&gt;&gt;(args)...);\n\n        return std::move(remaining_actions).Call(std::forward&lt;Args&gt;(args)...);\n      }\n    };\n\n    return OA{\n        std::move(initial_action_),\n        std::move(static_cast&lt;Base&amp;&gt;(*this)),\n    };\n  }\n\n  template &lt;\n      typename R, typename... Args,\n      typename std::enable_if&lt;\n          conjunction&lt;\n              // Both the initial action and the rest must support conversion to\n              // Action.\n              std::is_convertible&lt;const InitialAction&amp;,\n                                  Action&lt;void(InitialActionArgType&lt;Args&gt;...)&gt;&gt;,\n              std::is_convertible&lt;const Base&amp;, Action&lt;R(Args...)&gt;&gt;&gt;::value,\n          int&gt;::type = 0&gt;\n  operator Action&lt;R(Args...)&gt;() const {  // NOLINT\n    // Return an action that first calls the initial action with arguments\n    // filtered through InitialActionArgType, then forwards arguments directly\n    // to the base class to deal with the remaining actions.\n    struct OA {\n      Action&lt;void(InitialActionArgType&lt;Args&gt;...)&gt; initial_action;\n      Action&lt;R(Args...)&gt; remaining_actions;\n\n      R operator()(Args... args) const {\n        initial_action.Perform(std::forward_as_tuple(\n            static_cast&lt;InitialActionArgType&lt;Args&gt;&gt;(args)...));\n\n        return remaining_actions.Perform(\n            std::forward_as_tuple(std::forward&lt;Args&gt;(args)...));\n      }\n    };\n\n    return OA{\n        initial_action_,\n        static_cast&lt;const Base&amp;&gt;(*this),\n    };\n  }\n\n private:\n  InitialAction initial_action_;\n};\n\ntemplate &lt;typename T, typename... Params&gt;\nstruct ReturnNewAction {\n  T* operator()() const {\n    return internal::Apply(\n        [](const Params&amp;... unpacked_params) {\n          return new T(unpacked_params...);\n        },\n        params);\n  }\n  std::tuple&lt;Params...&gt; params;\n};\n\ntemplate &lt;size_t k&gt;\nstruct ReturnArgAction {\n  template &lt;typename... Args,\n            typename = typename std::enable_if&lt;(k &lt; sizeof...(Args))&gt;::type&gt;\n  auto operator()(Args&amp;&amp;... args) const -&gt; decltype(std::get&lt;k&gt;(\n      std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))) {\n    return std::get&lt;k&gt;(std::forward_as_tuple(std::forward&lt;Args&gt;(args)...));\n  }\n};\n\ntemplate &lt;size_t k, typename Ptr&gt;\nstruct SaveArgAction {\n  Ptr pointer;\n\n  template &lt;typename... Args&gt;\n  void operator()(const Args&amp;... args) const {\n    *pointer = std::get&lt;k&gt;(std::tie(args...));\n  }\n};\n\ntemplate &lt;size_t k, typename Ptr&gt;\nstruct SaveArgPointeeAction {\n  Ptr pointer;\n\n  template &lt;typename... Args&gt;\n  void operator()(const Args&amp;... args) const {\n    *pointer = *std::get&lt;k&gt;(std::tie(args...));\n  }\n};\n\ntemplate &lt;size_t k, typename T&gt;\nstruct SetArgRefereeAction {\n  T value;\n\n  template &lt;typename... Args&gt;\n  void operator()(Args&amp;&amp;... args) const {\n    using argk_type =\n        typename ::std::tuple_element&lt;k, std::tuple&lt;Args...&gt;&gt;::type;\n    static_assert(std::is_lvalue_reference&lt;argk_type&gt;::value,\n                  &quot;Argument must be a reference type.&quot;);\n    std::get&lt;k&gt;(std::tie(args...)) = value;\n  }\n};\n\ntemplate &lt;size_t k, typename I1, typename I2&gt;\nstruct SetArrayArgumentAction {\n  I1 first;\n  I2 last;\n\n  template &lt;typename... Args&gt;\n  void operator()(const Args&amp;... args) const {\n    auto value = std::get&lt;k&gt;(std::tie(args...));\n    for (auto it = first; it != last; ++it, (void)++value) {\n      *value = *it;\n    }\n  }\n};\n\ntemplate &lt;size_t k&gt;\nstruct DeleteArgAction {\n  template &lt;typename... Args&gt;\n  void operator()(const Args&amp;... args) const {\n    delete std::get&lt;k&gt;(std::tie(args...));\n  }\n};\n\ntemplate &lt;typename Ptr&gt;\nstruct ReturnPointeeAction {\n  Ptr pointer;\n  template &lt;typename... Args&gt;\n  auto operator()(const Args&amp;...) const -&gt; decltype(*pointer) {\n    return *pointer;\n  }\n};\n\n#if GTEST_HAS_EXCEPTIONS\ntemplate &lt;typename T&gt;\nstruct ThrowAction {\n  T exception;\n  // We use a conversion operator to adapt to any return type.\n  template &lt;typename R, typename... Args&gt;\n  operator Action&lt;R(Args...)&gt;() const {  // NOLINT\n    T copy = exception;\n    return [copy](Args...) -&gt; R { throw copy; };\n  }\n};\n#endif  // GTEST_HAS_EXCEPTIONS\n\n}  // namespace internal\n\n// An Unused object can be implicitly constructed from ANY value.\n// This is handy when defining actions that ignore some or all of the\n// mock function arguments.  For example, given\n//\n//   MOCK_METHOD3(Foo, double(const string&amp; label, double x, double y));\n//   MOCK_METHOD3(Bar, double(int index, double x, double y));\n//\n// instead of\n//\n//   double DistanceToOriginWithLabel(const string&amp; label, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   double DistanceToOriginWithIndex(int index, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXPECT_CALL(mock, Foo(&quot;abc&quot;, _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithLabel));\n//   EXPECT_CALL(mock, Bar(5, _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithIndex));\n//\n// you could write\n//\n//   // We can declare any uninteresting argument as Unused.\n//   double DistanceToOrigin(Unused, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXPECT_CALL(mock, Foo(&quot;abc&quot;, _, _)).WillOnce(Invoke(DistanceToOrigin));\n//   EXPECT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));\ntypedef internal::IgnoredValue Unused;\n\n// Creates an action that does actions a1, a2, ..., sequentially in\n// each invocation. All but the last action will have a readonly view of the\n// arguments.\ntemplate &lt;typename... Action&gt;\ninternal::DoAllAction&lt;typename std::decay&lt;Action&gt;::type...&gt; DoAll(\n    Action&amp;&amp;... action) {\n  return internal::DoAllAction&lt;typename std::decay&lt;Action&gt;::type...&gt;(\n      {}, std::forward&lt;Action&gt;(action)...);\n}\n\n// WithArg&lt;k&gt;(an_action) creates an action that passes the k-th\n// (0-based) argument of the mock function to an_action and performs\n// it.  It adapts an action accepting one argument to one that accepts\n// multiple arguments.  For convenience, we also provide\n// WithArgs&lt;k&gt;(an_action) (defined below) as a synonym.\ntemplate &lt;size_t k, typename InnerAction&gt;\ninternal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k&gt; WithArg(\n    InnerAction&amp;&amp; action) {\n  return {std::forward&lt;InnerAction&gt;(action)};\n}\n\n// WithArgs&lt;N1, N2, ..., Nk&gt;(an_action) creates an action that passes\n// the selected arguments of the mock function to an_action and\n// performs it.  It serves as an adaptor between actions with\n// different argument lists.\ntemplate &lt;size_t k, size_t... ks, typename InnerAction&gt;\ninternal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k, ks...&gt;\nWithArgs(InnerAction&amp;&amp; action) {\n  return {std::forward&lt;InnerAction&gt;(action)};\n}\n\n// WithoutArgs(inner_action) can be used in a mock function with a\n// non-empty argument list to perform inner_action, which takes no\n// argument.  In other words, it adapts an action accepting no\n// argument to one that accepts (and ignores) arguments.\ntemplate &lt;typename InnerAction&gt;\ninternal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type&gt; WithoutArgs(\n    InnerAction&amp;&amp; action) {\n  return {std::forward&lt;InnerAction&gt;(action)};\n}\n\n// Creates an action that returns a value.\n//\n// The returned type can be used with a mock function returning a non-void,\n// non-reference type U as follows:\n//\n//  *  If R is convertible to U and U is move-constructible, then the action can\n//     be used with WillOnce.\n//\n//  *  If const R&amp; is convertible to U and U is copy-constructible, then the\n//     action can be used with both WillOnce and WillRepeatedly.\n//\n// The mock expectation contains the R value from which the U return value is\n// constructed (a move/copy of the argument to Return). This means that the R\n// value will survive at least until the mock object&#x27;s expectations are cleared\n// or the mock object is destroyed, meaning that U can safely be a\n// reference-like type such as std::string_view:\n//\n//     // The mock function returns a view of a copy of the string fed to\n//     // Return. The view is valid even after the action is performed.\n//     MockFunction&lt;std::string_view()&gt; mock;\n//     EXPECT_CALL(mock, Call).WillOnce(Return(std::string(&quot;taco&quot;)));\n//     const std::string_view result = mock.AsStdFunction()();\n//     EXPECT_EQ(&quot;taco&quot;, result);\n//\ntemplate &lt;typename R&gt;\ninternal::ReturnAction&lt;R&gt; Return(R value) {\n  return internal::ReturnAction&lt;R&gt;(std::move(value));\n}\n\n// Creates an action that returns NULL.\ninline PolymorphicAction&lt;internal::ReturnNullAction&gt; ReturnNull() {\n  return MakePolymorphicAction(internal::ReturnNullAction());\n}\n\n// Creates an action that returns from a void function.\ninline PolymorphicAction&lt;internal::ReturnVoidAction&gt; Return() {\n  return MakePolymorphicAction(internal::ReturnVoidAction());\n}\n\n// Creates an action that returns the reference to a variable.\ntemplate &lt;typename R&gt;\ninline internal::ReturnRefAction&lt;R&gt; ReturnRef(R&amp; x) {  // NOLINT\n  return internal::ReturnRefAction&lt;R&gt;(x);\n}\n\n// Prevent using ReturnRef on reference to temporary.\ntemplate &lt;typename R, R* = nullptr&gt;\ninternal::ReturnRefAction&lt;R&gt; ReturnRef(R&amp;&amp;) = delete;\n\n// Creates an action that returns the reference to a copy of the\n// argument.  The copy is created when the action is constructed and\n// lives as long as the action.\ntemplate &lt;typename R&gt;\ninline internal::ReturnRefOfCopyAction&lt;R&gt; ReturnRefOfCopy(const R&amp; x) {\n  return internal::ReturnRefOfCopyAction&lt;R&gt;(x);\n}\n\n// DEPRECATED: use Return(x) directly with WillOnce.\n//\n// Modifies the parent action (a Return() action) to perform a move of the\n// argument instead of a copy.\n// Return(ByMove()) actions can only be executed once and will assert this\n// invariant.\ntemplate &lt;typename R&gt;\ninternal::ByMoveWrapper&lt;R&gt; ByMove(R x) {\n  return internal::ByMoveWrapper&lt;R&gt;(std::move(x));\n}\n\n// Creates an action that returns an element of `vals`. Calling this action will\n// repeatedly return the next value from `vals` until it reaches the end and\n// will restart from the beginning.\ntemplate &lt;typename T&gt;\ninternal::ReturnRoundRobinAction&lt;T&gt; ReturnRoundRobin(std::vector&lt;T&gt; vals) {\n  return internal::ReturnRoundRobinAction&lt;T&gt;(std::move(vals));\n}\n\n// Creates an action that returns an element of `vals`. Calling this action will\n// repeatedly return the next value from `vals` until it reaches the end and\n// will restart from the beginning.\ntemplate &lt;typename T&gt;\ninternal::ReturnRoundRobinAction&lt;T&gt; ReturnRoundRobin(\n    std::initializer_list&lt;T&gt; vals) {\n  return internal::ReturnRoundRobinAction&lt;T&gt;(std::vector&lt;T&gt;(vals));\n}\n\n// Creates an action that does the default action for the give mock function.\ninline internal::DoDefaultAction DoDefault() {\n  return internal::DoDefaultAction();\n}\n\n// Creates an action that sets the variable pointed by the N-th\n// (0-based) function argument to &#x27;value&#x27;.\ntemplate &lt;size_t N, typename T&gt;\ninternal::SetArgumentPointeeAction&lt;N, T&gt; SetArgPointee(T value) {\n  return {std::move(value)};\n}\n\n// The following version is DEPRECATED.\ntemplate &lt;size_t N, typename T&gt;\ninternal::SetArgumentPointeeAction&lt;N, T&gt; SetArgumentPointee(T value) {\n  return {std::move(value)};\n}\n\n// Creates an action that sets a pointer referent to a given value.\ntemplate &lt;typename T1, typename T2&gt;\nPolymorphicAction&lt;internal::AssignAction&lt;T1, T2&gt;&gt; Assign(T1* ptr, T2 val) {\n  return MakePolymorphicAction(internal::AssignAction&lt;T1, T2&gt;(ptr, val));\n}\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Creates an action that sets errno and returns the appropriate error.\ntemplate &lt;typename T&gt;\nPolymorphicAction&lt;internal::SetErrnoAndReturnAction&lt;T&gt;&gt; SetErrnoAndReturn(\n    int errval, T result) {\n  return MakePolymorphicAction(\n      internal::SetErrnoAndReturnAction&lt;T&gt;(errval, result));\n}\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Various overloads for Invoke().\n\n// Legacy function.\n// Actions can now be implicitly constructed from callables. No need to create\n// wrapper objects.\n// This function exists for backwards compatibility.\ntemplate &lt;typename FunctionImpl&gt;\ntypename std::decay&lt;FunctionImpl&gt;::type Invoke(FunctionImpl&amp;&amp; function_impl) {\n  return std::forward&lt;FunctionImpl&gt;(function_impl);\n}\n\n// Creates an action that invokes the given method on the given object\n// with the mock function&#x27;s arguments.\ntemplate &lt;class Class, typename MethodPtr&gt;\ninternal::InvokeMethodAction&lt;Class, MethodPtr&gt; Invoke(Class* obj_ptr,\n                                                      MethodPtr method_ptr) {\n  return {obj_ptr, method_ptr};\n}\n\n// Creates an action that invokes &#x27;function_impl&#x27; with no argument.\ntemplate &lt;typename FunctionImpl&gt;\ninternal::InvokeWithoutArgsAction&lt;typename std::decay&lt;FunctionImpl&gt;::type&gt;\nInvokeWithoutArgs(FunctionImpl function_impl) {\n  return {std::move(function_impl)};\n}\n\n// Creates an action that invokes the given method on the given object\n// with no argument.\ntemplate &lt;class Class, typename MethodPtr&gt;\ninternal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt; InvokeWithoutArgs(\n    Class* obj_ptr, MethodPtr method_ptr) {\n  return {obj_ptr, method_ptr};\n}\n\n// Creates an action that performs an_action and throws away its\n// result.  In other words, it changes the return type of an_action to\n// void.  an_action MUST NOT return void, or the code won&#x27;t compile.\ntemplate &lt;typename A&gt;\ninline internal::IgnoreResultAction&lt;A&gt; IgnoreResult(const A&amp; an_action) {\n  return internal::IgnoreResultAction&lt;A&gt;(an_action);\n}\n\n// Creates a reference wrapper for the given L-value.  If necessary,\n// you can explicitly specify the type of the reference.  For example,\n// suppose &#x27;derived&#x27; is an object of type Derived, ByRef(derived)\n// would wrap a Derived&amp;.  If you want to wrap a const Base&amp; instead,\n// where Base is a base class of Derived, just write:\n//\n//   ByRef&lt;const Base&gt;(derived)\n//\n// N.B. ByRef is redundant with std::ref, std::cref and std::reference_wrapper.\n// However, it may still be used for consistency with ByMove().\ntemplate &lt;typename T&gt;\ninline ::std::reference_wrapper&lt;T&gt; ByRef(T&amp; l_value) {  // NOLINT\n  return ::std::reference_wrapper&lt;T&gt;(l_value);\n}\n\n// The ReturnNew&lt;T&gt;(a1, a2, ..., a_k) action returns a pointer to a new\n// instance of type T, constructed on the heap with constructor arguments\n// a1, a2, ..., and a_k. The caller assumes ownership of the returned value.\ntemplate &lt;typename T, typename... Params&gt;\ninternal::ReturnNewAction&lt;T, typename std::decay&lt;Params&gt;::type...&gt; ReturnNew(\n    Params&amp;&amp;... params) {\n  return {std::forward_as_tuple(std::forward&lt;Params&gt;(params)...)};\n}\n\n// Action ReturnArg&lt;k&gt;() returns the k-th argument of the mock function.\ntemplate &lt;size_t k&gt;\ninternal::ReturnArgAction&lt;k&gt; ReturnArg() {\n  return {};\n}\n\n// Action SaveArg&lt;k&gt;(pointer) saves the k-th (0-based) argument of the\n// mock function to *pointer.\ntemplate &lt;size_t k, typename Ptr&gt;\ninternal::SaveArgAction&lt;k, Ptr&gt; SaveArg(Ptr pointer) {\n  return {pointer};\n}\n\n// Action SaveArgPointee&lt;k&gt;(pointer) saves the value pointed to\n// by the k-th (0-based) argument of the mock function to *pointer.\ntemplate &lt;size_t k, typename Ptr&gt;\ninternal::SaveArgPointeeAction&lt;k, Ptr&gt; SaveArgPointee(Ptr pointer) {\n  return {pointer};\n}\n\n// Action SetArgReferee&lt;k&gt;(value) assigns &#x27;value&#x27; to the variable\n// referenced by the k-th (0-based) argument of the mock function.\ntemplate &lt;size_t k, typename T&gt;\ninternal::SetArgRefereeAction&lt;k, typename std::decay&lt;T&gt;::type&gt; SetArgReferee(\n    T&amp;&amp; value) {\n  return {std::forward&lt;T&gt;(value)};\n}\n\n// Action SetArrayArgument&lt;k&gt;(first, last) copies the elements in\n// source range [first, last) to the array pointed to by the k-th\n// (0-based) argument, which can be either a pointer or an\n// iterator. The action does not take ownership of the elements in the\n// source range.\ntemplate &lt;size_t k, typename I1, typename I2&gt;\ninternal::SetArrayArgumentAction&lt;k, I1, I2&gt; SetArrayArgument(I1 first,\n                                                             I2 last) {\n  return {first, last};\n}\n\n// Action DeleteArg&lt;k&gt;() deletes the k-th (0-based) argument of the mock\n// function.\ntemplate &lt;size_t k&gt;\ninternal::DeleteArgAction&lt;k&gt; DeleteArg() {\n  return {};\n}\n\n// This action returns the value pointed to by &#x27;pointer&#x27;.\ntemplate &lt;typename Ptr&gt;\ninternal::ReturnPointeeAction&lt;Ptr&gt; ReturnPointee(Ptr pointer) {\n  return {pointer};\n}\n\n// Action Throw(exception) can be used in a mock function of any type\n// to throw the given exception.  Any copyable value can be thrown.\n#if GTEST_HAS_EXCEPTIONS\ntemplate &lt;typename T&gt;\ninternal::ThrowAction&lt;typename std::decay&lt;T&gt;::type&gt; Throw(T&amp;&amp; exception) {\n  return {std::forward&lt;T&gt;(exception)};\n}\n#endif  // GTEST_HAS_EXCEPTIONS\n\nnamespace internal {\n\n// A macro from the ACTION* family (defined later in gmock-generated-actions.h)\n// defines an action that can be used in a mock function.  Typically,\n// these actions only care about a subset of the arguments of the mock\n// function.  For example, if such an action only uses the second\n// argument, it can be used in any mock function that takes &gt;= 2\n// arguments where the type of the second argument is compatible.\n//\n// Therefore, the action implementation must be prepared to take more\n// arguments than it needs.  The ExcessiveArg type is used to\n// represent those excessive arguments.  In order to keep the compiler\n// error messages tractable, we define it in the testing namespace\n// instead of testing::internal.  However, this is an INTERNAL TYPE\n// and subject to change without notice, so a user MUST NOT USE THIS\n// TYPE DIRECTLY.\nstruct ExcessiveArg {};\n\n// Builds an implementation of an Action&lt;&gt; for some particular signature, using\n// a class defined by an ACTION* macro.\ntemplate &lt;typename F, typename Impl&gt;\nstruct ActionImpl;\n\ntemplate &lt;typename Impl&gt;\nstruct ImplBase {\n  struct Holder {\n    // Allows each copy of the Action&lt;&gt; to get to the Impl.\n    explicit operator const Impl&amp;() const { return *ptr; }\n    std::shared_ptr&lt;Impl&gt; ptr;\n  };\n  using type = typename std::conditional&lt;std::is_constructible&lt;Impl&gt;::value,\n                                         Impl, Holder&gt;::type;\n};\n\ntemplate &lt;typename R, typename... Args, typename Impl&gt;\nstruct ActionImpl&lt;R(Args...), Impl&gt; : ImplBase&lt;Impl&gt;::type {\n  using Base = typename ImplBase&lt;Impl&gt;::type;\n  using function_type = R(Args...);\n  using args_type = std::tuple&lt;Args...&gt;;\n\n  ActionImpl() = default;  // Only defined if appropriate for Base.\n  explicit ActionImpl(std::shared_ptr&lt;Impl&gt; impl) : Base{std::move(impl)} {}\n\n  R operator()(Args&amp;&amp;... arg) const {\n    static constexpr size_t kMaxArgs =\n        sizeof...(Args) &lt;= 10 ? sizeof...(Args) : 10;\n    return Apply(MakeIndexSequence&lt;kMaxArgs&gt;{},\n                 MakeIndexSequence&lt;10 - kMaxArgs&gt;{},\n                 args_type{std::forward&lt;Args&gt;(arg)...});\n  }\n\n  template &lt;std::size_t... arg_id, std::size_t... excess_id&gt;\n  R Apply(IndexSequence&lt;arg_id...&gt;, IndexSequence&lt;excess_id...&gt;,\n          const args_type&amp; args) const {\n    // Impl need not be specific to the signature of action being implemented;\n    // only the implementing function body needs to have all of the specific\n    // types instantiated.  Up to 10 of the args that are provided by the\n    // args_type get passed, followed by a dummy of unspecified type for the\n    // remainder up to 10 explicit args.\n    static constexpr ExcessiveArg kExcessArg{};\n    return static_cast&lt;const Impl&amp;&gt;(*this)\n        .template gmock_PerformImpl&lt;\n            /*function_type=*/function_type, /*return_type=*/R,\n            /*args_type=*/args_type,\n            /*argN_type=*/\n            typename std::tuple_element&lt;arg_id, args_type&gt;::type...&gt;(\n            /*args=*/args, std::get&lt;arg_id&gt;(args)...,\n            ((void)excess_id, kExcessArg)...);\n  }\n};\n\n// Stores a default-constructed Impl as part of the Action&lt;&gt;&#x27;s\n// std::function&lt;&gt;. The Impl should be trivial to copy.\ntemplate &lt;typename F, typename Impl&gt;\n::testing::Action&lt;F&gt; MakeAction() {\n  return ::testing::Action&lt;F&gt;(ActionImpl&lt;F, Impl&gt;());\n}\n\n// Stores just the one given instance of Impl.\ntemplate &lt;typename F, typename Impl&gt;\n::testing::Action&lt;F&gt; MakeAction(std::shared_ptr&lt;Impl&gt; impl) {\n  return ::testing::Action&lt;F&gt;(ActionImpl&lt;F, Impl&gt;(std::move(impl)));\n}\n\n#define GMOCK_INTERNAL_ARG_UNUSED(i, data, el) \\\n  , const arg##i##_type&amp; arg##i GTEST_ATTRIBUTE_UNUSED_\n#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_                 \\\n  const args_type&amp; args GTEST_ATTRIBUTE_UNUSED_ GMOCK_PP_REPEAT( \\\n      GMOCK_INTERNAL_ARG_UNUSED, , 10)\n\n#define GMOCK_INTERNAL_ARG(i, data, el) , const arg##i##_type&amp; arg##i\n#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_ \\\n  const args_type&amp; args GMOCK_PP_REPEAT(GMOCK_INTERNAL_ARG, , 10)\n\n#define GMOCK_INTERNAL_TEMPLATE_ARG(i, data, el) , typename arg##i##_type\n#define GMOCK_ACTION_TEMPLATE_ARGS_NAMES_ \\\n  GMOCK_PP_TAIL(GMOCK_PP_REPEAT(GMOCK_INTERNAL_TEMPLATE_ARG, , 10))\n\n#define GMOCK_INTERNAL_TYPENAME_PARAM(i, data, param) , typename param##_type\n#define GMOCK_ACTION_TYPENAME_PARAMS_(params) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_TYPENAME_PARAM, , params))\n\n#define GMOCK_INTERNAL_TYPE_PARAM(i, data, param) , param##_type\n#define GMOCK_ACTION_TYPE_PARAMS_(params) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_TYPE_PARAM, , params))\n\n#define GMOCK_INTERNAL_TYPE_GVALUE_PARAM(i, data, param) \\\n  , param##_type gmock_p##i\n#define GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_TYPE_GVALUE_PARAM, , params))\n\n#define GMOCK_INTERNAL_GVALUE_PARAM(i, data, param) \\\n  , std::forward&lt;param##_type&gt;(gmock_p##i)\n#define GMOCK_ACTION_GVALUE_PARAMS_(params) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_GVALUE_PARAM, , params))\n\n#define GMOCK_INTERNAL_INIT_PARAM(i, data, param) \\\n  , param(::std::forward&lt;param##_type&gt;(gmock_p##i))\n#define GMOCK_ACTION_INIT_PARAMS_(params) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_INIT_PARAM, , params))\n\n#define GMOCK_INTERNAL_FIELD_PARAM(i, data, param) param##_type param;\n#define GMOCK_ACTION_FIELD_PARAMS_(params) \\\n  GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_FIELD_PARAM, , params)\n\n#define GMOCK_INTERNAL_ACTION(name, full_name, params)                         \\\n  template &lt;GMOCK_ACTION_TYPENAME_PARAMS_(params)&gt;                             \\\n  class full_name {                                                            \\\n   public:                                                                     \\\n    explicit full_name(GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params))               \\\n        : impl_(std::make_shared&lt;gmock_Impl&gt;(                                  \\\n              GMOCK_ACTION_GVALUE_PARAMS_(params))) {}                         \\\n    full_name(const full_name&amp;) = default;                                     \\\n    full_name(full_name&amp;&amp;) noexcept = default;                                 \\\n    template &lt;typename F&gt;                                                      \\\n    operator ::testing::Action&lt;F&gt;() const {                                    \\\n      return ::testing::internal::MakeAction&lt;F&gt;(impl_);                        \\\n    }                                                                          \\\n                                                                               \\\n   private:                                                                    \\\n    class gmock_Impl {                                                         \\\n     public:                                                                   \\\n      explicit gmock_Impl(GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params))            \\\n          : GMOCK_ACTION_INIT_PARAMS_(params) {}                               \\\n      template &lt;typename function_type, typename return_type,                  \\\n                typename args_type, GMOCK_ACTION_TEMPLATE_ARGS_NAMES_&gt;         \\\n      return_type gmock_PerformImpl(GMOCK_ACTION_ARG_TYPES_AND_NAMES_) const;  \\\n      GMOCK_ACTION_FIELD_PARAMS_(params)                                       \\\n    };                                                                         \\\n    std::shared_ptr&lt;const gmock_Impl&gt; impl_;                                   \\\n  };                                                                           \\\n  template &lt;GMOCK_ACTION_TYPENAME_PARAMS_(params)&gt;                             \\\n  inline full_name&lt;GMOCK_ACTION_TYPE_PARAMS_(params)&gt; name(                    \\\n      GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params)) GTEST_MUST_USE_RESULT_;        \\\n  template &lt;GMOCK_ACTION_TYPENAME_PARAMS_(params)&gt;                             \\\n  inline full_name&lt;GMOCK_ACTION_TYPE_PARAMS_(params)&gt; name(                    \\\n      GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params)) {                              \\\n    return full_name&lt;GMOCK_ACTION_TYPE_PARAMS_(params)&gt;(                       \\\n        GMOCK_ACTION_GVALUE_PARAMS_(params));                                  \\\n  }                                                                            \\\n  template &lt;GMOCK_ACTION_TYPENAME_PARAMS_(params)&gt;                             \\\n  template &lt;typename function_type, typename return_type, typename args_type,  \\\n            GMOCK_ACTION_TEMPLATE_ARGS_NAMES_&gt;                                 \\\n  return_type                                                                  \\\n  full_name&lt;GMOCK_ACTION_TYPE_PARAMS_(params)&gt;::gmock_Impl::gmock_PerformImpl( \\\n      GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n}  // namespace internal\n\n// Similar to GMOCK_INTERNAL_ACTION, but no bound parameters are stored.\n#define ACTION(name)                                                          \\\n  class name##Action {                                                        \\\n   public:                                                                    \\\n    explicit name##Action() noexcept {}                                       \\\n    name##Action(const name##Action&amp;) noexcept {}                             \\\n    template &lt;typename F&gt;                                                     \\\n    operator ::testing::Action&lt;F&gt;() const {                                   \\\n      return ::testing::internal::MakeAction&lt;F, gmock_Impl&gt;();                \\\n    }                                                                         \\\n                                                                              \\\n   private:                                                                   \\\n    class gmock_Impl {                                                        \\\n     public:                                                                  \\\n      template &lt;typename function_type, typename return_type,                 \\\n                typename args_type, GMOCK_ACTION_TEMPLATE_ARGS_NAMES_&gt;        \\\n      return_type gmock_PerformImpl(GMOCK_ACTION_ARG_TYPES_AND_NAMES_) const; \\\n    };                                                                        \\\n  };                                                                          \\\n  inline name##Action name() GTEST_MUST_USE_RESULT_;                          \\\n  inline name##Action name() { return name##Action(); }                       \\\n  template &lt;typename function_type, typename return_type, typename args_type, \\\n            GMOCK_ACTION_TEMPLATE_ARGS_NAMES_&gt;                                \\\n  return_type name##Action::gmock_Impl::gmock_PerformImpl(                    \\\n      GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP, (__VA_ARGS__))\n\n#define ACTION_P2(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP2, (__VA_ARGS__))\n\n#define ACTION_P3(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP3, (__VA_ARGS__))\n\n#define ACTION_P4(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP4, (__VA_ARGS__))\n\n#define ACTION_P5(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP5, (__VA_ARGS__))\n\n#define ACTION_P6(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP6, (__VA_ARGS__))\n\n#define ACTION_P7(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP7, (__VA_ARGS__))\n\n#define ACTION_P8(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP8, (__VA_ARGS__))\n\n#define ACTION_P9(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP9, (__VA_ARGS__))\n\n#define ACTION_P10(name, ...) \\\n  GMOCK_INTERNAL_ACTION(name, name##ActionP10, (__VA_ARGS__))\n\n}  // namespace testing\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n#endif  // GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// The MATCHER* family of macros can be used in a namespace scope to\n// define custom matchers easily.\n//\n// Basic Usage\n// ===========\n//\n// The syntax\n//\n//   MATCHER(name, description_string) { statements; }\n//\n// defines a matcher with the given name that executes the statements,\n// which must return a bool to indicate if the match succeeds.  Inside\n// the statements, you can refer to the value being matched by &#x27;arg&#x27;,\n// and refer to its type by &#x27;arg_type&#x27;.\n//\n// The description string documents what the matcher does, and is used\n// to generate the failure message when the match fails.  Since a\n// MATCHER() is usually defined in a header file shared by multiple\n// C++ source files, we require the description to be a C-string\n// literal to avoid possible side effects.  It can be empty, in which\n// case we&#x27;ll use the sequence of words in the matcher name as the\n// description.\n//\n// For example:\n//\n//   MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }\n//\n// allows you to write\n//\n//   // Expects mock_foo.Bar(n) to be called where n is even.\n//   EXPECT_CALL(mock_foo, Bar(IsEven()));\n//\n// or,\n//\n//   // Verifies that the value of some_expression is even.\n//   EXPECT_THAT(some_expression, IsEven());\n//\n// If the above assertion fails, it will print something like:\n//\n//   Value of: some_expression\n//   Expected: is even\n//     Actual: 7\n//\n// where the description &quot;is even&quot; is automatically calculated from the\n// matcher name IsEven.\n//\n// Argument Type\n// =============\n//\n// Note that the type of the value being matched (arg_type) is\n// determined by the context in which you use the matcher and is\n// supplied to you by the compiler, so you don&#x27;t need to worry about\n// declaring it (nor can you).  This allows the matcher to be\n// polymorphic.  For example, IsEven() can be used to match any type\n// where the value of &quot;(arg % 2) == 0&quot; can be implicitly converted to\n// a bool.  In the &quot;Bar(IsEven())&quot; example above, if method Bar()\n// takes an int, &#x27;arg_type&#x27; will be int; if it takes an unsigned long,\n// &#x27;arg_type&#x27; will be unsigned long; and so on.\n//\n// Parameterizing Matchers\n// =======================\n//\n// Sometimes you&#x27;ll want to parameterize the matcher.  For that you\n// can use another macro:\n//\n//   MATCHER_P(name, param_name, description_string) { statements; }\n//\n// For example:\n//\n//   MATCHER_P(HasAbsoluteValue, value, &quot;&quot;) { return abs(arg) == value; }\n//\n// will allow you to write:\n//\n//   EXPECT_THAT(Blah(&quot;a&quot;), HasAbsoluteValue(n));\n//\n// which may lead to this message (assuming n is 10):\n//\n//   Value of: Blah(&quot;a&quot;)\n//   Expected: has absolute value 10\n//     Actual: -9\n//\n// Note that both the matcher description and its parameter are\n// printed, making the message human-friendly.\n//\n// In the matcher definition body, you can write &#x27;foo_type&#x27; to\n// reference the type of a parameter named &#x27;foo&#x27;.  For example, in the\n// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\n// &#x27;value_type&#x27; to refer to the type of &#x27;value&#x27;.\n//\n// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P$n to\n// support multi-parameter matchers.\n//\n// Describing Parameterized Matchers\n// =================================\n//\n// The last argument to MATCHER*() is a string-typed expression.  The\n// expression can reference all of the matcher&#x27;s parameters and a\n// special bool-typed variable named &#x27;negation&#x27;.  When &#x27;negation&#x27; is\n// false, the expression should evaluate to the matcher&#x27;s description;\n// otherwise it should evaluate to the description of the negation of\n// the matcher.  For example,\n//\n//   using testing::PrintToString;\n//\n//   MATCHER_P2(InClosedRange, low, hi,\n//       std::string(negation ? &quot;is not&quot; : &quot;is&quot;) + &quot; in range [&quot; +\n//       PrintToString(low) + &quot;, &quot; + PrintToString(hi) + &quot;]&quot;) {\n//     return low &lt;= arg &amp;&amp; arg &lt;= hi;\n//   }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: is in range [4, 6]\n//   ...\n//   Expected: is not in range [2, 4]\n//\n// If you specify &quot;&quot; as the description, the failure message will\n// contain the sequence of words in the matcher name followed by the\n// parameter values printed as a tuple.  For example,\n//\n//   MATCHER_P2(InClosedRange, low, hi, &quot;&quot;) { ... }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: in closed range (4, 6)\n//   ...\n//   Expected: not (in closed range (2, 4))\n//\n// Types of Matcher Parameters\n// ===========================\n//\n// For the purpose of typing, you can view\n//\n//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n//\n// as shorthand for\n//\n//   template &lt;typename p1_type, ..., typename pk_type&gt;\n//   FooMatcherPk&lt;p1_type, ..., pk_type&gt;\n//   Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// When you write Foo(v1, ..., vk), the compiler infers the types of\n// the parameters v1, ..., and vk for you.  If you are not happy with\n// the result of the type inference, you can specify the types by\n// explicitly instantiating the template, as in Foo&lt;long, bool&gt;(5,\n// false).  As said earlier, you don&#x27;t get to (or need to) specify\n// &#x27;arg_type&#x27; as that&#x27;s determined by the context in which the matcher\n// is used.  You can assign the result of expression Foo(p1, ..., pk)\n// to a variable of type FooMatcherPk&lt;p1_type, ..., pk_type&gt;.  This\n// can be useful when composing matchers.\n//\n// While you can instantiate a matcher template with reference types,\n// passing the parameters by pointer usually makes your code more\n// readable.  If, however, you still want to pass a parameter by\n// reference, be aware that in the failure message generated by the\n// matcher you will see the value of the referenced object but not its\n// address.\n//\n// Explaining Match Results\n// ========================\n//\n// Sometimes the matcher description alone isn&#x27;t enough to explain why\n// the match has failed or succeeded.  For example, when expecting a\n// long string, it can be very helpful to also print the diff between\n// the expected string and the actual one.  To achieve that, you can\n// optionally stream additional information to a special variable\n// named result_listener, whose type is a pointer to class\n// MatchResultListener:\n//\n//   MATCHER_P(EqualsLongString, str, &quot;&quot;) {\n//     if (arg == str) return true;\n//\n//     *result_listener &lt;&lt; &quot;the difference: &quot;\n///                     &lt;&lt; DiffStrings(str, arg);\n//     return false;\n//   }\n//\n// Overloading Matchers\n// ====================\n//\n// You can overload matchers with different numbers of parameters:\n//\n//   MATCHER_P(Blah, a, description_string1) { ... }\n//   MATCHER_P2(Blah, a, b, description_string2) { ... }\n//\n// Caveats\n// =======\n//\n// When defining a new matcher, you should also consider implementing\n// MatcherInterface or using MakePolymorphicMatcher().  These\n// approaches require more work than the MATCHER* macros, but also\n// give you more control on the types of the value being matched and\n// the matcher parameters, which may leads to better compiler error\n// messages when the matcher is used wrong.  They also allow\n// overloading matchers based on parameter types (as opposed to just\n// based on the number of parameters).\n//\n// MATCHER*() can only be used in a namespace scope as templates cannot be\n// declared inside of a local class.\n//\n// More Information\n// ================\n//\n// To learn more about using these macros, please search for &#x27;MATCHER&#x27;\n// on\n// https://github.com/google/googletest/blob/master/docs/gmock_cook_book.md\n//\n// This file also implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface&lt;T&gt; interface if necessary.\n//\n// See googletest/include/gtest/gtest-matchers.h for the definition of class\n// Matcher, class MatcherInterface, and others.\n\n// IWYU pragma: private, include &quot;gmock/gmock.h&quot;\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iterator&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &quot;gmock/internal/gmock-internal-utils.h&quot;\n#include &quot;gmock/internal/gmock-port.h&quot;\n#include &quot;gmock/internal/gmock-pp.h&quot;\n#include &quot;gtest/gtest.h&quot;\n\n// MSVC warning C5046 is new as of VS2017 version 15.8.\n#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915\n#define GMOCK_MAYBE_5046_ 5046\n#else\n#define GMOCK_MAYBE_5046_\n#endif\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(\n    4251 GMOCK_MAYBE_5046_ /* class A needs to have dll-interface to be used by\n                              clients of class B */\n    /* Symbol involving type with internal linkage not defined */)\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface&lt;T&gt; interface, and\n//   2. a factory function that creates a Matcher&lt;T&gt; object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write &quot;v&quot; instead of &quot;Eq(v)&quot; where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&amp;ss_) {}\n\n  // Returns the explanation accumulated so far.\n  std::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(&quot;&quot;); }\n\n private:\n  ::std::stringstream ss_;\n\n  StringMatchResultListener(const StringMatchResultListener&amp;) = delete;\n  StringMatchResultListener&amp; operator=(const StringMatchResultListener&amp;) =\n      delete;\n};\n\n// Anything inside the &#x27;internal&#x27; namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()&#x27;s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, &quot;hello&quot;).\ntemplate &lt;typename T, typename M&gt;\nclass MatcherCastImpl {\n public:\n  static Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {\n    // M can be a polymorphic matcher, in which case we want to use\n    // its conversion operator to create Matcher&lt;T&gt;.  Or it can be a value\n    // that should be passed to the Matcher&lt;T&gt;&#x27;s constructor.\n    //\n    // We can&#x27;t call Matcher&lt;T&gt;(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it&#x27;ll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won&#x27;t work to unconditionally implicit_cast\n    // polymorphic_matcher_or_value to Matcher&lt;T&gt; because it won&#x27;t trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(polymorphic_matcher_or_value,\n                    std::is_convertible&lt;M, Matcher&lt;T&gt;&gt;{},\n                    std::is_convertible&lt;M, T&gt;{});\n  }\n\n private:\n  template &lt;bool Ignore&gt;\n  static Matcher&lt;T&gt; CastImpl(const M&amp; polymorphic_matcher_or_value,\n                             std::true_type /* convertible_to_matcher */,\n                             std::integral_constant&lt;bool, Ignore&gt;) {\n    // M is implicitly convertible to Matcher&lt;T&gt;, which means that either\n    // M is a polymorphic matcher or Matcher&lt;T&gt; has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won&#x27;t be called because\n    // creating Matcher&lt;T&gt; would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher&lt;T&gt; from T).\n    return polymorphic_matcher_or_value;\n  }\n\n  // M can&#x27;t be implicitly converted to Matcher&lt;T&gt;, so M isn&#x27;t a polymorphic\n  // matcher. It&#x27;s a value of a type implicitly convertible to T. Use direct\n  // initialization to create a matcher.\n  static Matcher&lt;T&gt; CastImpl(const M&amp; value,\n                             std::false_type /* convertible_to_matcher */,\n                             std::true_type /* convertible_to_T */) {\n    return Matcher&lt;T&gt;(ImplicitCast_&lt;T&gt;(value));\n  }\n\n  // M can&#x27;t be implicitly converted to either Matcher&lt;T&gt; or T. Attempt to use\n  // polymorphic matcher Eq(value) in this case.\n  //\n  // Note that we first attempt to perform an implicit cast on the value and\n  // only fall back to the polymorphic Eq() matcher afterwards because the\n  // latter calls bool operator==(const Lhs&amp; lhs, const Rhs&amp; rhs) in the end\n  // which might be undefined even when Rhs is implicitly convertible to Lhs\n  // (e.g. std::pair&lt;const int, int&gt; vs. std::pair&lt;int, int&gt;).\n  //\n  // We don&#x27;t define this method inline as we need the declaration of Eq().\n  static Matcher&lt;T&gt; CastImpl(const M&amp; value,\n                             std::false_type /* convertible_to_matcher */,\n                             std::false_type /* convertible_to_T */);\n};\n\n// This more specialized version is used when MatcherCast()&#x27;s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate &lt;typename T, typename U&gt;\nclass MatcherCastImpl&lt;T, Matcher&lt;U&gt;&gt; {\n public:\n  static Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; source_matcher) {\n    return Matcher&lt;T&gt;(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface&lt;T&gt; {\n   public:\n    explicit Impl(const Matcher&lt;U&gt;&amp; source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    bool MatchAndExplain(T x, MatchResultListener* listener) const override {\n      using FromType = typename std::remove_cv&lt;typename std::remove_pointer&lt;\n          typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::type;\n      using ToType = typename std::remove_cv&lt;typename std::remove_pointer&lt;\n          typename std::remove_reference&lt;U&gt;::type&gt;::type&gt;::type;\n      // Do not allow implicitly converting base*/&amp; to derived*/&amp;.\n      static_assert(\n          // Do not trigger if only one of them is a pointer. That implies a\n          // regular conversion and not a down_cast.\n          (std::is_pointer&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value !=\n           std::is_pointer&lt;typename std::remove_reference&lt;U&gt;::type&gt;::value) ||\n              std::is_same&lt;FromType, ToType&gt;::value ||\n              !std::is_base_of&lt;FromType, ToType&gt;::value,\n          &quot;Can&#x27;t implicitly convert from &lt;base&gt; to &lt;derived&gt;&quot;);\n\n      // Do the cast to `U` explicitly if necessary.\n      // Otherwise, let implicit conversions do the trick.\n      using CastType =\n          typename std::conditional&lt;std::is_convertible&lt;T&amp;, const U&amp;&gt;::value,\n                                    T&amp;, U&gt;::type;\n\n      return source_matcher_.MatchAndExplain(static_cast&lt;CastType&gt;(x),\n                                             listener);\n    }\n\n    void DescribeTo(::std::ostream* os) const override {\n      source_matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher&lt;U&gt; source_matcher_;\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate &lt;typename T&gt;\nclass MatcherCastImpl&lt;T, Matcher&lt;T&gt;&gt; {\n public:\n  static Matcher&lt;T&gt; Cast(const Matcher&lt;T&gt;&amp; matcher) { return matcher; }\n};\n\n// Template specialization for parameterless Matcher.\ntemplate &lt;typename Derived&gt;\nclass MatcherBaseImpl {\n public:\n  MatcherBaseImpl() = default;\n\n  template &lt;typename T&gt;\n  operator ::testing::Matcher&lt;T&gt;() const {  // NOLINT(runtime/explicit)\n    return ::testing::Matcher&lt;T&gt;(new\n                                 typename Derived::template gmock_Impl&lt;T&gt;());\n  }\n};\n\n// Template specialization for Matcher with parameters.\ntemplate &lt;template &lt;typename...&gt; class Derived, typename... Ts&gt;\nclass MatcherBaseImpl&lt;Derived&lt;Ts...&gt;&gt; {\n public:\n  // Mark the constructor explicit for single argument T to avoid implicit\n  // conversions.\n  template &lt;typename E = std::enable_if&lt;sizeof...(Ts) == 1&gt;,\n            typename E::type* = nullptr&gt;\n  explicit MatcherBaseImpl(Ts... params)\n      : params_(std::forward&lt;Ts&gt;(params)...) {}\n  template &lt;typename E = std::enable_if&lt;sizeof...(Ts) != 1&gt;,\n            typename = typename E::type&gt;\n  MatcherBaseImpl(Ts... params)  // NOLINT\n      : params_(std::forward&lt;Ts&gt;(params)...) {}\n\n  template &lt;typename F&gt;\n  operator ::testing::Matcher&lt;F&gt;() const {  // NOLINT(runtime/explicit)\n    return Apply&lt;F&gt;(MakeIndexSequence&lt;sizeof...(Ts)&gt;{});\n  }\n\n private:\n  template &lt;typename F, std::size_t... tuple_ids&gt;\n  ::testing::Matcher&lt;F&gt; Apply(IndexSequence&lt;tuple_ids...&gt;) const {\n    return ::testing::Matcher&lt;F&gt;(\n        new typename Derived&lt;Ts...&gt;::template gmock_Impl&lt;F&gt;(\n            std::get&lt;tuple_ids&gt;(params_)...));\n  }\n\n  const std::tuple&lt;Ts...&gt; params_;\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast&lt;T&gt;(m), which takes a\n// matcher m and returns a Matcher&lt;T&gt;.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate &lt;typename T, typename M&gt;\ninline Matcher&lt;T&gt; MatcherCast(const M&amp; matcher) {\n  return internal::MatcherCastImpl&lt;T, M&gt;::Cast(matcher);\n}\n\n// This overload handles polymorphic matchers and values only since\n// monomorphic matchers are handled by the next one.\ntemplate &lt;typename T, typename M&gt;\ninline Matcher&lt;T&gt; SafeMatcherCast(const M&amp; polymorphic_matcher_or_value) {\n  return MatcherCast&lt;T&gt;(polymorphic_matcher_or_value);\n}\n\n// This overload handles monomorphic matchers.\n//\n// In general, if type T can be implicitly converted to type U, we can\n// safely convert a Matcher&lt;U&gt; to a Matcher&lt;T&gt; (i.e. Matcher is\n// contravariant): just keep a copy of the original Matcher&lt;U&gt;, convert the\n// argument from type T to U, and then pass it to the underlying Matcher&lt;U&gt;.\n// The only exception is when U is a reference and T is not, as the\n// underlying Matcher&lt;U&gt; may be interested in the argument&#x27;s address, which\n// is not preserved in the conversion from T to U.\ntemplate &lt;typename T, typename U&gt;\ninline Matcher&lt;T&gt; SafeMatcherCast(const Matcher&lt;U&gt;&amp; matcher) {\n  // Enforce that T can be implicitly converted to U.\n  static_assert(std::is_convertible&lt;const T&amp;, const U&amp;&gt;::value,\n                &quot;T must be implicitly convertible to U&quot;);\n  // Enforce that we are not converting a non-reference type T to a reference\n  // type U.\n  static_assert(std::is_reference&lt;T&gt;::value || !std::is_reference&lt;U&gt;::value,\n                &quot;cannot convert non reference arg to reference&quot;);\n  // In case both T and U are arithmetic types, enforce that the\n  // conversion is not lossy.\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n  constexpr bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n  constexpr bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n  static_assert(\n      kTIsOther || kUIsOther ||\n          (internal::LosslessArithmeticConvertible&lt;RawT, RawU&gt;::value),\n      &quot;conversion of arithmetic types must be lossless&quot;);\n  return MatcherCast&lt;T&gt;(matcher);\n}\n\n// A&lt;T&gt;() returns a matcher that matches any value of type T.\ntemplate &lt;typename T&gt;\nMatcher&lt;T&gt; A();\n\n// Anything inside the &#x27;internal&#x27; namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const std::string&amp; explanation,\n                            ::std::ostream* os) {\n  if (explanation != &quot;&quot; &amp;&amp; os != nullptr) {\n    *os &lt;&lt; &quot;, &quot; &lt;&lt; explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const std::string&amp; type_name) {\n  // We consider a type name readable if it&#x27;s short or doesn&#x27;t contain\n  // a template or function type.\n  return (type_name.length() &lt;= 20 ||\n          type_name.find_first_of(&quot;&lt;(&quot;) == std::string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// &#x27;listener&#x27; must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate &lt;typename Value, typename T&gt;\nbool MatchPrintAndExplain(Value&amp; value, const Matcher&lt;T&gt;&amp; matcher,\n                          MatchResultListener* listener) {\n  if (!listener-&gt;IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &amp;inner_listener);\n\n  UniversalPrint(value, listener-&gt;stream());\n#if GTEST_HAS_RTTI\n  const std::string&amp; type_name = GetTypeName&lt;Value&gt;();\n  if (IsReadableTypeName(type_name))\n    *listener-&gt;stream() &lt;&lt; &quot; (of type &quot; &lt;&lt; type_name &lt;&lt; &quot;)&quot;;\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple&#x27;s\n// fields.\ntemplate &lt;size_t N&gt;\nclass TuplePrefix {\n public:\n  // TuplePrefix&lt;N&gt;::Matches(matcher_tuple, value_tuple) returns true\n  // if and only if the first N fields of matcher_tuple matches\n  // the first N fields of value_tuple, respectively.\n  template &lt;typename MatcherTuple, typename ValueTuple&gt;\n  static bool Matches(const MatcherTuple&amp; matcher_tuple,\n                      const ValueTuple&amp; value_tuple) {\n    return TuplePrefix&lt;N - 1&gt;::Matches(matcher_tuple, value_tuple) &amp;&amp;\n           std::get&lt;N - 1&gt;(matcher_tuple).Matches(std::get&lt;N - 1&gt;(value_tuple));\n  }\n\n  // TuplePrefix&lt;N&gt;::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template &lt;typename MatcherTuple, typename ValueTuple&gt;\n  static void ExplainMatchFailuresTo(const MatcherTuple&amp; matchers,\n                                     const ValueTuple&amp; values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix&lt;N - 1&gt;::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename std::tuple_element&lt;N - 1, MatcherTuple&gt;::type matcher =\n        std::get&lt;N - 1&gt;(matchers);\n    typedef typename std::tuple_element&lt;N - 1, ValueTuple&gt;::type Value;\n    const Value&amp; value = std::get&lt;N - 1&gt;(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &amp;listener)) {\n      *os &lt;&lt; &quot;  Expected arg #&quot; &lt;&lt; N - 1 &lt;&lt; &quot;: &quot;;\n      std::get&lt;N - 1&gt;(matchers).DescribeTo(os);\n      *os &lt;&lt; &quot;\\n           Actual: &quot;;\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn&#x27;t interesting to the user most of the time.  The\n      // matcher&#x27;s MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os &lt;&lt; &quot;\\n&quot;;\n    }\n  }\n};\n\n// The base case.\ntemplate &lt;&gt;\nclass TuplePrefix&lt;0&gt; {\n public:\n  template &lt;typename MatcherTuple, typename ValueTuple&gt;\n  static bool Matches(const MatcherTuple&amp; /* matcher_tuple */,\n                      const ValueTuple&amp; /* value_tuple */) {\n    return true;\n  }\n\n  template &lt;typename MatcherTuple, typename ValueTuple&gt;\n  static void ExplainMatchFailuresTo(const MatcherTuple&amp; /* matchers */,\n                                     const ValueTuple&amp; /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true if and only if\n// all matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate &lt;typename MatcherTuple, typename ValueTuple&gt;\nbool TupleMatches(const MatcherTuple&amp; matcher_tuple,\n                  const ValueTuple&amp; value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  static_assert(std::tuple_size&lt;MatcherTuple&gt;::value ==\n                    std::tuple_size&lt;ValueTuple&gt;::value,\n                &quot;matcher and value have different numbers of fields&quot;);\n  return TuplePrefix&lt;std::tuple_size&lt;ValueTuple&gt;::value&gt;::Matches(matcher_tuple,\n                                                                  value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate &lt;typename MatcherTuple, typename ValueTuple&gt;\nvoid ExplainMatchFailureTupleTo(const MatcherTuple&amp; matchers,\n                                const ValueTuple&amp; values, ::std::ostream* os) {\n  TuplePrefix&lt;std::tuple_size&lt;MatcherTuple&gt;::value&gt;::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate &lt;typename Tuple, typename Func, typename OutIter&gt;\nclass TransformTupleValuesHelper {\n private:\n  typedef ::std::tuple_size&lt;Tuple&gt; TupleSize;\n\n public:\n  // For each member of tuple &#x27;t&#x27;, taken in order, evaluates &#x27;*out++ = f(t)&#x27;.\n  // Returns the final value of &#x27;out&#x27; in case the caller needs it.\n  static OutIter Run(Func f, const Tuple&amp; t, OutIter out) {\n    return IterateOverTuple&lt;Tuple, TupleSize::value&gt;()(f, t, out);\n  }\n\n private:\n  template &lt;typename Tup, size_t kRemainingSize&gt;\n  struct IterateOverTuple {\n    OutIter operator()(Func f, const Tup&amp; t, OutIter out) const {\n      *out++ = f(::std::get&lt;TupleSize::value - kRemainingSize&gt;(t));\n      return IterateOverTuple&lt;Tup, kRemainingSize - 1&gt;()(f, t, out);\n    }\n  };\n  template &lt;typename Tup&gt;\n  struct IterateOverTuple&lt;Tup, 0&gt; {\n    OutIter operator()(Func /* f */, const Tup&amp; /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes &#x27;f(element)&#x27; on each element of the tuple &#x27;t&#x27;,\n// appending each result to the &#x27;out&#x27; iterator. Returns the final value\n// of &#x27;out&#x27;.\ntemplate &lt;typename Tuple, typename Func, typename OutIter&gt;\nOutIter TransformTupleValues(Func f, const Tuple&amp; t, OutIter out) {\n  return TransformTupleValuesHelper&lt;Tuple, Func, OutIter&gt;::Run(f, t, out);\n}\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher&lt;T&gt; for any\n// type T.\nclass AnythingMatcher {\n public:\n  using is_gtest_matcher = void;\n\n  template &lt;typename T&gt;\n  bool MatchAndExplain(const T&amp; /* x */, std::ostream* /* listener */) const {\n    return true;\n  }\n  void DescribeTo(std::ostream* os) const { *os &lt;&lt; &quot;is anything&quot;; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness&#x27; sake, as it&#x27;s not very useful\n    // to write Not(A&lt;bool&gt;()).  However we cannot completely rule out\n    // such a possibility, and it doesn&#x27;t hurt to be prepared.\n    *os &lt;&lt; &quot;never matches&quot;;\n  }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template &lt;typename Pointer&gt;\n  bool MatchAndExplain(const Pointer&amp; p,\n                       MatchResultListener* /* listener */) const {\n    return p == nullptr;\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;is NULL&quot;; }\n  void DescribeNegationTo(::std::ostream* os) const { *os &lt;&lt; &quot;isn&#x27;t NULL&quot;; }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template &lt;typename Pointer&gt;\n  bool MatchAndExplain(const Pointer&amp; p,\n                       MatchResultListener* /* listener */) const {\n    return p != nullptr;\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;isn&#x27;t NULL&quot;; }\n  void DescribeNegationTo(::std::ostream* os) const { *os &lt;&lt; &quot;is NULL&quot;; }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// &#x27;variable&#x27;.  This matcher is polymorphic as it can match any\n// super type of the type of &#x27;variable&#x27;.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher&lt;int&gt; m1 = Ref(n);   // This won&#x27;t compile.\n//   Matcher&lt;int&amp;&gt; m2 = Ref(n);  // This will compile.\ntemplate &lt;typename T&gt;\nclass RefMatcher;\n\ntemplate &lt;typename T&gt;\nclass RefMatcher&lt;T&amp;&gt; {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T&amp; instead of const T&amp;, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T&amp; x) : object_(x) {}  // NOLINT\n\n  template &lt;typename Super&gt;\n  operator Matcher&lt;Super&amp;&gt;() const {\n    // By passing object_ (type T&amp;) to Impl(), which expects a Super&amp;,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl&lt;Super&gt;(object_));\n  }\n\n private:\n  template &lt;typename Super&gt;\n  class Impl : public MatcherInterface&lt;Super&amp;&gt; {\n   public:\n    explicit Impl(Super&amp; x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super&amp; (as opposed to const Super&amp;)\n    // in order to match the interface MatcherInterface&lt;Super&amp;&gt;.\n    bool MatchAndExplain(Super&amp; x,\n                         MatchResultListener* listener) const override {\n      *listener &lt;&lt; &quot;which is located @&quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;x);\n      return &amp;x == &amp;object_;\n    }\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;references the variable &quot;;\n      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;does not reference the variable &quot;;\n      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);\n    }\n\n   private:\n    const Super&amp; object_;\n  };\n\n  T&amp; object_;\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate &lt;typename StringType&gt;\nbool CaseInsensitiveStringEquals(const StringType&amp; s1, const StringType&amp; s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate &lt;typename StringType&gt;\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(StringType str, bool expect_eq, bool case_sensitive)\n      : string_(std::move(str)),\n        expect_eq_(expect_eq),\n        case_sensitive_(case_sensitive) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    // This should fail to compile if StringView is used with wide\n    // strings.\n    const StringType&amp; str = std::string(s);\n    return MatchAndExplain(str, listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == nullptr) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&amp;,\n  // because StringView has some interfering non-explicit constructors.\n  template &lt;typename MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    const StringType s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_\n                                    : CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os &lt;&lt; (expect_eq ? &quot;is &quot; : &quot;isn&#x27;t &quot;);\n    *os &lt;&lt; &quot;equal to &quot;;\n    if (!case_sensitive_) {\n      *os &lt;&lt; &quot;(ignoring case) &quot;;\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher&lt;T&gt; as long as T can be converted to a\n// string.\ntemplate &lt;typename StringType&gt;\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType&amp; substring)\n      : substring_(substring) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    // This should fail to compile if StringView is used with wide\n    // strings.\n    const StringType&amp; str = std::string(s);\n    return MatchAndExplain(str, listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&amp;,\n  // because StringView has some interfering non-explicit constructors.\n  template &lt;typename MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    return StringType(s).find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;has substring &quot;;\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;has no substring &quot;;\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher&lt;T&gt; as long as T can be converted to a\n// string.\ntemplate &lt;typename StringType&gt;\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType&amp; prefix) : prefix_(prefix) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    // This should fail to compile if StringView is used with wide\n    // strings.\n    const StringType&amp; str = std::string(s);\n    return MatchAndExplain(str, listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&amp;,\n  // because StringView has some interfering non-explicit constructors.\n  template &lt;typename MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    const StringType&amp; s2(s);\n    return s2.length() &gt;= prefix_.length() &amp;&amp;\n           s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;starts with &quot;;\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;doesn&#x27;t start with &quot;;\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher&lt;T&gt; as long as T can be converted to a\n// string.\ntemplate &lt;typename StringType&gt;\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType&amp; suffix) : suffix_(suffix) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    // This should fail to compile if StringView is used with wide\n    // strings.\n    const StringType&amp; str = std::string(s);\n    return MatchAndExplain(str, listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&amp;,\n  // because StringView has some interfering non-explicit constructors.\n  template &lt;typename MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    const StringType&amp; s2(s);\n    return s2.length() &gt;= suffix_.length() &amp;&amp;\n           s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;ends with &quot;;\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;doesn&#x27;t end with &quot;;\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n};\n\n// Implements the polymorphic WhenBase64Unescaped(matcher) matcher, which can be\n// used as a Matcher&lt;T&gt; as long as T can be converted to a string.\nclass WhenBase64UnescapedMatcher {\n public:\n  using is_gtest_matcher = void;\n\n  explicit WhenBase64UnescapedMatcher(\n      const Matcher&lt;const std::string&amp;&gt;&amp; internal_matcher)\n      : internal_matcher_(internal_matcher) {}\n\n  // Matches anything that can convert to std::string.\n  template &lt;typename MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* listener) const {\n    const std::string s2(s);  // NOLINT (needed for working with string_view).\n    std::string unescaped;\n    if (!internal::Base64Unescape(s2, &amp;unescaped)) {\n      if (listener != nullptr) {\n        *listener &lt;&lt; &quot;is not a valid base64 escaped string&quot;;\n      }\n      return false;\n    }\n    return MatchPrintAndExplain(unescaped, internal_matcher_, listener);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;matches after Base64Unescape &quot;;\n    internal_matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;does not match after Base64Unescape &quot;;\n    internal_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher&lt;const std::string&amp;&gt; internal_matcher_;\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, &lt;=, &lt;, etc, operators.  The two fields being\n// compared don&#x27;t have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a std::tuple&lt;int, short&gt;, a std::tuple&lt;const long&amp;, double&gt;,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate &lt;typename D, typename Op&gt;\nclass PairMatchBase {\n public:\n  template &lt;typename T1, typename T2&gt;\n  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {\n    return Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);\n  }\n  template &lt;typename T1, typename T2&gt;\n  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {\n    return MakeMatcher(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);\n  }\n\n private:\n  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT\n    return os &lt;&lt; D::Desc();\n  }\n\n  template &lt;typename Tuple&gt;\n  class Impl : public MatcherInterface&lt;Tuple&gt; {\n   public:\n    bool MatchAndExplain(Tuple args,\n                         MatchResultListener* /* listener */) const override {\n      return Op()(::std::get&lt;0&gt;(args), ::std::get&lt;1&gt;(args));\n    }\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;are &quot; &lt;&lt; GetDesc;\n    }\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;aren&#x27;t &quot; &lt;&lt; GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase&lt;Eq2Matcher, AnyEq&gt; {\n public:\n  static const char* Desc() { return &quot;an equal pair&quot;; }\n};\nclass Ne2Matcher : public PairMatchBase&lt;Ne2Matcher, AnyNe&gt; {\n public:\n  static const char* Desc() { return &quot;an unequal pair&quot;; }\n};\nclass Lt2Matcher : public PairMatchBase&lt;Lt2Matcher, AnyLt&gt; {\n public:\n  static const char* Desc() { return &quot;a pair where the first &lt; the second&quot;; }\n};\nclass Gt2Matcher : public PairMatchBase&lt;Gt2Matcher, AnyGt&gt; {\n public:\n  static const char* Desc() { return &quot;a pair where the first &gt; the second&quot;; }\n};\nclass Le2Matcher : public PairMatchBase&lt;Le2Matcher, AnyLe&gt; {\n public:\n  static const char* Desc() { return &quot;a pair where the first &lt;= the second&quot;; }\n};\nclass Ge2Matcher : public PairMatchBase&lt;Ge2Matcher, AnyGe&gt; {\n public:\n  static const char* Desc() { return &quot;a pair where the first &gt;= the second&quot;; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl&lt;T&gt; class.\ntemplate &lt;typename T&gt;\nclass NotMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {\n public:\n  explicit NotMatcherImpl(const Matcher&lt;T&gt;&amp; matcher) : matcher_(matcher) {}\n\n  bool MatchAndExplain(const T&amp; x,\n                       MatchResultListener* listener) const override {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  void DescribeTo(::std::ostream* os) const override {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher&lt;T&gt; matcher_;\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn&#x27;t\n// match matcher m.\ntemplate &lt;typename InnerMatcher&gt;\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    return Matcher&lt;T&gt;(new NotMatcherImpl&lt;T&gt;(SafeMatcherCast&lt;T&gt;(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl&lt;T&gt; class.\ntemplate &lt;typename T&gt;\nclass AllOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {\n public:\n  explicit AllOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt;&gt; matchers)\n      : matchers_(std::move(matchers)) {}\n\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;(&quot;;\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      if (i != 0) *os &lt;&lt; &quot;) and (&quot;;\n      matchers_[i].DescribeTo(os);\n    }\n    *os &lt;&lt; &quot;)&quot;;\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;(&quot;;\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      if (i != 0) *os &lt;&lt; &quot;) or (&quot;;\n      matchers_[i].DescribeNegationTo(os);\n    }\n    *os &lt;&lt; &quot;)&quot;;\n  }\n\n  bool MatchAndExplain(const T&amp; x,\n                       MatchResultListener* listener) const override {\n    // If either matcher1_ or matcher2_ doesn&#x27;t match x, we only need\n    // to explain why one of them fails.\n    std::string all_match_result;\n\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      StringMatchResultListener slistener;\n      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {\n        if (all_match_result.empty()) {\n          all_match_result = slistener.str();\n        } else {\n          std::string result = slistener.str();\n          if (!result.empty()) {\n            all_match_result += &quot;, and &quot;;\n            all_match_result += result;\n          }\n        }\n      } else {\n        *listener &lt;&lt; slistener.str();\n        return false;\n      }\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    *listener &lt;&lt; all_match_result;\n    return true;\n  }\n\n private:\n  const std::vector&lt;Matcher&lt;T&gt;&gt; matchers_;\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher&lt;T&gt; is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate &lt;template &lt;typename T&gt; class CombiningMatcher, typename... Args&gt;\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&amp;... matchers)  // NOLINT\n      : matchers_(matchers...) {\n    static_assert(sizeof...(Args) &gt; 0, &quot;Must have at least one matcher.&quot;);\n  }\n\n  VariadicMatcher(const VariadicMatcher&amp;) = default;\n  VariadicMatcher&amp; operator=(const VariadicMatcher&amp;) = delete;\n\n  // This template type conversion operator allows an\n  // VariadicMatcher&lt;Matcher1, Matcher2...&gt; object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    std::vector&lt;Matcher&lt;T&gt;&gt; values;\n    CreateVariadicMatcher&lt;T&gt;(&amp;values, std::integral_constant&lt;size_t, 0&gt;());\n    return Matcher&lt;T&gt;(new CombiningMatcher&lt;T&gt;(std::move(values)));\n  }\n\n private:\n  template &lt;typename T, size_t I&gt;\n  void CreateVariadicMatcher(std::vector&lt;Matcher&lt;T&gt;&gt;* values,\n                             std::integral_constant&lt;size_t, I&gt;) const {\n    values-&gt;push_back(SafeMatcherCast&lt;T&gt;(std::get&lt;I&gt;(matchers_)));\n    CreateVariadicMatcher&lt;T&gt;(values, std::integral_constant&lt;size_t, I + 1&gt;());\n  }\n\n  template &lt;typename T&gt;\n  void CreateVariadicMatcher(\n      std::vector&lt;Matcher&lt;T&gt;&gt;*,\n      std::integral_constant&lt;size_t, sizeof...(Args)&gt;) const {}\n\n  std::tuple&lt;Args...&gt; matchers_;\n};\n\ntemplate &lt;typename... Args&gt;\nusing AllOfMatcher = VariadicMatcher&lt;AllOfMatcherImpl, Args...&gt;;\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl&lt;T&gt; class.\ntemplate &lt;typename T&gt;\nclass AnyOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {\n public:\n  explicit AnyOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt;&gt; matchers)\n      : matchers_(std::move(matchers)) {}\n\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;(&quot;;\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      if (i != 0) *os &lt;&lt; &quot;) or (&quot;;\n      matchers_[i].DescribeTo(os);\n    }\n    *os &lt;&lt; &quot;)&quot;;\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;(&quot;;\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      if (i != 0) *os &lt;&lt; &quot;) and (&quot;;\n      matchers_[i].DescribeNegationTo(os);\n    }\n    *os &lt;&lt; &quot;)&quot;;\n  }\n\n  bool MatchAndExplain(const T&amp; x,\n                       MatchResultListener* listener) const override {\n    std::string no_match_result;\n\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    for (size_t i = 0; i &lt; matchers_.size(); ++i) {\n      StringMatchResultListener slistener;\n      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {\n        *listener &lt;&lt; slistener.str();\n        return true;\n      } else {\n        if (no_match_result.empty()) {\n          no_match_result = slistener.str();\n        } else {\n          std::string result = slistener.str();\n          if (!result.empty()) {\n            no_match_result += &quot;, and &quot;;\n            no_match_result += result;\n          }\n        }\n      }\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    *listener &lt;&lt; no_match_result;\n    return false;\n  }\n\n private:\n  const std::vector&lt;Matcher&lt;T&gt;&gt; matchers_;\n};\n\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate &lt;typename... Args&gt;\nusing AnyOfMatcher = VariadicMatcher&lt;AnyOfMatcherImpl, Args...&gt;;\n\n// ConditionalMatcher is the implementation of Conditional(cond, m1, m2)\ntemplate &lt;typename MatcherTrue, typename MatcherFalse&gt;\nclass ConditionalMatcher {\n public:\n  ConditionalMatcher(bool condition, MatcherTrue matcher_true,\n                     MatcherFalse matcher_false)\n      : condition_(condition),\n        matcher_true_(std::move(matcher_true)),\n        matcher_false_(std::move(matcher_false)) {}\n\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {  // NOLINT(runtime/explicit)\n    return condition_ ? SafeMatcherCast&lt;T&gt;(matcher_true_)\n                      : SafeMatcherCast&lt;T&gt;(matcher_false_);\n  }\n\n private:\n  bool condition_;\n  MatcherTrue matcher_true_;\n  MatcherFalse matcher_false_;\n};\n\n// Wrapper for implementation of Any/AllOfArray().\ntemplate &lt;template &lt;class&gt; class MatcherImpl, typename T&gt;\nclass SomeOfArrayMatcher {\n public:\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template &lt;typename Iter&gt;\n  SomeOfArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template &lt;typename U&gt;\n  operator Matcher&lt;U&gt;() const {  // NOLINT\n    using RawU = typename std::decay&lt;U&gt;::type;\n    std::vector&lt;Matcher&lt;RawU&gt;&gt; matchers;\n    for (const auto&amp; matcher : matchers_) {\n      matchers.push_back(MatcherCast&lt;RawU&gt;(matcher));\n    }\n    return Matcher&lt;U&gt;(new MatcherImpl&lt;RawU&gt;(std::move(matchers)));\n  }\n\n private:\n  const ::std::vector&lt;T&gt; matchers_;\n};\n\ntemplate &lt;typename T&gt;\nusing AllOfArrayMatcher = SomeOfArrayMatcher&lt;AllOfMatcherImpl, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing AnyOfArrayMatcher = SomeOfArrayMatcher&lt;AnyOfMatcherImpl, T&gt;;\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate &lt;typename Predicate&gt;\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate &#x27;pred&#x27;.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template &lt;typename T&gt;\n  bool MatchAndExplain(T&amp; x,  // NOLINT\n                       MatchResultListener* listener) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write &#x27;return !!predicate_(x);&#x27; as that doesn&#x27;t work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x)) return true;\n    *listener &lt;&lt; &quot;didn&#x27;t satisfy the given predicate&quot;;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;satisfies the given predicate&quot;;\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;doesn&#x27;t satisfy the given predicate&quot;;\n  }\n\n private:\n  Predicate predicate_;\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate &lt;typename M&gt;\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template &lt;typename T&gt;\n  bool operator()(const T&amp; x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher&lt;T&gt;(matcher_).Matches(x) here, it won&#x27;t\n    // compile when matcher_ has type Matcher&lt;const T&amp;&gt;; if we write\n    // Matcher&lt;const T&amp;&gt;(matcher_).Matches(x) here, it won&#x27;t compile\n    // when matcher_ has type Matcher&lt;T&gt;; if we just write\n    // matcher_.Matches(x), it won&#x27;t compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast&lt;const T&amp;&gt;() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast&lt;const T&amp;&gt;(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate &lt;typename M&gt;\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(std::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test&#x27;s EXPECT_PRED_FORMAT1() macro.\n  template &lt;typename T&gt;\n  AssertionResult operator()(const char* value_text, const T&amp; x) const {\n    // We convert matcher_ to a Matcher&lt;const T&amp;&gt; *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won&#x27;t\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast&lt;const T&amp;&gt;(matcher_) instead of\n    // Matcher&lt;const T&amp;&gt;(matcher_), as the latter won&#x27;t compile when\n    // matcher_ has type Matcher&lt;T&gt; (e.g. An&lt;int&gt;()).\n    // We don&#x27;t write MatcherCast&lt;const T&amp;&gt; either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher&lt;const T&amp;&gt; matcher = SafeMatcherCast&lt;const T&amp;&gt;(matcher_);\n\n    // The expected path here is that the matcher should match (i.e. that most\n    // tests pass) so optimize for this case.\n    if (matcher.Matches(x)) {\n      return AssertionSuccess();\n    }\n\n    ::std::stringstream ss;\n    ss &lt;&lt; &quot;Value of: &quot; &lt;&lt; value_text &lt;&lt; &quot;\\n&quot;\n       &lt;&lt; &quot;Expected: &quot;;\n    matcher.DescribeTo(&amp;ss);\n\n    // Rerun the matcher to &quot;PrintAndExplain&quot; the failure.\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &amp;listener)) {\n      ss &lt;&lt; &quot;\\n  The matcher failed on the initial attempt; but passed when &quot;\n            &quot;rerun to generate the explanation.&quot;;\n    }\n    ss &lt;&lt; &quot;\\n  Actual: &quot; &lt;&lt; listener.str();\n    return AssertionFailure() &lt;&lt; ss.str();\n  }\n\n private:\n  const M matcher_;\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: &#x27;matcher&#x27; is received by-value to force decaying.\ntemplate &lt;typename M&gt;\ninline PredicateFormatterFromMatcher&lt;M&gt; MakePredicateFormatterFromMatcher(\n    M matcher) {\n  return PredicateFormatterFromMatcher&lt;M&gt;(std::move(matcher));\n}\n\n// Implements the polymorphic IsNan() matcher, which matches any floating type\n// value that is Nan.\nclass IsNanMatcher {\n public:\n  template &lt;typename FloatType&gt;\n  bool MatchAndExplain(const FloatType&amp; f,\n                       MatchResultListener* /* listener */) const {\n    return (::std::isnan)(f);\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;is NaN&quot;; }\n  void DescribeNegationTo(::std::ostream* os) const { *os &lt;&lt; &quot;isn&#x27;t NaN&quot;; }\n};\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate &lt;typename FloatType&gt;\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher&#x27;s input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan)\n      : expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {}\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error &gt;= 0)\n        &lt;&lt; &quot;, where max_abs_error is&quot; &lt;&lt; max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher&lt;T&gt;.\n  template &lt;typename T&gt;\n  class Impl : public MatcherInterface&lt;T&gt; {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    bool MatchAndExplain(T value,\n                         MatchResultListener* listener) const override {\n      const FloatingPoint&lt;FloatType&gt; actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() &amp;&amp; expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (::std::fabs(diff) &lt;= max_abs_error_) {\n          return true;\n        }\n\n        if (listener-&gt;IsInterested()) {\n          *listener &lt;&lt; &quot;which is &quot; &lt;&lt; diff &lt;&lt; &quot; from &quot; &lt;&lt; expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    void DescribeTo(::std::ostream* os) const override {\n      // os-&gt;precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision =\n          os-&gt;precision(::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);\n      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os &lt;&lt; &quot;is NaN&quot;;\n        } else {\n          *os &lt;&lt; &quot;never matches&quot;;\n        }\n      } else {\n        *os &lt;&lt; &quot;is approximately &quot; &lt;&lt; expected_;\n        if (HasMaxAbsError()) {\n          *os &lt;&lt; &quot; (absolute error &lt;= &quot; &lt;&lt; max_abs_error_ &lt;&lt; &quot;)&quot;;\n        }\n      }\n      os-&gt;precision(old_precision);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      // As before, get original precision.\n      const ::std::streamsize old_precision =\n          os-&gt;precision(::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);\n      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os &lt;&lt; &quot;isn&#x27;t NaN&quot;;\n        } else {\n          *os &lt;&lt; &quot;is anything&quot;;\n        }\n      } else {\n        *os &lt;&lt; &quot;isn&#x27;t approximately &quot; &lt;&lt; expected_;\n        if (HasMaxAbsError()) {\n          *os &lt;&lt; &quot; (absolute error &gt; &quot; &lt;&lt; max_abs_error_ &lt;&lt; &quot;)&quot;;\n        }\n      }\n      // Restore original precision.\n      os-&gt;precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const { return max_abs_error_ &gt;= 0; }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when &gt;= 0.\n    const FloatType max_abs_error_;\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher&lt;float&gt;, a\n  // Matcher&lt;const float&amp;&gt;, or a Matcher&lt;float&amp;&gt;, but nothing else.\n  operator Matcher&lt;FloatType&gt;() const {\n    return MakeMatcher(\n        new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher&lt;const FloatType&amp;&gt;() const {\n    return MakeMatcher(\n        new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher&lt;FloatType&amp;&gt;() const {\n    return MakeMatcher(\n        new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when &gt;= 0.\n  const FloatType max_abs_error_;\n};\n\n// A 2-tuple (&quot;binary&quot;) wrapper around FloatingEqMatcher:\n// FloatingEq2Matcher() matches (x, y) by matching FloatingEqMatcher(x, false)\n// against y, and FloatingEq2Matcher(e) matches FloatingEqMatcher(x, false, e)\n// against y. The former implements &quot;Eq&quot;, the latter &quot;Near&quot;. At present, there\n// is no version that compares NaNs as equal.\ntemplate &lt;typename FloatType&gt;\nclass FloatingEq2Matcher {\n public:\n  FloatingEq2Matcher() { Init(-1, false); }\n\n  explicit FloatingEq2Matcher(bool nan_eq_nan) { Init(-1, nan_eq_nan); }\n\n  explicit FloatingEq2Matcher(FloatType max_abs_error) {\n    Init(max_abs_error, false);\n  }\n\n  FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) {\n    Init(max_abs_error, nan_eq_nan);\n  }\n\n  template &lt;typename T1, typename T2&gt;\n  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {\n    return MakeMatcher(\n        new Impl&lt;::std::tuple&lt;T1, T2&gt;&gt;(max_abs_error_, nan_eq_nan_));\n  }\n  template &lt;typename T1, typename T2&gt;\n  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {\n    return MakeMatcher(\n        new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_));\n  }\n\n private:\n  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT\n    return os &lt;&lt; &quot;an almost-equal pair&quot;;\n  }\n\n  template &lt;typename Tuple&gt;\n  class Impl : public MatcherInterface&lt;Tuple&gt; {\n   public:\n    Impl(FloatType max_abs_error, bool nan_eq_nan)\n        : max_abs_error_(max_abs_error), nan_eq_nan_(nan_eq_nan) {}\n\n    bool MatchAndExplain(Tuple args,\n                         MatchResultListener* listener) const override {\n      if (max_abs_error_ == -1) {\n        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_);\n        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(\n            ::std::get&lt;1&gt;(args), listener);\n      } else {\n        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_,\n                                        max_abs_error_);\n        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(\n            ::std::get&lt;1&gt;(args), listener);\n      }\n    }\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;are &quot; &lt;&lt; GetDesc;\n    }\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;aren&#x27;t &quot; &lt;&lt; GetDesc;\n    }\n\n   private:\n    FloatType max_abs_error_;\n    const bool nan_eq_nan_;\n  };\n\n  void Init(FloatType max_abs_error_val, bool nan_eq_nan_val) {\n    max_abs_error_ = max_abs_error_val;\n    nan_eq_nan_ = nan_eq_nan_val;\n  }\n  FloatType max_abs_error_;\n  bool nan_eq_nan_;\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate &lt;typename InnerMatcher&gt;\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template &lt;typename Pointer&gt;\n  operator Matcher&lt;Pointer&gt;() const {\n    return Matcher&lt;Pointer&gt;(new Impl&lt;const Pointer&amp;&gt;(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template &lt;typename Pointer&gt;\n  class Impl : public MatcherInterface&lt;Pointer&gt; {\n   public:\n    using Pointee =\n        typename std::pointer_traits&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(\n            Pointer)&gt;::element_type;\n\n    explicit Impl(const InnerMatcher&amp; matcher)\n        : matcher_(MatcherCast&lt;const Pointee&amp;&gt;(matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;points to a value that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;does not point to a value that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    bool MatchAndExplain(Pointer pointer,\n                         MatchResultListener* listener) const override {\n      if (GetRawPointer(pointer) == nullptr) return false;\n\n      *listener &lt;&lt; &quot;which points to &quot;;\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher&lt;const Pointee&amp;&gt; matcher_;\n  };\n\n  const InnerMatcher matcher_;\n};\n\n// Implements the Pointer(m) matcher\n// Implements the Pointer(m) matcher for matching a pointer that matches matcher\n// m.  The pointer can be either raw or smart, and will match `m` against the\n// raw pointer.\ntemplate &lt;typename InnerMatcher&gt;\nclass PointerMatcher {\n public:\n  explicit PointerMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointer(m) to be\n  // used as a matcher for any pointer type whose pointer type is\n  // compatible with the inner matcher, where type PointerType can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointer().\n  template &lt;typename PointerType&gt;\n  operator Matcher&lt;PointerType&gt;() const {  // NOLINT\n    return Matcher&lt;PointerType&gt;(new Impl&lt;const PointerType&amp;&gt;(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template &lt;typename PointerType&gt;\n  class Impl : public MatcherInterface&lt;PointerType&gt; {\n   public:\n    using Pointer =\n        const typename std::pointer_traits&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(\n            PointerType)&gt;::element_type*;\n\n    explicit Impl(const InnerMatcher&amp; matcher)\n        : matcher_(MatcherCast&lt;Pointer&gt;(matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;is a pointer that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;is not a pointer that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    bool MatchAndExplain(PointerType pointer,\n                         MatchResultListener* listener) const override {\n      *listener &lt;&lt; &quot;which is a pointer that &quot;;\n      Pointer p = GetRawPointer(pointer);\n      return MatchPrintAndExplain(p, matcher_, listener);\n    }\n\n   private:\n    Matcher&lt;Pointer&gt; matcher_;\n  };\n\n  const InnerMatcher matcher_;\n};\n\n#if GTEST_HAS_RTTI\n// Implements the WhenDynamicCastTo&lt;T&gt;(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast&lt;T&gt; is applied.\n// The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate &lt;typename To&gt;\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher&lt;To&gt;&amp; matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher&lt;To&gt; matcher_;\n\n  static std::string GetToName() { return GetTypeName&lt;To&gt;(); }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os &lt;&lt; &quot;when dynamic_cast to &quot; &lt;&lt; GetToName() &lt;&lt; &quot;, &quot;;\n  }\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate &lt;typename To&gt;\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase&lt;To&gt; {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&gt;&amp; matcher)\n      : WhenDynamicCastToMatcherBase&lt;To&gt;(matcher) {}\n\n  template &lt;typename From&gt;\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    To to = dynamic_cast&lt;To&gt;(from);\n    return MatchPrintAndExplain(to, this-&gt;matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate &lt;typename To&gt;\nclass WhenDynamicCastToMatcher&lt;To&amp;&gt; : public WhenDynamicCastToMatcherBase&lt;To&amp;&gt; {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&amp;&gt;&amp; matcher)\n      : WhenDynamicCastToMatcherBase&lt;To&amp;&gt;(matcher) {}\n\n  template &lt;typename From&gt;\n  bool MatchAndExplain(From&amp; from, MatchResultListener* listener) const {\n    // We don&#x27;t want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast&lt;To*&gt;(&amp;from);\n    if (to == nullptr) {\n      *listener &lt;&lt; &quot;which cannot be dynamic_cast to &quot; &lt;&lt; this-&gt;GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this-&gt;matcher_, listener);\n  }\n};\n#endif  // GTEST_HAS_RTTI\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate &lt;typename Class, typename FieldType&gt;\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)\n      : field_(field), matcher_(matcher), whose_field_(&quot;whose given field &quot;) {}\n\n  FieldMatcher(const std::string&amp; field_name, FieldType Class::*field,\n               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)\n      : field_(field),\n        matcher_(matcher),\n        whose_field_(&quot;whose field `&quot; + field_name + &quot;` &quot;) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_field_;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_field_;\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template &lt;typename T&gt;\n  bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {\n    // FIXME: The dispatch on std::is_pointer was introduced as a workaround for\n    // a compiler bug, and can now be removed.\n    return MatchAndExplainImpl(\n        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),\n        value, listener);\n  }\n\n private:\n  bool MatchAndExplainImpl(std::false_type /* is_not_pointer */,\n                           const Class&amp; obj,\n                           MatchResultListener* listener) const {\n    *listener &lt;&lt; whose_field_ &lt;&lt; &quot;is &quot;;\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(std::true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == nullptr) return false;\n\n    *listener &lt;&lt; &quot;which points to an object &quot;;\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(std::false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher&lt;const FieldType&amp;&gt; matcher_;\n\n  // Contains either &quot;whose given field &quot; if the name of the field is unknown\n  // or &quot;whose field `name_of_field` &quot; if the name is known.\n  const std::string whose_field_;\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\n//\n// Property is a const-qualified member function of Class returning\n// PropertyType.\ntemplate &lt;typename Class, typename PropertyType, typename Property&gt;\nclass PropertyMatcher {\n public:\n  typedef const PropertyType&amp; RefToConstProperty;\n\n  PropertyMatcher(Property property, const Matcher&lt;RefToConstProperty&gt;&amp; matcher)\n      : property_(property),\n        matcher_(matcher),\n        whose_property_(&quot;whose given property &quot;) {}\n\n  PropertyMatcher(const std::string&amp; property_name, Property property,\n                  const Matcher&lt;RefToConstProperty&gt;&amp; matcher)\n      : property_(property),\n        matcher_(matcher),\n        whose_property_(&quot;whose property `&quot; + property_name + &quot;` &quot;) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_property_;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;is an object &quot; &lt;&lt; whose_property_;\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template &lt;typename T&gt;\n  bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),\n        value, listener);\n  }\n\n private:\n  bool MatchAndExplainImpl(std::false_type /* is_not_pointer */,\n                           const Class&amp; obj,\n                           MatchResultListener* listener) const {\n    *listener &lt;&lt; whose_property_ &lt;&lt; &quot;is &quot;;\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(std::true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == nullptr) return false;\n\n    *listener &lt;&lt; &quot;which points to an object &quot;;\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(std::false_type(), *p, listener);\n  }\n\n  Property property_;\n  const Matcher&lt;RefToConstProperty&gt; matcher_;\n\n  // Contains either &quot;whose given property &quot; if the name of the property is\n  // unknown or &quot;whose property `name_of_property` &quot; if the name is known.\n  const std::string whose_property_;\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\ntemplate &lt;typename Functor&gt;\nstruct CallableTraits {\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n\n  template &lt;typename T&gt;\n  static auto Invoke(Functor f, const T&amp; arg) -&gt; decltype(f(arg)) {\n    return f(arg);\n  }\n};\n\n// Specialization for function pointers.\ntemplate &lt;typename ArgType, typename ResType&gt;\nstruct CallableTraits&lt;ResType (*)(ArgType)&gt; {\n  typedef ResType ResultType;\n  typedef ResType (*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType (*f)(ArgType)) {\n    GTEST_CHECK_(f != nullptr)\n        &lt;&lt; &quot;NULL function pointer is passed into ResultOf().&quot;;\n  }\n  template &lt;typename T&gt;\n  static ResType Invoke(ResType (*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate &lt;typename Callable, typename InnerMatcher&gt;\nclass ResultOfMatcher {\n public:\n  ResultOfMatcher(Callable callable, InnerMatcher matcher)\n      : ResultOfMatcher(/*result_description=*/&quot;&quot;, std::move(callable),\n                        std::move(matcher)) {}\n\n  ResultOfMatcher(const std::string&amp; result_description, Callable callable,\n                  InnerMatcher matcher)\n      : result_description_(result_description),\n        callable_(std::move(callable)),\n        matcher_(std::move(matcher)) {\n    CallableTraits&lt;Callable&gt;::CheckIsValid(callable_);\n  }\n\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    return Matcher&lt;T&gt;(\n        new Impl&lt;const T&amp;&gt;(result_description_, callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits&lt;Callable&gt;::StorageType CallableStorageType;\n\n  template &lt;typename T&gt;\n  class Impl : public MatcherInterface&lt;T&gt; {\n    using ResultType = decltype(CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(\n        std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;()));\n\n   public:\n    template &lt;typename M&gt;\n    Impl(const std::string&amp; result_description,\n         const CallableStorageType&amp; callable, const M&amp; matcher)\n        : result_description_(result_description),\n          callable_(callable),\n          matcher_(MatcherCast&lt;ResultType&gt;(matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      if (result_description_.empty()) {\n        *os &lt;&lt; &quot;is mapped by the given callable to a value that &quot;;\n      } else {\n        *os &lt;&lt; &quot;whose &quot; &lt;&lt; result_description_ &lt;&lt; &quot; &quot;;\n      }\n      matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      if (result_description_.empty()) {\n        *os &lt;&lt; &quot;is mapped by the given callable to a value that &quot;;\n      } else {\n        *os &lt;&lt; &quot;whose &quot; &lt;&lt; result_description_ &lt;&lt; &quot; &quot;;\n      }\n      matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(T obj, MatchResultListener* listener) const override {\n      if (result_description_.empty()) {\n        *listener &lt;&lt; &quot;which is mapped by the given callable to &quot;;\n      } else {\n        *listener &lt;&lt; &quot;whose &quot; &lt;&lt; result_description_ &lt;&lt; &quot; is &quot;;\n      }\n      // Cannot pass the return value directly to MatchPrintAndExplain, which\n      // takes a non-const reference as argument.\n      // Also, specifying template argument explicitly is needed because T could\n      // be a non-const reference (e.g. Matcher&lt;Uncopyable&amp;&gt;).\n      ResultType result =\n          CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    const std::string result_description_;\n    // Functors often define operator() as non-const method even though\n    // they are actually stateless. But we need to use them even when\n    // &#x27;this&#x27; is a const pointer. It&#x27;s the user&#x27;s responsibility not to\n    // use stateful callables with ResultOf(), which doesn&#x27;t guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher&lt;ResultType&gt; matcher_;\n  };  // class Impl\n\n  const std::string result_description_;\n  const CallableStorageType callable_;\n  const InnerMatcher matcher_;\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate &lt;typename SizeMatcher&gt;\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher&amp; size_matcher)\n      : size_matcher_(size_matcher) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(size_matcher_));\n  }\n\n  template &lt;typename Container&gt;\n  class Impl : public MatcherInterface&lt;Container&gt; {\n   public:\n    using SizeType = decltype(std::declval&lt;Container&gt;().size());\n    explicit Impl(const SizeMatcher&amp; size_matcher)\n        : size_matcher_(MatcherCast&lt;SizeType&gt;(size_matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;size &quot;;\n      size_matcher_.DescribeTo(os);\n    }\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;size &quot;;\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(Container container,\n                         MatchResultListener* listener) const override {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &amp;size_listener);\n      *listener &lt;&lt; &quot;whose size &quot; &lt;&lt; size\n                &lt;&lt; (result ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n      PrintIfNotEmpty(size_listener.str(), listener-&gt;stream());\n      return result;\n    }\n\n   private:\n    const Matcher&lt;SizeType&gt; size_matcher_;\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate &lt;typename DistanceMatcher&gt;\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher&amp; distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(distance_matcher_));\n  }\n\n  template &lt;typename Container&gt;\n  class Impl : public MatcherInterface&lt;Container&gt; {\n   public:\n    typedef internal::StlContainerView&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(\n        Container)&gt;\n        ContainerView;\n    typedef typename std::iterator_traits&lt;\n        typename ContainerView::type::const_iterator&gt;::difference_type\n        DistanceType;\n    explicit Impl(const DistanceMatcher&amp; distance_matcher)\n        : distance_matcher_(MatcherCast&lt;DistanceType&gt;(distance_matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;distance between begin() and end() &quot;;\n      distance_matcher_.DescribeTo(os);\n    }\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;distance between begin() and end() &quot;;\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(Container container,\n                         MatchResultListener* listener) const override {\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &amp;distance_listener);\n      *listener &lt;&lt; &quot;whose distance between begin() and end() &quot; &lt;&lt; distance\n                &lt;&lt; (result ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n      PrintIfNotEmpty(distance_listener.str(), listener-&gt;stream());\n      return result;\n    }\n\n   private:\n    const Matcher&lt;DistanceType&gt; distance_matcher_;\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don&#x27;t properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container&#x27;s const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate &lt;typename Container&gt;\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView&lt;Container&gt; View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  static_assert(!std::is_const&lt;Container&gt;::value,\n                &quot;Container type must not be const&quot;);\n  static_assert(!std::is_reference&lt;Container&gt;::value,\n                &quot;Container type must not be a reference&quot;);\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container&amp; expected)\n      : expected_(View::Copy(expected)) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;equals &quot;;\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;does not equal &quot;;\n    UniversalPrint(expected_, os);\n  }\n\n  template &lt;typename LhsContainer&gt;\n  bool MatchAndExplain(const LhsContainer&amp; lhs,\n                       MatchResultListener* listener) const {\n    typedef internal::StlContainerView&lt;\n        typename std::remove_const&lt;LhsContainer&gt;::type&gt;\n        LhsView;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_) return true;\n\n    ::std::ostream* const os = listener-&gt;stream();\n    if (os != nullptr) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (auto it = lhs_stl_container.begin(); it != lhs_stl_container.end();\n           ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os &lt;&lt; &quot;, &quot;;\n          } else {\n            *os &lt;&lt; &quot;which has these unexpected elements: &quot;;\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (auto it = expected_.begin(); it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(lhs_stl_container.begin(),\n                                     lhs_stl_container.end(),\n                                     *it) == lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os &lt;&lt; &quot;, &quot;;\n          } else {\n            *os &lt;&lt; (printed_header ? &quot;,\\nand&quot; : &quot;which&quot;)\n                &lt;&lt; &quot; doesn&#x27;t have these expected elements: &quot;;\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n};\n\n// A comparator functor that uses the &lt; operator to compare two values.\nstruct LessComparator {\n  template &lt;typename T, typename U&gt;\n  bool operator()(const T&amp; lhs, const U&amp; rhs) const {\n    return lhs &lt; rhs;\n  }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate &lt;typename Comparator, typename ContainerMatcher&gt;\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator&amp; comparator,\n                      const ContainerMatcher&amp; matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template &lt;typename LhsContainer&gt;\n  operator Matcher&lt;LhsContainer&gt;() const {\n    return MakeMatcher(new Impl&lt;LhsContainer&gt;(comparator_, matcher_));\n  }\n\n  template &lt;typename LhsContainer&gt;\n  class Impl : public MatcherInterface&lt;LhsContainer&gt; {\n   public:\n    typedef internal::StlContainerView&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(\n        LhsContainer)&gt;\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair&lt;const Key, Value&gt; into std::pair&lt;Key, Value&gt;\n    // so that we can match associative containers.\n    typedef\n        typename RemoveConstFromKey&lt;typename LhsStlContainer::value_type&gt;::type\n            LhsValue;\n\n    Impl(const Comparator&amp; comparator, const ContainerMatcher&amp; matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;(when sorted) &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;(when sorted) &quot;;\n      matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(LhsContainer lhs,\n                         MatchResultListener* listener) const override {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector&lt;LhsValue&gt; sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(sorted_container.begin(), sorted_container.end(),\n                  comparator_);\n\n      if (!listener-&gt;IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener &lt;&lt; &quot;which is &quot;;\n      UniversalPrint(sorted_container, listener-&gt;stream());\n      *listener &lt;&lt; &quot; when sorted&quot;;\n\n      StringMatchResultListener inner_listener;\n      const bool match =\n          matcher_.MatchAndExplain(sorted_container, &amp;inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher&lt;const ::std::vector&lt;LhsValue&gt;&amp;&gt; matcher_;\n\n    Impl(const Impl&amp;) = delete;\n    Impl&amp; operator=(const Impl&amp;) = delete;\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher&lt;std::tuple&lt;const T1&amp;, const\n// T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate &lt;typename TupleMatcher, typename RhsContainer&gt;\nclass PointwiseMatcher {\n  static_assert(\n      !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;::value,\n      &quot;use UnorderedPointwise with hash tables&quot;);\n\n public:\n  typedef internal::StlContainerView&lt;RhsContainer&gt; RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  static_assert(!std::is_const&lt;RhsContainer&gt;::value,\n                &quot;RhsContainer type must not be const&quot;);\n  static_assert(!std::is_reference&lt;RhsContainer&gt;::value,\n                &quot;RhsContainer type must not be a reference&quot;);\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher&amp; tuple_matcher, const RhsContainer&amp; rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {}\n\n  template &lt;typename LhsContainer&gt;\n  operator Matcher&lt;LhsContainer&gt;() const {\n    static_assert(\n        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt;::value,\n        &quot;use UnorderedPointwise with hash tables&quot;);\n\n    return Matcher&lt;LhsContainer&gt;(\n        new Impl&lt;const LhsContainer&amp;&gt;(tuple_matcher_, rhs_));\n  }\n\n  template &lt;typename LhsContainer&gt;\n  class Impl : public MatcherInterface&lt;LhsContainer&gt; {\n   public:\n    typedef internal::StlContainerView&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(\n        LhsContainer)&gt;\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::std::tuple&lt;const LhsValue&amp;, const RhsValue&amp;&gt; InnerMatcherArg;\n\n    Impl(const TupleMatcher&amp; tuple_matcher, const RhsStlContainer&amp; rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast&lt;InnerMatcherArg&gt;(tuple_matcher)),\n          rhs_(rhs) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;contains &quot; &lt;&lt; rhs_.size()\n          &lt;&lt; &quot; values, where each value and its corresponding value in &quot;;\n      UniversalPrinter&lt;RhsStlContainer&gt;::Print(rhs_, os);\n      *os &lt;&lt; &quot; &quot;;\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;doesn&#x27;t contain exactly &quot; &lt;&lt; rhs_.size()\n          &lt;&lt; &quot; values, or contains a value x at some index i&quot;\n          &lt;&lt; &quot; where x and the i-th value of &quot;;\n      UniversalPrint(rhs_, os);\n      *os &lt;&lt; &quot; &quot;;\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(LhsContainer lhs,\n                         MatchResultListener* listener) const override {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener &lt;&lt; &quot;which contains &quot; &lt;&lt; actual_size &lt;&lt; &quot; values&quot;;\n        return false;\n      }\n\n      auto left = lhs_stl_container.begin();\n      auto right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        if (listener-&gt;IsInterested()) {\n          StringMatchResultListener inner_listener;\n          // Create InnerMatcherArg as a temporarily object to avoid it outlives\n          // *left and *right. Dereference or the conversion to `const T&amp;` may\n          // return temp objects, e.g. for vector&lt;bool&gt;.\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),\n                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right)),\n                  &amp;inner_listener)) {\n            *listener &lt;&lt; &quot;where the value pair (&quot;;\n            UniversalPrint(*left, listener-&gt;stream());\n            *listener &lt;&lt; &quot;, &quot;;\n            UniversalPrint(*right, listener-&gt;stream());\n            *listener &lt;&lt; &quot;) at index #&quot; &lt;&lt; i &lt;&lt; &quot; don&#x27;t match&quot;;\n            PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(\n                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),\n                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right))))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher&lt;InnerMatcherArg&gt; mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate &lt;typename Container&gt;\nclass QuantifierMatcherImpl : public MatcherInterface&lt;Container&gt; {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView&lt;RawContainer&gt; View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template &lt;typename InnerMatcher&gt;\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n            testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match, Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (auto it = stl_container.begin(); it != stl_container.end();\n         ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; i\n                  &lt;&lt; (matches ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n        PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n  bool MatchAndExplainImpl(const Matcher&lt;size_t&gt;&amp; count_matcher,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    std::vector&lt;size_t&gt; match_elements;\n    for (auto it = stl_container.begin(); it != stl_container.end();\n         ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);\n      if (matches) {\n        match_elements.push_back(i);\n      }\n    }\n    if (listener-&gt;IsInterested()) {\n      if (match_elements.empty()) {\n        *listener &lt;&lt; &quot;has no element that matches&quot;;\n      } else if (match_elements.size() == 1) {\n        *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; match_elements[0] &lt;&lt; &quot; matches&quot;;\n      } else {\n        *listener &lt;&lt; &quot;whose elements (&quot;;\n        std::string sep = &quot;&quot;;\n        for (size_t e : match_elements) {\n          *listener &lt;&lt; sep &lt;&lt; e;\n          sep = &quot;, &quot;;\n        }\n        *listener &lt;&lt; &quot;) match&quot;;\n      }\n    }\n    StringMatchResultListener count_listener;\n    if (count_matcher.MatchAndExplain(match_elements.size(), &amp;count_listener)) {\n      *listener &lt;&lt; &quot; and whose match quantity of &quot; &lt;&lt; match_elements.size()\n                &lt;&lt; &quot; matches&quot;;\n      PrintIfNotEmpty(count_listener.str(), listener-&gt;stream());\n      return true;\n    } else {\n      if (match_elements.empty()) {\n        *listener &lt;&lt; &quot; and&quot;;\n      } else {\n        *listener &lt;&lt; &quot; but&quot;;\n      }\n      *listener &lt;&lt; &quot; whose match quantity of &quot; &lt;&lt; match_elements.size()\n                &lt;&lt; &quot; does not match&quot;;\n      PrintIfNotEmpty(count_listener.str(), listener-&gt;stream());\n      return false;\n    }\n  }\n\n protected:\n  const Matcher&lt;const Element&amp;&gt; inner_matcher_;\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate &lt;typename Container&gt;\nclass ContainsMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {\n public:\n  template &lt;typename InnerMatcher&gt;\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;contains at least one element that &quot;;\n    this-&gt;inner_matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;doesn&#x27;t contain any element that &quot;;\n    this-&gt;inner_matcher_.DescribeTo(os);\n  }\n\n  bool MatchAndExplain(Container container,\n                       MatchResultListener* listener) const override {\n    return this-&gt;MatchAndExplainImpl(false, container, listener);\n  }\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate &lt;typename Container&gt;\nclass EachMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {\n public:\n  template &lt;typename InnerMatcher&gt;\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;only contains elements that &quot;;\n    this-&gt;inner_matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;contains some element that &quot;;\n    this-&gt;inner_matcher_.DescribeNegationTo(os);\n  }\n\n  bool MatchAndExplain(Container container,\n                       MatchResultListener* listener) const override {\n    return this-&gt;MatchAndExplainImpl(true, container, listener);\n  }\n};\n\n// Implements Contains(element_matcher).Times(n) for the given argument type\n// Container.\ntemplate &lt;typename Container&gt;\nclass ContainsTimesMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {\n public:\n  template &lt;typename InnerMatcher&gt;\n  explicit ContainsTimesMatcherImpl(InnerMatcher inner_matcher,\n                                    Matcher&lt;size_t&gt; count_matcher)\n      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher),\n        count_matcher_(std::move(count_matcher)) {}\n\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;quantity of elements that match &quot;;\n    this-&gt;inner_matcher_.DescribeTo(os);\n    *os &lt;&lt; &quot; &quot;;\n    count_matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;quantity of elements that match &quot;;\n    this-&gt;inner_matcher_.DescribeTo(os);\n    *os &lt;&lt; &quot; &quot;;\n    count_matcher_.DescribeNegationTo(os);\n  }\n\n  bool MatchAndExplain(Container container,\n                       MatchResultListener* listener) const override {\n    return this-&gt;MatchAndExplainImpl(count_matcher_, container, listener);\n  }\n\n private:\n  const Matcher&lt;size_t&gt; count_matcher_;\n};\n\n// Implements polymorphic Contains(element_matcher).Times(n).\ntemplate &lt;typename M&gt;\nclass ContainsTimesMatcher {\n public:\n  explicit ContainsTimesMatcher(M m, Matcher&lt;size_t&gt; count_matcher)\n      : inner_matcher_(m), count_matcher_(std::move(count_matcher)) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {  // NOLINT\n    return Matcher&lt;Container&gt;(new ContainsTimesMatcherImpl&lt;const Container&amp;&gt;(\n        inner_matcher_, count_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n  const Matcher&lt;size_t&gt; count_matcher_;\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate &lt;typename M&gt;\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {  // NOLINT\n    return Matcher&lt;Container&gt;(\n        new ContainsMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));\n  }\n\n  ContainsTimesMatcher&lt;M&gt; Times(Matcher&lt;size_t&gt; count_matcher) const {\n    return ContainsTimesMatcher&lt;M&gt;(inner_matcher_, std::move(count_matcher));\n  }\n\n private:\n  const M inner_matcher_;\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate &lt;typename M&gt;\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {  // NOLINT\n    return Matcher&lt;Container&gt;(\n        new EachMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n};\n\nstruct Rank1 {};\nstruct Rank0 : Rank1 {};\n\nnamespace pair_getters {\nusing std::get;\ntemplate &lt;typename T&gt;\nauto First(T&amp; x, Rank1) -&gt; decltype(get&lt;0&gt;(x)) {  // NOLINT\n  return get&lt;0&gt;(x);\n}\ntemplate &lt;typename T&gt;\nauto First(T&amp; x, Rank0) -&gt; decltype((x.first)) {  // NOLINT\n  return x.first;\n}\n\ntemplate &lt;typename T&gt;\nauto Second(T&amp; x, Rank1) -&gt; decltype(get&lt;1&gt;(x)) {  // NOLINT\n  return get&lt;1&gt;(x);\n}\ntemplate &lt;typename T&gt;\nauto Second(T&amp; x, Rank0) -&gt; decltype((x.second)) {  // NOLINT\n  return x.second;\n}\n}  // namespace pair_getters\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose &#x27;first&#x27; field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is &gt;= 5.\ntemplate &lt;typename PairType&gt;\nclass KeyMatcherImpl : public MatcherInterface&lt;PairType&gt; {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template &lt;typename InnerMatcher&gt;\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n            testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)) {}\n\n  // Returns true if and only if &#x27;key_value.first&#x27; (the key) matches the inner\n  // matcher.\n  bool MatchAndExplain(PairType key_value,\n                       MatchResultListener* listener) const override {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(\n        pair_getters::First(key_value, Rank0()), &amp;inner_listener);\n    const std::string explanation = inner_listener.str();\n    if (explanation != &quot;&quot;) {\n      *listener &lt;&lt; &quot;whose first field is a value &quot; &lt;&lt; explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;has a key that &quot;;\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;doesn&#x27;t have a key that &quot;;\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher&lt;const KeyType&amp;&gt; inner_matcher_;\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate &lt;typename M&gt;\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template &lt;typename PairType&gt;\n  operator Matcher&lt;PairType&gt;() const {\n    return Matcher&lt;PairType&gt;(\n        new KeyMatcherImpl&lt;const PairType&amp;&gt;(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n};\n\n// Implements polymorphic Address(matcher_for_address).\ntemplate &lt;typename InnerMatcher&gt;\nclass AddressMatcher {\n public:\n  explicit AddressMatcher(InnerMatcher m) : matcher_(m) {}\n\n  template &lt;typename Type&gt;\n  operator Matcher&lt;Type&gt;() const {  // NOLINT\n    return Matcher&lt;Type&gt;(new Impl&lt;const Type&amp;&gt;(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular object type.\n  template &lt;typename Type&gt;\n  class Impl : public MatcherInterface&lt;Type&gt; {\n   public:\n    using Address = const GTEST_REMOVE_REFERENCE_AND_CONST_(Type) *;\n    explicit Impl(const InnerMatcher&amp; matcher)\n        : matcher_(MatcherCast&lt;Address&gt;(matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;has address that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;does not have address that &quot;;\n      matcher_.DescribeTo(os);\n    }\n\n    bool MatchAndExplain(Type object,\n                         MatchResultListener* listener) const override {\n      *listener &lt;&lt; &quot;which has address &quot;;\n      Address address = std::addressof(object);\n      return MatchPrintAndExplain(address, matcher_, listener);\n    }\n\n   private:\n    const Matcher&lt;Address&gt; matcher_;\n  };\n  const InnerMatcher matcher_;\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate &lt;typename PairType&gt;\nclass PairMatcherImpl : public MatcherInterface&lt;PairType&gt; {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template &lt;typename FirstMatcher, typename SecondMatcher&gt;\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast&lt;const FirstType&amp;&gt;(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)) {}\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;has a first field that &quot;;\n    first_matcher_.DescribeTo(os);\n    *os &lt;&lt; &quot;, and has a second field that &quot;;\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;has a first field that &quot;;\n    first_matcher_.DescribeNegationTo(os);\n    *os &lt;&lt; &quot;, or has a second field that &quot;;\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true if and only if &#x27;a_pair.first&#x27; matches first_matcher and\n  // &#x27;a_pair.second&#x27; matches second_matcher.\n  bool MatchAndExplain(PairType a_pair,\n                       MatchResultListener* listener) const override {\n    if (!listener-&gt;IsInterested()) {\n      // If the listener is not interested, we don&#x27;t need to construct the\n      // explanation.\n      return first_matcher_.Matches(pair_getters::First(a_pair, Rank0())) &amp;&amp;\n             second_matcher_.Matches(pair_getters::Second(a_pair, Rank0()));\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(pair_getters::First(a_pair, Rank0()),\n                                        &amp;first_inner_listener)) {\n      *listener &lt;&lt; &quot;whose first field does not match&quot;;\n      PrintIfNotEmpty(first_inner_listener.str(), listener-&gt;stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(pair_getters::Second(a_pair, Rank0()),\n                                         &amp;second_inner_listener)) {\n      *listener &lt;&lt; &quot;whose second field does not match&quot;;\n      PrintIfNotEmpty(second_inner_listener.str(), listener-&gt;stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const std::string&amp; first_explanation,\n                      const std::string&amp; second_explanation,\n                      MatchResultListener* listener) const {\n    *listener &lt;&lt; &quot;whose both fields match&quot;;\n    if (first_explanation != &quot;&quot;) {\n      *listener &lt;&lt; &quot;, where the first field is a value &quot; &lt;&lt; first_explanation;\n    }\n    if (second_explanation != &quot;&quot;) {\n      *listener &lt;&lt; &quot;, &quot;;\n      if (first_explanation != &quot;&quot;) {\n        *listener &lt;&lt; &quot;and &quot;;\n      } else {\n        *listener &lt;&lt; &quot;where &quot;;\n      }\n      *listener &lt;&lt; &quot;the second field is a value &quot; &lt;&lt; second_explanation;\n    }\n  }\n\n  const Matcher&lt;const FirstType&amp;&gt; first_matcher_;\n  const Matcher&lt;const SecondType&amp;&gt; second_matcher_;\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate &lt;typename FirstMatcher, typename SecondMatcher&gt;\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template &lt;typename PairType&gt;\n  operator Matcher&lt;PairType&gt;() const {\n    return Matcher&lt;PairType&gt;(\n        new PairMatcherImpl&lt;const PairType&amp;&gt;(first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n};\n\ntemplate &lt;typename T, size_t... I&gt;\nauto UnpackStructImpl(const T&amp; t, IndexSequence&lt;I...&gt;, int)\n    -&gt; decltype(std::tie(get&lt;I&gt;(t)...)) {\n  static_assert(std::tuple_size&lt;T&gt;::value == sizeof...(I),\n                &quot;Number of arguments doesn&#x27;t match the number of fields.&quot;);\n  return std::tie(get&lt;I&gt;(t)...);\n}\n\n#if defined(__cpp_structured_bindings) &amp;&amp; __cpp_structured_bindings &gt;= 201606\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;1&gt;, char) {\n  const auto&amp; [a] = t;\n  return std::tie(a);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;2&gt;, char) {\n  const auto&amp; [a, b] = t;\n  return std::tie(a, b);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;3&gt;, char) {\n  const auto&amp; [a, b, c] = t;\n  return std::tie(a, b, c);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;4&gt;, char) {\n  const auto&amp; [a, b, c, d] = t;\n  return std::tie(a, b, c, d);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;5&gt;, char) {\n  const auto&amp; [a, b, c, d, e] = t;\n  return std::tie(a, b, c, d, e);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;6&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f] = t;\n  return std::tie(a, b, c, d, e, f);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;7&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g] = t;\n  return std::tie(a, b, c, d, e, f, g);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;8&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h] = t;\n  return std::tie(a, b, c, d, e, f, g, h);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;9&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;10&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;11&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;12&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;13&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;14&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;15&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\ntemplate &lt;typename T&gt;\nauto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;16&gt;, char) {\n  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p] = t;\n  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n}\n#endif  // defined(__cpp_structured_bindings)\n\ntemplate &lt;size_t I, typename T&gt;\nauto UnpackStruct(const T&amp; t)\n    -&gt; decltype((UnpackStructImpl)(t, MakeIndexSequence&lt;I&gt;{}, 0)) {\n  return (UnpackStructImpl)(t, MakeIndexSequence&lt;I&gt;{}, 0);\n}\n\n// Helper function to do comma folding in C++11.\n// The array ensures left-to-right order of evaluation.\n// Usage: VariadicExpand({expr...});\ntemplate &lt;typename T, size_t N&gt;\nvoid VariadicExpand(const T (&amp;)[N]) {}\n\ntemplate &lt;typename Struct, typename StructSize&gt;\nclass FieldsAreMatcherImpl;\n\ntemplate &lt;typename Struct, size_t... I&gt;\nclass FieldsAreMatcherImpl&lt;Struct, IndexSequence&lt;I...&gt;&gt;\n    : public MatcherInterface&lt;Struct&gt; {\n  using UnpackedType =\n      decltype(UnpackStruct&lt;sizeof...(I)&gt;(std::declval&lt;const Struct&amp;&gt;()));\n  using MatchersType = std::tuple&lt;\n      Matcher&lt;const typename std::tuple_element&lt;I, UnpackedType&gt;::type&amp;&gt;...&gt;;\n\n public:\n  template &lt;typename Inner&gt;\n  explicit FieldsAreMatcherImpl(const Inner&amp; matchers)\n      : matchers_(testing::SafeMatcherCast&lt;\n                  const typename std::tuple_element&lt;I, UnpackedType&gt;::type&amp;&gt;(\n            std::get&lt;I&gt;(matchers))...) {}\n\n  void DescribeTo(::std::ostream* os) const override {\n    const char* separator = &quot;&quot;;\n    VariadicExpand(\n        {(*os &lt;&lt; separator &lt;&lt; &quot;has field #&quot; &lt;&lt; I &lt;&lt; &quot; that &quot;,\n          std::get&lt;I&gt;(matchers_).DescribeTo(os), separator = &quot;, and &quot;)...});\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    const char* separator = &quot;&quot;;\n    VariadicExpand({(*os &lt;&lt; separator &lt;&lt; &quot;has field #&quot; &lt;&lt; I &lt;&lt; &quot; that &quot;,\n                     std::get&lt;I&gt;(matchers_).DescribeNegationTo(os),\n                     separator = &quot;, or &quot;)...});\n  }\n\n  bool MatchAndExplain(Struct t, MatchResultListener* listener) const override {\n    return MatchInternal((UnpackStruct&lt;sizeof...(I)&gt;)(t), listener);\n  }\n\n private:\n  bool MatchInternal(UnpackedType tuple, MatchResultListener* listener) const {\n    if (!listener-&gt;IsInterested()) {\n      // If the listener is not interested, we don&#x27;t need to construct the\n      // explanation.\n      bool good = true;\n      VariadicExpand({good = good &amp;&amp; std::get&lt;I&gt;(matchers_).Matches(\n                                         std::get&lt;I&gt;(tuple))...});\n      return good;\n    }\n\n    size_t failed_pos = ~size_t{};\n\n    std::vector&lt;StringMatchResultListener&gt; inner_listener(sizeof...(I));\n\n    VariadicExpand(\n        {failed_pos == ~size_t{} &amp;&amp; !std::get&lt;I&gt;(matchers_).MatchAndExplain(\n                                        std::get&lt;I&gt;(tuple), &amp;inner_listener[I])\n             ? failed_pos = I\n             : 0 ...});\n    if (failed_pos != ~size_t{}) {\n      *listener &lt;&lt; &quot;whose field #&quot; &lt;&lt; failed_pos &lt;&lt; &quot; does not match&quot;;\n      PrintIfNotEmpty(inner_listener[failed_pos].str(), listener-&gt;stream());\n      return false;\n    }\n\n    *listener &lt;&lt; &quot;whose all elements match&quot;;\n    const char* separator = &quot;, where&quot;;\n    for (size_t index = 0; index &lt; sizeof...(I); ++index) {\n      const std::string str = inner_listener[index].str();\n      if (!str.empty()) {\n        *listener &lt;&lt; separator &lt;&lt; &quot; field #&quot; &lt;&lt; index &lt;&lt; &quot; is a value &quot; &lt;&lt; str;\n        separator = &quot;, and&quot;;\n      }\n    }\n\n    return true;\n  }\n\n  MatchersType matchers_;\n};\n\ntemplate &lt;typename... Inner&gt;\nclass FieldsAreMatcher {\n public:\n  explicit FieldsAreMatcher(Inner... inner) : matchers_(std::move(inner)...) {}\n\n  template &lt;typename Struct&gt;\n  operator Matcher&lt;Struct&gt;() const {  // NOLINT\n    return Matcher&lt;Struct&gt;(\n        new FieldsAreMatcherImpl&lt;const Struct&amp;, IndexSequenceFor&lt;Inner...&gt;&gt;(\n            matchers_));\n  }\n\n private:\n  std::tuple&lt;Inner...&gt; matchers_;\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate &lt;typename Container&gt;\nclass ElementsAreMatcherImpl : public MatcherInterface&lt;Container&gt; {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView&lt;RawContainer&gt; View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template &lt;typename InputIter&gt;\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    if (count() == 0) {\n      *os &lt;&lt; &quot;is empty&quot;;\n    } else if (count() == 1) {\n      *os &lt;&lt; &quot;has 1 element that &quot;;\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os &lt;&lt; &quot;has &quot; &lt;&lt; Elements(count()) &lt;&lt; &quot; where\\n&quot;;\n      for (size_t i = 0; i != count(); ++i) {\n        *os &lt;&lt; &quot;element #&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;\n        matchers_[i].DescribeTo(os);\n        if (i + 1 &lt; count()) {\n          *os &lt;&lt; &quot;,\\n&quot;;\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  void DescribeNegationTo(::std::ostream* os) const override {\n    if (count() == 0) {\n      *os &lt;&lt; &quot;isn&#x27;t empty&quot;;\n      return;\n    }\n\n    *os &lt;&lt; &quot;doesn&#x27;t have &quot; &lt;&lt; Elements(count()) &lt;&lt; &quot;, or\\n&quot;;\n    for (size_t i = 0; i != count(); ++i) {\n      *os &lt;&lt; &quot;element #&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 &lt; count()) {\n        *os &lt;&lt; &quot;, or\\n&quot;;\n      }\n    }\n  }\n\n  bool MatchAndExplain(Container container,\n                       MatchResultListener* listener) const override {\n    // To work with stream-like &quot;containers&quot;, we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener-&gt;IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector&lt;std::string&gt; explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    auto it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() &amp;&amp; exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &amp;s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, &#x27;exam_pos&#x27; is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like &quot;containers&quot;\n    // that don&#x27;t define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn&#x27;t match.  If the container is empty,\n      // there&#x27;s no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested &amp;&amp; (actual_count != 0)) {\n        *listener &lt;&lt; &quot;which has &quot; &lt;&lt; Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn&#x27;t match.\n      if (listener_interested) {\n        *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; exam_pos &lt;&lt; &quot; doesn&#x27;t match&quot;;\n        PrintIfNotEmpty(explanations[exam_pos], listener-&gt;stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const std::string&amp; s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener &lt;&lt; &quot;,\\nand &quot;;\n          }\n          *listener &lt;&lt; &quot;whose element #&quot; &lt;&lt; i &lt;&lt; &quot; matches, &quot; &lt;&lt; s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() &lt;&lt; count &lt;&lt; (count == 1 ? &quot; element&quot; : &quot; elements&quot;);\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector&lt;Matcher&lt;const Element&amp;&gt;&gt; matchers_;\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_ * num_matchers_, 0) {}\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  std::string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use &#x27;SpaceIndex()&#x27; to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector&lt;char&gt; matched_;\n};\n\ntypedef ::std::pair&lt;size_t, size_t&gt; ElementMatcherPair;\ntypedef ::std::vector&lt;ElementMatcherPair&gt; ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph &#x27;g&#x27;.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs FindMaxBipartiteMatching(const MatchMatrix&amp; g);\n\nstruct UnorderedMatcherRequire {\n  enum Flags {\n    Superset = 1 &lt;&lt; 0,\n    Subset = 1 &lt;&lt; 1,\n    ExactMatch = Superset | Subset,\n  };\n};\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that&#x27;s not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  explicit UnorderedElementsAreMatcherImplBase(\n      UnorderedMatcherRequire::Flags matcher_flags)\n      : match_flags_(matcher_flags) {}\n\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector&lt;const MatcherDescriberInterface*&gt; MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyMatchMatrix(const ::std::vector&lt;std::string&gt;&amp; element_printouts,\n                         const MatchMatrix&amp; matrix,\n                         MatchResultListener* listener) const;\n\n  bool FindPairing(const MatchMatrix&amp; matrix,\n                   MatchResultListener* listener) const;\n\n  MatcherDescriberVec&amp; matcher_describers() { return matcher_describers_; }\n\n  static Message Elements(size_t n) {\n    return Message() &lt;&lt; n &lt;&lt; &quot; element&quot; &lt;&lt; (n == 1 ? &quot;&quot; : &quot;s&quot;);\n  }\n\n  UnorderedMatcherRequire::Flags match_flags() const { return match_flags_; }\n\n private:\n  UnorderedMatcherRequire::Flags match_flags_;\n  MatcherDescriberVec matcher_describers_;\n};\n\n// Implements UnorderedElementsAre, UnorderedElementsAreArray, IsSubsetOf, and\n// IsSupersetOf.\ntemplate &lt;typename Container&gt;\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface&lt;Container&gt;,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView&lt;RawContainer&gt; View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template &lt;typename InputIter&gt;\n  UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags,\n                                  InputIter first, InputIter last)\n      : UnorderedElementsAreMatcherImplBase(matcher_flags) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first));\n    }\n    for (const auto&amp; m : matchers_) {\n      matcher_describers().push_back(m.GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  void DescribeTo(::std::ostream* os) const override {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  void DescribeNegationTo(::std::ostream* os) const override {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  bool MatchAndExplain(Container container,\n                       MatchResultListener* listener) const override {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector&lt;std::string&gt; element_printouts;\n    MatchMatrix matrix =\n        AnalyzeElements(stl_container.begin(), stl_container.end(),\n                        &amp;element_printouts, listener);\n\n    if (matrix.LhsSize() == 0 &amp;&amp; matrix.RhsSize() == 0) {\n      return true;\n    }\n\n    if (match_flags() == UnorderedMatcherRequire::ExactMatch) {\n      if (matrix.LhsSize() != matrix.RhsSize()) {\n        // The element count doesn&#x27;t match.  If the container is empty,\n        // there&#x27;s no need to explain anything as Google Mock already\n        // prints the empty container. Otherwise we just need to show\n        // how many elements there actually are.\n        if (matrix.LhsSize() != 0 &amp;&amp; listener-&gt;IsInterested()) {\n          *listener &lt;&lt; &quot;which has &quot; &lt;&lt; Elements(matrix.LhsSize());\n        }\n        return false;\n      }\n    }\n\n    return VerifyMatchMatrix(element_printouts, matrix, listener) &amp;&amp;\n           FindPairing(matrix, listener);\n  }\n\n private:\n  template &lt;typename ElementIter&gt;\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector&lt;std::string&gt;* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts-&gt;clear();\n    ::std::vector&lt;char&gt; did_match;\n    size_t num_elements = 0;\n    DummyMatchResultListener dummy;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener-&gt;IsInterested()) {\n        element_printouts-&gt;push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(\n            matchers_[irhs].MatchAndExplain(*elem_first, &amp;dummy));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector&lt;char&gt;::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  ::std::vector&lt;Matcher&lt;const Element&amp;&gt;&gt; matchers_;\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast&lt;Target&gt; on an input argument of any type.\ntemplate &lt;typename Target&gt;\nstruct CastAndAppendTransform {\n  template &lt;typename Arg&gt;\n  Matcher&lt;Target&gt; operator()(const Arg&amp; a) const {\n    return MatcherCast&lt;Target&gt;(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate &lt;typename MatcherTuple&gt;\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple&amp; args)\n      : matchers_(args) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;\n    typedef typename View::value_type Element;\n    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt;&gt; MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);\n    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,\n                         ::std::back_inserter(matchers));\n    return Matcher&lt;Container&gt;(\n        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(\n            UnorderedMatcherRequire::ExactMatch, matchers.begin(),\n            matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n};\n\n// Implements ElementsAre.\ntemplate &lt;typename MatcherTuple&gt;\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple&amp; args) : matchers_(args) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    static_assert(\n        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value ||\n            ::std::tuple_size&lt;MatcherTuple&gt;::value &lt; 2,\n        &quot;use UnorderedElementsAre with hash tables&quot;);\n\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;\n    typedef typename View::value_type Element;\n    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt;&gt; MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);\n    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,\n                         ::std::back_inserter(matchers));\n    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(\n        matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n};\n\n// Implements UnorderedElementsAreArray(), IsSubsetOf(), and IsSupersetOf().\ntemplate &lt;typename T&gt;\nclass UnorderedElementsAreArrayMatcher {\n public:\n  template &lt;typename Iter&gt;\n  UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags,\n                                   Iter first, Iter last)\n      : match_flags_(match_flags), matchers_(first, last) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    return Matcher&lt;Container&gt;(\n        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(\n            match_flags_, matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  UnorderedMatcherRequire::Flags match_flags_;\n  ::std::vector&lt;T&gt; matchers_;\n};\n\n// Implements ElementsAreArray().\ntemplate &lt;typename T&gt;\nclass ElementsAreArrayMatcher {\n public:\n  template &lt;typename Iter&gt;\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template &lt;typename Container&gt;\n  operator Matcher&lt;Container&gt;() const {\n    static_assert(\n        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value,\n        &quot;use UnorderedElementsAreArray with hash tables&quot;);\n\n    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector&lt;T&gt; matchers_;\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm,\n// second) is a polymorphic matcher that matches a value x if and only if\n// tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate &lt;typename Tuple2Matcher, typename Second&gt;\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher&amp; tm, const Second&amp; second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  BoundSecondMatcher(const BoundSecondMatcher&amp; other) = default;\n\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    return MakeMatcher(new Impl&lt;T&gt;(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher&amp; /*rhs*/) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;BoundSecondMatcher should never be assigned.&quot;;\n  }\n\n private:\n  template &lt;typename T&gt;\n  class Impl : public MatcherInterface&lt;T&gt; {\n   public:\n    typedef ::std::tuple&lt;T, Second&gt; ArgTuple;\n\n    Impl(const Tuple2Matcher&amp; tm, const Second&amp; second)\n        : mono_tuple2_matcher_(SafeMatcherCast&lt;const ArgTuple&amp;&gt;(tm)),\n          second_value_(second) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;and &quot;;\n      UniversalPrint(second_value_, os);\n      *os &lt;&lt; &quot; &quot;;\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    bool MatchAndExplain(T x, MatchResultListener* listener) const override {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher&lt;const ArgTuple&amp;&gt; mono_tuple2_matcher_;\n    const Second second_value_;\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x if and only if tm matches tuple (x, second).  Useful for\n// implementing UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate &lt;typename Tuple2Matcher, typename Second&gt;\nBoundSecondMatcher&lt;Tuple2Matcher, Second&gt; MatcherBindSecond(\n    const Tuple2Matcher&amp; tm, const Second&amp; second) {\n  return BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is &quot;&quot;, if\n// &#x27;negation&#x27; is false; otherwise returns the description of the\n// negation of the matcher.  &#x27;param_values&#x27; contains a list of strings\n// that are the print-out of the matcher&#x27;s parameters.\nGTEST_API_ std::string FormatMatcherDescription(\n    bool negation, const char* matcher_name,\n    const std::vector&lt;const char*&gt;&amp; param_names, const Strings&amp; param_values);\n\n// Implements a matcher that checks the value of a optional&lt;&gt; type variable.\ntemplate &lt;typename ValueMatcher&gt;\nclass OptionalMatcher {\n public:\n  explicit OptionalMatcher(const ValueMatcher&amp; value_matcher)\n      : value_matcher_(value_matcher) {}\n\n  template &lt;typename Optional&gt;\n  operator Matcher&lt;Optional&gt;() const {\n    return Matcher&lt;Optional&gt;(new Impl&lt;const Optional&amp;&gt;(value_matcher_));\n  }\n\n  template &lt;typename Optional&gt;\n  class Impl : public MatcherInterface&lt;Optional&gt; {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView;\n    typedef typename OptionalView::value_type ValueType;\n    explicit Impl(const ValueMatcher&amp; value_matcher)\n        : value_matcher_(MatcherCast&lt;ValueType&gt;(value_matcher)) {}\n\n    void DescribeTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;value &quot;;\n      value_matcher_.DescribeTo(os);\n    }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      *os &lt;&lt; &quot;value &quot;;\n      value_matcher_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(Optional optional,\n                         MatchResultListener* listener) const override {\n      if (!optional) {\n        *listener &lt;&lt; &quot;which is not engaged&quot;;\n        return false;\n      }\n      const ValueType&amp; value = *optional;\n      StringMatchResultListener value_listener;\n      const bool match = value_matcher_.MatchAndExplain(value, &amp;value_listener);\n      *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(value)\n                &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n      PrintIfNotEmpty(value_listener.str(), listener-&gt;stream());\n      return match;\n    }\n\n   private:\n    const Matcher&lt;ValueType&gt; value_matcher_;\n  };\n\n private:\n  const ValueMatcher value_matcher_;\n};\n\nnamespace variant_matcher {\n// Overloads to allow VariantMatcher to do proper ADL lookup.\ntemplate &lt;typename T&gt;\nvoid holds_alternative() {}\ntemplate &lt;typename T&gt;\nvoid get() {}\n\n// Implements a matcher that checks the value of a variant&lt;&gt; type variable.\ntemplate &lt;typename T&gt;\nclass VariantMatcher {\n public:\n  explicit VariantMatcher(::testing::Matcher&lt;const T&amp;&gt; matcher)\n      : matcher_(std::move(matcher)) {}\n\n  template &lt;typename Variant&gt;\n  bool MatchAndExplain(const Variant&amp; value,\n                       ::testing::MatchResultListener* listener) const {\n    using std::get;\n    if (!listener-&gt;IsInterested()) {\n      return holds_alternative&lt;T&gt;(value) &amp;&amp; matcher_.Matches(get&lt;T&gt;(value));\n    }\n\n    if (!holds_alternative&lt;T&gt;(value)) {\n      *listener &lt;&lt; &quot;whose value is not of type &#x27;&quot; &lt;&lt; GetTypeName() &lt;&lt; &quot;&#x27;&quot;;\n      return false;\n    }\n\n    const T&amp; elem = get&lt;T&gt;(value);\n    StringMatchResultListener elem_listener;\n    const bool match = matcher_.MatchAndExplain(elem, &amp;elem_listener);\n    *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(elem)\n              &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());\n    return match;\n  }\n\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;is a variant&lt;&gt; with value of type &#x27;&quot; &lt;&lt; GetTypeName()\n        &lt;&lt; &quot;&#x27; and the value &quot;;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;is a variant&lt;&gt; with value of type other than &#x27;&quot; &lt;&lt; GetTypeName()\n        &lt;&lt; &quot;&#x27; or the value &quot;;\n    matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static std::string GetTypeName() {\n#if GTEST_HAS_RTTI\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(\n        return internal::GetTypeName&lt;T&gt;());\n#endif\n    return &quot;the element type&quot;;\n  }\n\n  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;\n};\n\n}  // namespace variant_matcher\n\nnamespace any_cast_matcher {\n\n// Overloads to allow AnyCastMatcher to do proper ADL lookup.\ntemplate &lt;typename T&gt;\nvoid any_cast() {}\n\n// Implements a matcher that any_casts the value.\ntemplate &lt;typename T&gt;\nclass AnyCastMatcher {\n public:\n  explicit AnyCastMatcher(const ::testing::Matcher&lt;const T&amp;&gt;&amp; matcher)\n      : matcher_(matcher) {}\n\n  template &lt;typename AnyType&gt;\n  bool MatchAndExplain(const AnyType&amp; value,\n                       ::testing::MatchResultListener* listener) const {\n    if (!listener-&gt;IsInterested()) {\n      const T* ptr = any_cast&lt;T&gt;(&amp;value);\n      return ptr != nullptr &amp;&amp; matcher_.Matches(*ptr);\n    }\n\n    const T* elem = any_cast&lt;T&gt;(&amp;value);\n    if (elem == nullptr) {\n      *listener &lt;&lt; &quot;whose value is not of type &#x27;&quot; &lt;&lt; GetTypeName() &lt;&lt; &quot;&#x27;&quot;;\n      return false;\n    }\n\n    StringMatchResultListener elem_listener;\n    const bool match = matcher_.MatchAndExplain(*elem, &amp;elem_listener);\n    *listener &lt;&lt; &quot;whose value &quot; &lt;&lt; PrintToString(*elem)\n              &lt;&lt; (match ? &quot; matches&quot; : &quot; doesn&#x27;t match&quot;);\n    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());\n    return match;\n  }\n\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;is an &#x27;any&#x27; type with value of type &#x27;&quot; &lt;&lt; GetTypeName()\n        &lt;&lt; &quot;&#x27; and the value &quot;;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;is an &#x27;any&#x27; type with value of type other than &#x27;&quot; &lt;&lt; GetTypeName()\n        &lt;&lt; &quot;&#x27; or the value &quot;;\n    matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static std::string GetTypeName() {\n#if GTEST_HAS_RTTI\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(\n        return internal::GetTypeName&lt;T&gt;());\n#endif\n    return &quot;the element type&quot;;\n  }\n\n  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;\n};\n\n}  // namespace any_cast_matcher\n\n// Implements the Args() matcher.\ntemplate &lt;class ArgsTuple, size_t... k&gt;\nclass ArgsMatcherImpl : public MatcherInterface&lt;ArgsTuple&gt; {\n public:\n  using RawArgsTuple = typename std::decay&lt;ArgsTuple&gt;::type;\n  using SelectedArgs =\n      std::tuple&lt;typename std::tuple_element&lt;k, RawArgsTuple&gt;::type...&gt;;\n  using MonomorphicInnerMatcher = Matcher&lt;const SelectedArgs&amp;&gt;;\n\n  template &lt;typename InnerMatcher&gt;\n  explicit ArgsMatcherImpl(const InnerMatcher&amp; inner_matcher)\n      : inner_matcher_(SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)) {}\n\n  bool MatchAndExplain(ArgsTuple args,\n                       MatchResultListener* listener) const override {\n    // Workaround spurious C4100 on MSVC&lt;=15.7 when k is empty.\n    (void)args;\n    const SelectedArgs&amp; selected_args =\n        std::forward_as_tuple(std::get&lt;k&gt;(args)...);\n    if (!listener-&gt;IsInterested()) return inner_matcher_.Matches(selected_args);\n\n    PrintIndices(listener-&gt;stream());\n    *listener &lt;&lt; &quot;are &quot; &lt;&lt; PrintToString(selected_args);\n\n    StringMatchResultListener inner_listener;\n    const bool match =\n        inner_matcher_.MatchAndExplain(selected_args, &amp;inner_listener);\n    PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());\n    return match;\n  }\n\n  void DescribeTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;are a tuple &quot;;\n    PrintIndices(os);\n    inner_matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const override {\n    *os &lt;&lt; &quot;are a tuple &quot;;\n    PrintIndices(os);\n    inner_matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  // Prints the indices of the selected fields.\n  static void PrintIndices(::std::ostream* os) {\n    *os &lt;&lt; &quot;whose fields (&quot;;\n    const char* sep = &quot;&quot;;\n    // Workaround spurious C4189 on MSVC&lt;=15.7 when k is empty.\n    (void)sep;\n    const char* dummy[] = {&quot;&quot;, (*os &lt;&lt; sep &lt;&lt; &quot;#&quot; &lt;&lt; k, sep = &quot;, &quot;)...};\n    (void)dummy;\n    *os &lt;&lt; &quot;) &quot;;\n  }\n\n  MonomorphicInnerMatcher inner_matcher_;\n};\n\ntemplate &lt;class InnerMatcher, size_t... k&gt;\nclass ArgsMatcher {\n public:\n  explicit ArgsMatcher(InnerMatcher inner_matcher)\n      : inner_matcher_(std::move(inner_matcher)) {}\n\n  template &lt;typename ArgsTuple&gt;\n  operator Matcher&lt;ArgsTuple&gt;() const {  // NOLINT\n    return MakeMatcher(new ArgsMatcherImpl&lt;ArgsTuple, k...&gt;(inner_matcher_));\n  }\n\n private:\n  InnerMatcher inner_matcher_;\n};\n\n}  // namespace internal\n\n// ElementsAreArray(iterator_first, iterator_last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate &lt;typename Iter&gt;\ninline internal::ElementsAreArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;\n  return internal::ElementsAreArrayMatcher&lt;T&gt;(first, last);\n}\n\ntemplate &lt;typename T&gt;\ninline auto ElementsAreArray(const T* pointer, size_t count)\n    -&gt; decltype(ElementsAreArray(pointer, pointer + count)) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline auto ElementsAreArray(const T (&amp;array)[N])\n    -&gt; decltype(ElementsAreArray(array, N)) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate &lt;typename Container&gt;\ninline auto ElementsAreArray(const Container&amp; container)\n    -&gt; decltype(ElementsAreArray(container.begin(), container.end())) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\ntemplate &lt;typename T&gt;\ninline auto ElementsAreArray(::std::initializer_list&lt;T&gt; xs)\n    -&gt; decltype(ElementsAreArray(xs.begin(), xs.end())) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n\n// UnorderedElementsAreArray(iterator_first, iterator_last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// UnorderedElementsAreArray() verifies that a bijective mapping onto a\n// collection of matchers exists.\n//\n// The matchers can be specified as an array, a pointer and count, a container,\n// an initializer list, or an STL iterator range. In each of these cases, the\n// underlying matchers can be either values or matchers.\n\ntemplate &lt;typename Iter&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(\n      internal::UnorderedMatcherRequire::ExactMatch, first, last);\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; UnorderedElementsAreArray(\n    const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; UnorderedElementsAreArray(\n    const T (&amp;array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate &lt;typename Container&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename Container::value_type&gt;\nUnorderedElementsAreArray(const Container&amp; container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; UnorderedElementsAreArray(\n    ::std::initializer_list&lt;T&gt; xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it&#x27;s OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate &lt;typename T&gt;\ninline Matcher&lt;T&gt; A() {\n  return _;\n}\n\n// Creates a matcher that matches any value of the given type T.\ntemplate &lt;typename T&gt;\ninline Matcher&lt;T&gt; An() {\n  return _;\n}\n\ntemplate &lt;typename T, typename M&gt;\nMatcher&lt;T&gt; internal::MatcherCastImpl&lt;T, M&gt;::CastImpl(\n    const M&amp; value, std::false_type /* convertible_to_matcher */,\n    std::false_type /* convertible_to_T */) {\n  return Eq(value);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher&lt;internal::IsNullMatcher&gt; IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn&#x27;t compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher&lt;internal::NotNullMatcher&gt; NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate &lt;typename T&gt;\ninline internal::RefMatcher&lt;T&amp;&gt; Ref(T&amp; x) {  // NOLINT\n  return internal::RefMatcher&lt;T&amp;&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches any NaN floating point.\ninline PolymorphicMatcher&lt;internal::IsNanMatcher&gt; IsNan() {\n  return MakePolymorphicMatcher(internal::IsNanMatcher());\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher&lt;double&gt; DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher&lt;double&gt; DoubleNear(double rhs,\n                                                      double max_abs_error) {\n  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher&lt;float&gt; FloatEq(float rhs) {\n  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher&lt;float&gt; FloatNear(float rhs,\n                                                    float max_abs_error) {\n  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate &lt;typename InnerMatcher&gt;\ninline internal::PointeeMatcher&lt;InnerMatcher&gt; Pointee(\n    const InnerMatcher&amp; inner_matcher) {\n  return internal::PointeeMatcher&lt;InnerMatcher&gt;(inner_matcher);\n}\n\n#if GTEST_HAS_RTTI\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast&lt;To&gt; is applied.\n// The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate &lt;typename To&gt;\ninline PolymorphicMatcher&lt;internal::WhenDynamicCastToMatcher&lt;To&gt;&gt;\nWhenDynamicCastTo(const Matcher&lt;To&gt;&amp; inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher&lt;To&gt;(inner_matcher));\n}\n#endif  // GTEST_HAS_RTTI\n\n// Creates a matcher that matches an object whose given field matches\n// &#x27;matcher&#x27;.  For example,\n//   Field(&amp;Foo::number, Ge(5))\n// matches a Foo object x if and only if x.number &gt;= 5.\ntemplate &lt;typename Class, typename FieldType, typename FieldMatcher&gt;\ninline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt;&gt; Field(\n    FieldType Class::*field, const FieldMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(\n      field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&amp;Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Same as Field() but also takes the name of the field to provide better error\n// messages.\ntemplate &lt;typename Class, typename FieldType, typename FieldMatcher&gt;\ninline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt;&gt; Field(\n    const std::string&amp; field_name, FieldType Class::*field,\n    const FieldMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(\n      field_name, field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));\n}\n\n// Creates a matcher that matches an object whose given property\n// matches &#x27;matcher&#x27;.  For example,\n//   Property(&amp;Foo::str, StartsWith(&quot;hi&quot;))\n// matches a Foo object x if and only if x.str() starts with &quot;hi&quot;.\ntemplate &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;\ninline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;\n    Class, PropertyType, PropertyType (Class::*)() const&gt;&gt;\nProperty(PropertyType (Class::*property)() const,\n         const PropertyMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher&lt;Class, PropertyType,\n                                PropertyType (Class::*)() const&gt;(\n          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&amp;Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Same as Property() above, but also takes the name of the property to provide\n// better error messages.\ntemplate &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;\ninline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;\n    Class, PropertyType, PropertyType (Class::*)() const&gt;&gt;\nProperty(const std::string&amp; property_name,\n         PropertyType (Class::*property)() const,\n         const PropertyMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher&lt;Class, PropertyType,\n                                PropertyType (Class::*)() const&gt;(\n          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));\n}\n\n// The same as above but for reference-qualified member functions.\ntemplate &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;\ninline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;\n    Class, PropertyType, PropertyType (Class::*)() const&amp;&gt;&gt;\nProperty(PropertyType (Class::*property)() const&amp;,\n         const PropertyMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher&lt;Class, PropertyType,\n                                PropertyType (Class::*)() const&amp;&gt;(\n          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));\n}\n\n// Three-argument form for reference-qualified member functions.\ntemplate &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;\ninline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;\n    Class, PropertyType, PropertyType (Class::*)() const&amp;&gt;&gt;\nProperty(const std::string&amp; property_name,\n         PropertyType (Class::*property)() const&amp;,\n         const PropertyMatcher&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher&lt;Class, PropertyType,\n                                PropertyType (Class::*)() const&amp;&gt;(\n          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));\n}\n\n// Creates a matcher that matches an object if and only if the result of\n// applying a callable to x matches &#x27;matcher&#x27;. For example,\n//   ResultOf(f, StartsWith(&quot;hi&quot;))\n// matches a Foo object x if and only if f(x) starts with &quot;hi&quot;.\n// `callable` parameter can be a function, function pointer, or a functor. It is\n// required to keep no state affecting the results of the calls on it and make\n// no assumptions about how many calls will be made. Any state it keeps must be\n// protected from the concurrent access.\ntemplate &lt;typename Callable, typename InnerMatcher&gt;\ninternal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(\n    Callable callable, InnerMatcher matcher) {\n  return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(std::move(callable),\n                                                           std::move(matcher));\n}\n\n// Same as ResultOf() above, but also takes a description of the `callable`\n// result to provide better error messages.\ntemplate &lt;typename Callable, typename InnerMatcher&gt;\ninternal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(\n    const std::string&amp; result_description, Callable callable,\n    InnerMatcher matcher) {\n  return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(\n      result_description, std::move(callable), std::move(matcher));\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt;&gt; StrEq(\n    const internal::StringLike&lt;T&gt;&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), true, true));\n}\n\n// Matches a string not equal to str.\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt;&gt; StrNe(\n    const internal::StringLike&lt;T&gt;&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt;&gt; StrCaseEq(\n    const internal::StringLike&lt;T&gt;&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt;&gt; StrCaseNe(\n    const internal::StringLike&lt;T&gt;&amp; str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher&lt;std::string&gt;(\n      std::string(str), false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::string&gt;&gt; HasSubstr(\n    const internal::StringLike&lt;T&gt;&amp; substring) {\n  return MakePolymorphicMatcher(\n      internal::HasSubstrMatcher&lt;std::string&gt;(std::string(substring)));\n}\n\n// Matches a string that starts with &#x27;prefix&#x27; (case-sensitive).\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::string&gt;&gt; StartsWith(\n    const internal::StringLike&lt;T&gt;&amp; prefix) {\n  return MakePolymorphicMatcher(\n      internal::StartsWithMatcher&lt;std::string&gt;(std::string(prefix)));\n}\n\n// Matches a string that ends with &#x27;suffix&#x27; (case-sensitive).\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::string&gt;&gt; EndsWith(\n    const internal::StringLike&lt;T&gt;&amp; suffix) {\n  return MakePolymorphicMatcher(\n      internal::EndsWithMatcher&lt;std::string&gt;(std::string(suffix)));\n}\n\n#if GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt;&gt; StrEq(\n    const std::wstring&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt;&gt; StrNe(\n    const std::wstring&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt;&gt; StrCaseEq(\n    const std::wstring&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt;&gt; StrCaseNe(\n    const std::wstring&amp; str) {\n  return MakePolymorphicMatcher(\n      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, false));\n}\n\n// Creates a matcher that matches any ::wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::wstring&gt;&gt; HasSubstr(\n    const std::wstring&amp; substring) {\n  return MakePolymorphicMatcher(\n      internal::HasSubstrMatcher&lt;std::wstring&gt;(substring));\n}\n\n// Matches a string that starts with &#x27;prefix&#x27; (case-sensitive).\ninline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::wstring&gt;&gt; StartsWith(\n    const std::wstring&amp; prefix) {\n  return MakePolymorphicMatcher(\n      internal::StartsWithMatcher&lt;std::wstring&gt;(prefix));\n}\n\n// Matches a string that ends with &#x27;suffix&#x27; (case-sensitive).\ninline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::wstring&gt;&gt; EndsWith(\n    const std::wstring&amp; suffix) {\n  return MakePolymorphicMatcher(\n      internal::EndsWithMatcher&lt;std::wstring&gt;(suffix));\n}\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field &gt;= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field &gt; the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field &lt;= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field &lt; the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// FloatEq(first field) matches the second field.\ninline internal::FloatingEq2Matcher&lt;float&gt; FloatEq() {\n  return internal::FloatingEq2Matcher&lt;float&gt;();\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// DoubleEq(first field) matches the second field.\ninline internal::FloatingEq2Matcher&lt;double&gt; DoubleEq() {\n  return internal::FloatingEq2Matcher&lt;double&gt;();\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// FloatEq(first field) matches the second field with NaN equality.\ninline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatEq() {\n  return internal::FloatingEq2Matcher&lt;float&gt;(true);\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// DoubleEq(first field) matches the second field with NaN equality.\ninline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleEq() {\n  return internal::FloatingEq2Matcher&lt;double&gt;(true);\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// FloatNear(first field, max_abs_error) matches the second field.\ninline internal::FloatingEq2Matcher&lt;float&gt; FloatNear(float max_abs_error) {\n  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error);\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// DoubleNear(first field, max_abs_error) matches the second field.\ninline internal::FloatingEq2Matcher&lt;double&gt; DoubleNear(double max_abs_error) {\n  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error);\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// FloatNear(first field, max_abs_error) matches the second field with NaN\n// equality.\ninline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatNear(\n    float max_abs_error) {\n  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error, true);\n}\n\n// Creates a polymorphic matcher that matches a 2-tuple where\n// DoubleNear(first field, max_abs_error) matches the second field with NaN\n// equality.\ninline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleNear(\n    double max_abs_error) {\n  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error, true);\n}\n\n// Creates a matcher that matches any value of type T that m doesn&#x27;t\n// match.\ntemplate &lt;typename InnerMatcher&gt;\ninline internal::NotMatcher&lt;InnerMatcher&gt; Not(InnerMatcher m) {\n  return internal::NotMatcher&lt;InnerMatcher&gt;(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate &lt;typename Predicate&gt;\ninline PolymorphicMatcher&lt;internal::TrulyMatcher&lt;Predicate&gt;&gt; Truly(\n    Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher&lt;Predicate&gt;(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter &#x27;size&#x27; can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate &lt;typename SizeMatcher&gt;\ninline internal::SizeIsMatcher&lt;SizeMatcher&gt; SizeIs(\n    const SizeMatcher&amp; size_matcher) {\n  return internal::SizeIsMatcher&lt;SizeMatcher&gt;(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container&#x27;s begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate &lt;typename DistanceMatcher&gt;\ninline internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt; BeginEndDistanceIs(\n    const DistanceMatcher&amp; distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate &lt;typename Container&gt;\ninline PolymorphicMatcher&lt;\n    internal::ContainerEqMatcher&lt;typename std::remove_const&lt;Container&gt;::type&gt;&gt;\nContainerEq(const Container&amp; rhs) {\n  return MakePolymorphicMatcher(internal::ContainerEqMatcher&lt;Container&gt;(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate &lt;typename Comparator, typename ContainerMatcher&gt;\ninline internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt; WhenSortedBy(\n    const Comparator&amp; comparator, const ContainerMatcher&amp; container_matcher) {\n  return internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the &lt; operator, matches container_matcher.\ntemplate &lt;typename ContainerMatcher&gt;\ninline internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;\nWhenSorted(const ContainerMatcher&amp; container_matcher) {\n  return internal::WhenSortedByMatcher&lt;internal::LessComparator,\n                                       ContainerMatcher&gt;(\n      internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs&#x27;s\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher&lt;std::tuple&lt;const\n// T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate &lt;typename TupleMatcher, typename Container&gt;\ninline internal::PointwiseMatcher&lt;TupleMatcher,\n                                  typename std::remove_const&lt;Container&gt;::type&gt;\nPointwise(const TupleMatcher&amp; tuple_matcher, const Container&amp; rhs) {\n  return internal::PointwiseMatcher&lt;TupleMatcher, Container&gt;(tuple_matcher,\n                                                             rhs);\n}\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate &lt;typename TupleMatcher, typename T&gt;\ninline internal::PointwiseMatcher&lt;TupleMatcher, std::vector&lt;T&gt;&gt; Pointwise(\n    const TupleMatcher&amp; tuple_matcher, std::initializer_list&lt;T&gt; rhs) {\n  return Pointwise(tuple_matcher, std::vector&lt;T&gt;(rhs));\n}\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs&#x27;s i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher&lt;std::tuple&lt;const T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn&#x27;t matter.\ntemplate &lt;typename Tuple2Matcher, typename RhsContainer&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename internal::BoundSecondMatcher&lt;\n        Tuple2Matcher,\n        typename internal::StlContainerView&lt;\n            typename std::remove_const&lt;RhsContainer&gt;::type&gt;::type::value_type&gt;&gt;\nUnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,\n                   const RhsContainer&amp; rhs_container) {\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView&lt;RhsContainer&gt; RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer&amp; rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector&lt;internal::BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;&gt; matchers;\n  for (auto it = rhs_stl_container.begin(); it != rhs_stl_container.end();\n       ++it) {\n    matchers.push_back(internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate &lt;typename Tuple2Matcher, typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename internal::BoundSecondMatcher&lt;Tuple2Matcher, T&gt;&gt;\nUnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,\n                   std::initializer_list&lt;T&gt; rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector&lt;T&gt;(rhs));\n}\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set&lt;int&gt; page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));  // See below for Times(0)\n//\n//   ::std::map&lt;int, size_t&gt; page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair&lt;const int, size_t&gt;(1, 100)));\n//\n//   const char* user_ids[] = { &quot;joe&quot;, &quot;mike&quot;, &quot;tom&quot; };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(&quot;tom&quot;))));\n//\n// The matcher supports a modifier `Times` that allows to check for arbitrary\n// occurrences including testing for absence with Times(0).\n//\n// Examples:\n//   ::std::vector&lt;int&gt; ids;\n//   ids.insert(1);\n//   ids.insert(1);\n//   ids.insert(3);\n//   EXPECT_THAT(ids, Contains(1).Times(2));      // 1 occurs 2 times\n//   EXPECT_THAT(ids, Contains(2).Times(0));      // 2 is not present\n//   EXPECT_THAT(ids, Contains(3).Times(Ge(1)));  // 3 occurs at least once\n\ntemplate &lt;typename M&gt;\ninline internal::ContainsMatcher&lt;M&gt; Contains(M matcher) {\n  return internal::ContainsMatcher&lt;M&gt;(matcher);\n}\n\n// IsSupersetOf(iterator_first, iterator_last)\n// IsSupersetOf(pointer, count)\n// IsSupersetOf(array)\n// IsSupersetOf(container)\n// IsSupersetOf({e1, e2, ..., en})\n//\n// IsSupersetOf() verifies that a surjective partial mapping onto a collection\n// of matchers exists. In other words, a container matches\n// IsSupersetOf({e1, ..., en}) if and only if there is a permutation\n// {y1, ..., yn} of some of the container&#x27;s elements where y1 matches e1,\n// ..., and yn matches en. Obviously, the size of the container must be &gt;= n\n// in order to have a match. Examples:\n//\n// - {1, 2, 3} matches IsSupersetOf({Ge(3), Ne(0)}), as 3 matches Ge(3) and\n//   1 matches Ne(0).\n// - {1, 2} doesn&#x27;t match IsSupersetOf({Eq(1), Lt(2)}), even though 1 matches\n//   both Eq(1) and Lt(2). The reason is that different matchers must be used\n//   for elements in different slots of the container.\n// - {1, 1, 2} matches IsSupersetOf({Eq(1), Lt(2)}), as (the first) 1 matches\n//   Eq(1) and (the second) 1 matches Lt(2).\n// - {1, 2, 3} matches IsSupersetOf(Gt(1), Gt(1)), as 2 matches (the first)\n//   Gt(1) and 3 matches (the second) Gt(1).\n//\n// The matchers can be specified as an array, a pointer and count, a container,\n// an initializer list, or an STL iterator range. In each of these cases, the\n// underlying matchers can be either values or matchers.\n\ntemplate &lt;typename Iter&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nIsSupersetOf(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(\n      internal::UnorderedMatcherRequire::Superset, first, last);\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(\n    const T* pointer, size_t count) {\n  return IsSupersetOf(pointer, pointer + count);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(\n    const T (&amp;array)[N]) {\n  return IsSupersetOf(array, N);\n}\n\ntemplate &lt;typename Container&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename Container::value_type&gt;\nIsSupersetOf(const Container&amp; container) {\n  return IsSupersetOf(container.begin(), container.end());\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(\n    ::std::initializer_list&lt;T&gt; xs) {\n  return IsSupersetOf(xs.begin(), xs.end());\n}\n\n// IsSubsetOf(iterator_first, iterator_last)\n// IsSubsetOf(pointer, count)\n// IsSubsetOf(array)\n// IsSubsetOf(container)\n// IsSubsetOf({e1, e2, ..., en})\n//\n// IsSubsetOf() verifies that an injective mapping onto a collection of matchers\n// exists.  In other words, a container matches IsSubsetOf({e1, ..., en}) if and\n// only if there is a subset of matchers {m1, ..., mk} which would match the\n// container using UnorderedElementsAre.  Obviously, the size of the container\n// must be &lt;= n in order to have a match. Examples:\n//\n// - {1} matches IsSubsetOf({Gt(0), Lt(0)}), as 1 matches Gt(0).\n// - {1, -1} matches IsSubsetOf({Lt(0), Gt(0)}), as 1 matches Gt(0) and -1\n//   matches Lt(0).\n// - {1, 2} doesn&#x27;t matches IsSubsetOf({Gt(0), Lt(0)}), even though 1 and 2 both\n//   match Gt(0). The reason is that different matchers must be used for\n//   elements in different slots of the container.\n//\n// The matchers can be specified as an array, a pointer and count, a container,\n// an initializer list, or an STL iterator range. In each of these cases, the\n// underlying matchers can be either values or matchers.\n\ntemplate &lt;typename Iter&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nIsSubsetOf(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(\n      internal::UnorderedMatcherRequire::Subset, first, last);\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(\n    const T* pointer, size_t count) {\n  return IsSubsetOf(pointer, pointer + count);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(\n    const T (&amp;array)[N]) {\n  return IsSubsetOf(array, N);\n}\n\ntemplate &lt;typename Container&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;\n    typename Container::value_type&gt;\nIsSubsetOf(const Container&amp; container) {\n  return IsSubsetOf(container.begin(), container.end());\n}\n\ntemplate &lt;typename T&gt;\ninline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(\n    ::std::initializer_list&lt;T&gt; xs) {\n  return IsSubsetOf(xs.begin(), xs.end());\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to `Not(Contains(Not(m)))`. Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set&lt;int&gt; page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map&lt;int, size_t&gt; page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { &quot;joe&quot;, &quot;mike&quot;, &quot;tom&quot; };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(&quot;tom&quot;)))));\ntemplate &lt;typename M&gt;\ninline internal::EachMatcher&lt;M&gt; Each(M matcher) {\n  return internal::EachMatcher&lt;M&gt;(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose &#x27;first&#x27; field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is &gt;= 5.\ntemplate &lt;typename M&gt;\ninline internal::KeyMatcher&lt;M&gt; Key(M inner_matcher) {\n  return internal::KeyMatcher&lt;M&gt;(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose &#x27;first&#x27; field\n// matches first_matcher and whose &#x27;second&#x27; field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), &quot;foo&quot;))) can be used\n// to match a std::map&lt;int, string&gt; that contains exactly one element whose key\n// is &gt;= 5 and whose value equals &quot;foo&quot;.\ntemplate &lt;typename FirstMatcher, typename SecondMatcher&gt;\ninline internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt; Pair(\n    FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;(first_matcher,\n                                                            second_matcher);\n}\n\nnamespace no_adl {\n// Conditional() creates a matcher that conditionally uses either the first or\n// second matcher provided. For example, we could create an `equal if, and only\n// if&#x27; matcher using the Conditional wrapper as follows:\n//\n//   EXPECT_THAT(result, Conditional(condition, Eq(expected), Ne(expected)));\ntemplate &lt;typename MatcherTrue, typename MatcherFalse&gt;\ninternal::ConditionalMatcher&lt;MatcherTrue, MatcherFalse&gt; Conditional(\n    bool condition, MatcherTrue matcher_true, MatcherFalse matcher_false) {\n  return internal::ConditionalMatcher&lt;MatcherTrue, MatcherFalse&gt;(\n      condition, std::move(matcher_true), std::move(matcher_false));\n}\n\n// FieldsAre(matchers...) matches piecewise the fields of compatible structs.\n// These include those that support `get&lt;I&gt;(obj)`, and when structured bindings\n// are enabled any class that supports them.\n// In particular, `std::tuple`, `std::pair`, `std::array` and aggregate types.\ntemplate &lt;typename... M&gt;\ninternal::FieldsAreMatcher&lt;typename std::decay&lt;M&gt;::type...&gt; FieldsAre(\n    M&amp;&amp;... matchers) {\n  return internal::FieldsAreMatcher&lt;typename std::decay&lt;M&gt;::type...&gt;(\n      std::forward&lt;M&gt;(matchers)...);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that matches\n// inner_matcher.\ntemplate &lt;typename InnerMatcher&gt;\ninline internal::PointerMatcher&lt;InnerMatcher&gt; Pointer(\n    const InnerMatcher&amp; inner_matcher) {\n  return internal::PointerMatcher&lt;InnerMatcher&gt;(inner_matcher);\n}\n\n// Creates a matcher that matches an object that has an address that matches\n// inner_matcher.\ntemplate &lt;typename InnerMatcher&gt;\ninline internal::AddressMatcher&lt;InnerMatcher&gt; Address(\n    const InnerMatcher&amp; inner_matcher) {\n  return internal::AddressMatcher&lt;InnerMatcher&gt;(inner_matcher);\n}\n\n// Matches a base64 escaped string, when the unescaped string matches the\n// internal matcher.\ntemplate &lt;typename MatcherType&gt;\ninternal::WhenBase64UnescapedMatcher WhenBase64Unescaped(\n    const MatcherType&amp; internal_matcher) {\n  return internal::WhenBase64UnescapedMatcher(internal_matcher);\n}\n}  // namespace no_adl\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate &lt;typename M&gt;\ninline internal::MatcherAsPredicate&lt;M&gt; Matches(M matcher) {\n  return internal::MatcherAsPredicate&lt;M&gt;(matcher);\n}\n\n// Returns true if and only if the value matches the matcher.\ntemplate &lt;typename T, typename M&gt;\ninline bool Value(const T&amp; value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate &lt;typename T, typename M&gt;\ninline bool ExplainMatchResult(M matcher, const T&amp; value,\n                               MatchResultListener* listener) {\n  return SafeMatcherCast&lt;const T&amp;&gt;(matcher).MatchAndExplain(value, listener);\n}\n\n// Returns a string representation of the given matcher.  Useful for description\n// strings of matchers defined using MATCHER_P* macros that accept matchers as\n// their arguments.  For example:\n//\n// MATCHER_P(XAndYThat, matcher,\n//           &quot;X that &quot; + DescribeMatcher&lt;int&gt;(matcher, negation) +\n//               (negation ? &quot; or&quot; : &quot; and&quot;) + &quot; Y that &quot; +\n//               DescribeMatcher&lt;double&gt;(matcher, negation)) {\n//   return ExplainMatchResult(matcher, arg.x(), result_listener) &amp;&amp;\n//          ExplainMatchResult(matcher, arg.y(), result_listener);\n// }\ntemplate &lt;typename T, typename M&gt;\nstd::string DescribeMatcher(const M&amp; matcher, bool negation = false) {\n  ::std::stringstream ss;\n  Matcher&lt;T&gt; monomorphic_matcher = SafeMatcherCast&lt;T&gt;(matcher);\n  if (negation) {\n    monomorphic_matcher.DescribeNegationTo(&amp;ss);\n  } else {\n    monomorphic_matcher.DescribeTo(&amp;ss);\n  }\n  return ss.str();\n}\n\ntemplate &lt;typename... Args&gt;\ninternal::ElementsAreMatcher&lt;\n    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;\nElementsAre(const Args&amp;... matchers) {\n  return internal::ElementsAreMatcher&lt;\n      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(\n      std::make_tuple(matchers...));\n}\n\ntemplate &lt;typename... Args&gt;\ninternal::UnorderedElementsAreMatcher&lt;\n    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;\nUnorderedElementsAre(const Args&amp;... matchers) {\n  return internal::UnorderedElementsAreMatcher&lt;\n      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(\n      std::make_tuple(matchers...));\n}\n\n// Define variadic matcher versions.\ntemplate &lt;typename... Args&gt;\ninternal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AllOf(\n    const Args&amp;... matchers) {\n  return internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(\n      matchers...);\n}\n\ntemplate &lt;typename... Args&gt;\ninternal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AnyOf(\n    const Args&amp;... matchers) {\n  return internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(\n      matchers...);\n}\n\n// AnyOfArray(array)\n// AnyOfArray(pointer, count)\n// AnyOfArray(container)\n// AnyOfArray({ e1, e2, ..., en })\n// AnyOfArray(iterator_first, iterator_last)\n//\n// AnyOfArray() verifies whether a given value matches any member of a\n// collection of matchers.\n//\n// AllOfArray(array)\n// AllOfArray(pointer, count)\n// AllOfArray(container)\n// AllOfArray({ e1, e2, ..., en })\n// AllOfArray(iterator_first, iterator_last)\n//\n// AllOfArray() verifies whether a given value matches all members of a\n// collection of matchers.\n//\n// The matchers can be specified as an array, a pointer and count, a container,\n// an initializer list, or an STL iterator range. In each of these cases, the\n// underlying matchers can be either values or matchers.\n\ntemplate &lt;typename Iter&gt;\ninline internal::AnyOfArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nAnyOfArray(Iter first, Iter last) {\n  return internal::AnyOfArrayMatcher&lt;\n      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);\n}\n\ntemplate &lt;typename Iter&gt;\ninline internal::AllOfArrayMatcher&lt;\n    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;\nAllOfArray(Iter first, Iter last) {\n  return internal::AllOfArrayMatcher&lt;\n      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);\n}\n\ntemplate &lt;typename T&gt;\ninline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T* ptr, size_t count) {\n  return AnyOfArray(ptr, ptr + count);\n}\n\ntemplate &lt;typename T&gt;\ninline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T* ptr, size_t count) {\n  return AllOfArray(ptr, ptr + count);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T (&amp;array)[N]) {\n  return AnyOfArray(array, N);\n}\n\ntemplate &lt;typename T, size_t N&gt;\ninline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T (&amp;array)[N]) {\n  return AllOfArray(array, N);\n}\n\ntemplate &lt;typename Container&gt;\ninline internal::AnyOfArrayMatcher&lt;typename Container::value_type&gt; AnyOfArray(\n    const Container&amp; container) {\n  return AnyOfArray(container.begin(), container.end());\n}\n\ntemplate &lt;typename Container&gt;\ninline internal::AllOfArrayMatcher&lt;typename Container::value_type&gt; AllOfArray(\n    const Container&amp; container) {\n  return AllOfArray(container.begin(), container.end());\n}\n\ntemplate &lt;typename T&gt;\ninline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(\n    ::std::initializer_list&lt;T&gt; xs) {\n  return AnyOfArray(xs.begin(), xs.end());\n}\n\ntemplate &lt;typename T&gt;\ninline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(\n    ::std::initializer_list&lt;T&gt; xs) {\n  return AllOfArray(xs.begin(), xs.end());\n}\n\n// Args&lt;N1, N2, ..., Nk&gt;(a_matcher) matches a tuple if the selected\n// fields of it matches a_matcher.  C++ doesn&#x27;t support default\n// arguments for function templates, so we have to overload it.\ntemplate &lt;size_t... k, typename InnerMatcher&gt;\ninternal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt; Args(\n    InnerMatcher&amp;&amp; matcher) {\n  return internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt;(\n      std::forward&lt;InnerMatcher&gt;(matcher));\n}\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate &lt;typename InnerMatcher&gt;\ninline InnerMatcher AllArgs(const InnerMatcher&amp; matcher) {\n  return matcher;\n}\n\n// Returns a matcher that matches the value of an optional&lt;&gt; type variable.\n// The matcher implementation only uses &#x27;!arg&#x27; and requires that the optional&lt;&gt;\n// type has a &#x27;value_type&#x27; member type and that &#x27;*arg&#x27; is of type &#x27;value_type&#x27;\n// and is printable using &#x27;PrintToString&#x27;. It is compatible with\n// std::optional/std::experimental::optional.\n// Note that to compare an optional type variable against nullopt you should\n// use Eq(nullopt) and not Eq(Optional(nullopt)). The latter implies that the\n// optional value contains an optional itself.\ntemplate &lt;typename ValueMatcher&gt;\ninline internal::OptionalMatcher&lt;ValueMatcher&gt; Optional(\n    const ValueMatcher&amp; value_matcher) {\n  return internal::OptionalMatcher&lt;ValueMatcher&gt;(value_matcher);\n}\n\n// Returns a matcher that matches the value of a absl::any type variable.\ntemplate &lt;typename T&gt;\nPolymorphicMatcher&lt;internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;&gt; AnyWith(\n    const Matcher&lt;const T&amp;&gt;&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;(matcher));\n}\n\n// Returns a matcher that matches the value of a variant&lt;&gt; type variable.\n// The matcher implementation uses ADL to find the holds_alternative and get\n// functions.\n// It is compatible with std::variant.\ntemplate &lt;typename T&gt;\nPolymorphicMatcher&lt;internal::variant_matcher::VariantMatcher&lt;T&gt;&gt; VariantWith(\n    const Matcher&lt;const T&amp;&gt;&amp; matcher) {\n  return MakePolymorphicMatcher(\n      internal::variant_matcher::VariantMatcher&lt;T&gt;(matcher));\n}\n\n#if GTEST_HAS_EXCEPTIONS\n\n// Anything inside the `internal` namespace is internal to the implementation\n// and must not be used in user code!\nnamespace internal {\n\nclass WithWhatMatcherImpl {\n public:\n  WithWhatMatcherImpl(Matcher&lt;std::string&gt; matcher)\n      : matcher_(std::move(matcher)) {}\n\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;contains .what() that &quot;;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;contains .what() that does not &quot;;\n    matcher_.DescribeTo(os);\n  }\n\n  template &lt;typename Err&gt;\n  bool MatchAndExplain(const Err&amp; err, MatchResultListener* listener) const {\n    *listener &lt;&lt; &quot;which contains .what() (of value = &quot; &lt;&lt; err.what()\n              &lt;&lt; &quot;) that &quot;;\n    return matcher_.MatchAndExplain(err.what(), listener);\n  }\n\n private:\n  const Matcher&lt;std::string&gt; matcher_;\n};\n\ninline PolymorphicMatcher&lt;WithWhatMatcherImpl&gt; WithWhat(\n    Matcher&lt;std::string&gt; m) {\n  return MakePolymorphicMatcher(WithWhatMatcherImpl(std::move(m)));\n}\n\ntemplate &lt;typename Err&gt;\nclass ExceptionMatcherImpl {\n  class NeverThrown {\n   public:\n    const char* what() const noexcept {\n      return &quot;this exception should never be thrown&quot;;\n    }\n  };\n\n  // If the matchee raises an exception of a wrong type, we&#x27;d like to\n  // catch it and print its message and type. To do that, we add an additional\n  // catch clause:\n  //\n  //     try { ... }\n  //     catch (const Err&amp;) { /* an expected exception */ }\n  //     catch (const std::exception&amp;) { /* exception of a wrong type */ }\n  //\n  // However, if the `Err` itself is `std::exception`, we&#x27;d end up with two\n  // identical `catch` clauses:\n  //\n  //     try { ... }\n  //     catch (const std::exception&amp;) { /* an expected exception */ }\n  //     catch (const std::exception&amp;) { /* exception of a wrong type */ }\n  //\n  // This can cause a warning or an error in some compilers. To resolve\n  // the issue, we use a fake error type whenever `Err` is `std::exception`:\n  //\n  //     try { ... }\n  //     catch (const std::exception&amp;) { /* an expected exception */ }\n  //     catch (const NeverThrown&amp;) { /* exception of a wrong type */ }\n  using DefaultExceptionType = typename std::conditional&lt;\n      std::is_same&lt;typename std::remove_cv&lt;\n                       typename std::remove_reference&lt;Err&gt;::type&gt;::type,\n                   std::exception&gt;::value,\n      const NeverThrown&amp;, const std::exception&amp;&gt;::type;\n\n public:\n  ExceptionMatcherImpl(Matcher&lt;const Err&amp;&gt; matcher)\n      : matcher_(std::move(matcher)) {}\n\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;throws an exception which is a &quot; &lt;&lt; GetTypeName&lt;Err&gt;();\n    *os &lt;&lt; &quot; which &quot;;\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; &quot;throws an exception which is not a &quot; &lt;&lt; GetTypeName&lt;Err&gt;();\n    *os &lt;&lt; &quot; which &quot;;\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template &lt;typename T&gt;\n  bool MatchAndExplain(T&amp;&amp; x, MatchResultListener* listener) const {\n    try {\n      (void)(std::forward&lt;T&gt;(x)());\n    } catch (const Err&amp; err) {\n      *listener &lt;&lt; &quot;throws an exception which is a &quot; &lt;&lt; GetTypeName&lt;Err&gt;();\n      *listener &lt;&lt; &quot; &quot;;\n      return matcher_.MatchAndExplain(err, listener);\n    } catch (DefaultExceptionType err) {\n#if GTEST_HAS_RTTI\n      *listener &lt;&lt; &quot;throws an exception of type &quot; &lt;&lt; GetTypeName(typeid(err));\n      *listener &lt;&lt; &quot; &quot;;\n#else\n      *listener &lt;&lt; &quot;throws an std::exception-derived type &quot;;\n#endif\n      *listener &lt;&lt; &quot;with description \\&quot;&quot; &lt;&lt; err.what() &lt;&lt; &quot;\\&quot;&quot;;\n      return false;\n    } catch (...) {\n      *listener &lt;&lt; &quot;throws an exception of an unknown type&quot;;\n      return false;\n    }\n\n    *listener &lt;&lt; &quot;does not throw any exception&quot;;\n    return false;\n  }\n\n private:\n  const Matcher&lt;const Err&amp;&gt; matcher_;\n};\n\n}  // namespace internal\n\n// Throws()\n// Throws(exceptionMatcher)\n// ThrowsMessage(messageMatcher)\n//\n// This matcher accepts a callable and verifies that when invoked, it throws\n// an exception with the given type and properties.\n//\n// Examples:\n//\n//   EXPECT_THAT(\n//       []() { throw std::runtime_error(&quot;message&quot;); },\n//       Throws&lt;std::runtime_error&gt;());\n//\n//   EXPECT_THAT(\n//       []() { throw std::runtime_error(&quot;message&quot;); },\n//       ThrowsMessage&lt;std::runtime_error&gt;(HasSubstr(&quot;message&quot;)));\n//\n//   EXPECT_THAT(\n//       []() { throw std::runtime_error(&quot;message&quot;); },\n//       Throws&lt;std::runtime_error&gt;(\n//           Property(&amp;std::runtime_error::what, HasSubstr(&quot;message&quot;))));\n\ntemplate &lt;typename Err&gt;\nPolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; Throws() {\n  return MakePolymorphicMatcher(\n      internal::ExceptionMatcherImpl&lt;Err&gt;(A&lt;const Err&amp;&gt;()));\n}\n\ntemplate &lt;typename Err, typename ExceptionMatcher&gt;\nPolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; Throws(\n    const ExceptionMatcher&amp; exception_matcher) {\n  // Using matcher cast allows users to pass a matcher of a more broad type.\n  // For example user may want to pass Matcher&lt;std::exception&gt;\n  // to Throws&lt;std::runtime_error&gt;, or Matcher&lt;int64&gt; to Throws&lt;int32&gt;.\n  return MakePolymorphicMatcher(internal::ExceptionMatcherImpl&lt;Err&gt;(\n      SafeMatcherCast&lt;const Err&amp;&gt;(exception_matcher)));\n}\n\ntemplate &lt;typename Err, typename MessageMatcher&gt;\nPolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; ThrowsMessage(\n    MessageMatcher&amp;&amp; message_matcher) {\n  static_assert(std::is_base_of&lt;std::exception, Err&gt;::value,\n                &quot;expected an std::exception-derived type&quot;);\n  return Throws&lt;Err&gt;(internal::WithWhat(\n      MatcherCast&lt;std::string&gt;(std::forward&lt;MessageMatcher&gt;(message_matcher))));\n}\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed if and only if the value matches the matcher.  If the assertion\n// fails, the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) \\\n  ASSERT_PRED_FORMAT1(              \\\n      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) \\\n  EXPECT_PRED_FORMAT1(              \\\n      ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n// MATCHER* macros itself are listed below.\n#define MATCHER(name, description)                                             \\\n  class name##Matcher                                                          \\\n      : public ::testing::internal::MatcherBaseImpl&lt;name##Matcher&gt; {           \\\n   public:                                                                     \\\n    template &lt;typename arg_type&gt;                                               \\\n    class gmock_Impl : public ::testing::MatcherInterface&lt;const arg_type&amp;&gt; {   \\\n     public:                                                                   \\\n      gmock_Impl() {}                                                          \\\n      bool MatchAndExplain(                                                    \\\n          const arg_type&amp; arg,                                                 \\\n          ::testing::MatchResultListener* result_listener) const override;     \\\n      void DescribeTo(::std::ostream* gmock_os) const override {               \\\n        *gmock_os &lt;&lt; FormatDescription(false);                                 \\\n      }                                                                        \\\n      void DescribeNegationTo(::std::ostream* gmock_os) const override {       \\\n        *gmock_os &lt;&lt; FormatDescription(true);                                  \\\n      }                                                                        \\\n                                                                               \\\n     private:                                                                  \\\n      ::std::string FormatDescription(bool negation) const {                   \\\n        /* NOLINTNEXTLINE readability-redundant-string-init */                 \\\n        ::std::string gmock_description = (description);                       \\\n        if (!gmock_description.empty()) {                                      \\\n          return gmock_description;                                            \\\n        }                                                                      \\\n        return ::testing::internal::FormatMatcherDescription(negation, #name,  \\\n                                                             {}, {});          \\\n      }                                                                        \\\n    };                                                                         \\\n  };                                                                           \\\n  GTEST_ATTRIBUTE_UNUSED_ inline name##Matcher name() { return {}; }           \\\n  template &lt;typename arg_type&gt;                                                 \\\n  bool name##Matcher::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(                   \\\n      const arg_type&amp; arg,                                                     \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_) \\\n      const\n\n#define MATCHER_P(name, p0, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP, description, (#p0), (p0))\n#define MATCHER_P2(name, p0, p1, description)                            \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP2, description, (#p0, #p1), \\\n                         (p0, p1))\n#define MATCHER_P3(name, p0, p1, p2, description)                             \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP3, description, (#p0, #p1, #p2), \\\n                         (p0, p1, p2))\n#define MATCHER_P4(name, p0, p1, p2, p3, description)        \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP4, description, \\\n                         (#p0, #p1, #p2, #p3), (p0, p1, p2, p3))\n#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)    \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP5, description, \\\n                         (#p0, #p1, #p2, #p3, #p4), (p0, p1, p2, p3, p4))\n#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP6, description,  \\\n                         (#p0, #p1, #p2, #p3, #p4, #p5),      \\\n                         (p0, p1, p2, p3, p4, p5))\n#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP7, description,      \\\n                         (#p0, #p1, #p2, #p3, #p4, #p5, #p6),     \\\n                         (p0, p1, p2, p3, p4, p5, p6))\n#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP8, description,          \\\n                         (#p0, #p1, #p2, #p3, #p4, #p5, #p6, #p7),    \\\n                         (p0, p1, p2, p3, p4, p5, p6, p7))\n#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP9, description,              \\\n                         (#p0, #p1, #p2, #p3, #p4, #p5, #p6, #p7, #p8),   \\\n                         (p0, p1, p2, p3, p4, p5, p6, p7, p8))\n#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description) \\\n  GMOCK_INTERNAL_MATCHER(name, name##MatcherP10, description,                  \\\n                         (#p0, #p1, #p2, #p3, #p4, #p5, #p6, #p7, #p8, #p9),   \\\n                         (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))\n\n#define GMOCK_INTERNAL_MATCHER(name, full_name, description, arg_names, args)  \\\n  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \\\n  class full_name : public ::testing::internal::MatcherBaseImpl&lt;               \\\n                        full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;&gt; { \\\n   public:                                                                     \\\n    using full_name::MatcherBaseImpl::MatcherBaseImpl;                         \\\n    template &lt;typename arg_type&gt;                                               \\\n    class gmock_Impl : public ::testing::MatcherInterface&lt;const arg_type&amp;&gt; {   \\\n     public:                                                                   \\\n      explicit gmock_Impl(GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args))          \\\n          : GMOCK_INTERNAL_MATCHER_FORWARD_ARGS(args) {}                       \\\n      bool MatchAndExplain(                                                    \\\n          const arg_type&amp; arg,                                                 \\\n          ::testing::MatchResultListener* result_listener) const override;     \\\n      void DescribeTo(::std::ostream* gmock_os) const override {               \\\n        *gmock_os &lt;&lt; FormatDescription(false);                                 \\\n      }                                                                        \\\n      void DescribeNegationTo(::std::ostream* gmock_os) const override {       \\\n        *gmock_os &lt;&lt; FormatDescription(true);                                  \\\n      }                                                                        \\\n      GMOCK_INTERNAL_MATCHER_MEMBERS(args)                                     \\\n                                                                               \\\n     private:                                                                  \\\n      ::std::string FormatDescription(bool negation) const {                   \\\n        ::std::string gmock_description = (description);                       \\\n        if (!gmock_description.empty()) {                                      \\\n          return gmock_description;                                            \\\n        }                                                                      \\\n        return ::testing::internal::FormatMatcherDescription(                  \\\n            negation, #name, {GMOCK_PP_REMOVE_PARENS(arg_names)},              \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(      \\\n                ::std::tuple&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;(        \\\n                    GMOCK_INTERNAL_MATCHER_MEMBERS_USAGE(args))));             \\\n      }                                                                        \\\n    };                                                                         \\\n  };                                                                           \\\n  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \\\n  inline full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt; name(             \\\n      GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args)) {                            \\\n    return full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;(                \\\n        GMOCK_INTERNAL_MATCHER_ARGS_USAGE(args));                              \\\n  }                                                                            \\\n  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \\\n  template &lt;typename arg_type&gt;                                                 \\\n  bool full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;::gmock_Impl&lt;        \\\n      arg_type&gt;::MatchAndExplain(const arg_type&amp; arg,                          \\\n                                 ::testing::MatchResultListener*               \\\n                                     result_listener GTEST_ATTRIBUTE_UNUSED_)  \\\n      const\n\n#define GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args) \\\n  GMOCK_PP_TAIL(                                     \\\n      GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAM, , args))\n#define GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAM(i_unused, data_unused, arg) \\\n  , typename arg##_type\n\n#define GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_TYPE_PARAM, , args))\n#define GMOCK_INTERNAL_MATCHER_TYPE_PARAM(i_unused, data_unused, arg) \\\n  , arg##_type\n\n#define GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args) \\\n  GMOCK_PP_TAIL(dummy_first GMOCK_PP_FOR_EACH(     \\\n      GMOCK_INTERNAL_MATCHER_FUNCTION_ARG, , args))\n#define GMOCK_INTERNAL_MATCHER_FUNCTION_ARG(i, data_unused, arg) \\\n  , arg##_type gmock_p##i\n\n#define GMOCK_INTERNAL_MATCHER_FORWARD_ARGS(args) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_FORWARD_ARG, , args))\n#define GMOCK_INTERNAL_MATCHER_FORWARD_ARG(i, data_unused, arg) \\\n  , arg(::std::forward&lt;arg##_type&gt;(gmock_p##i))\n\n#define GMOCK_INTERNAL_MATCHER_MEMBERS(args) \\\n  GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_MEMBER, , args)\n#define GMOCK_INTERNAL_MATCHER_MEMBER(i_unused, data_unused, arg) \\\n  const arg##_type arg;\n\n#define GMOCK_INTERNAL_MATCHER_MEMBERS_USAGE(args) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_MEMBER_USAGE, , args))\n#define GMOCK_INTERNAL_MATCHER_MEMBER_USAGE(i_unused, data_unused, arg) , arg\n\n#define GMOCK_INTERNAL_MATCHER_ARGS_USAGE(args) \\\n  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_ARG_USAGE, , args))\n#define GMOCK_INTERNAL_MATCHER_ARG_USAGE(i, data_unused, arg_unused) \\\n  , gmock_p##i\n\n// To prevent ADL on certain functions we put them on a separate namespace.\nusing namespace no_adl;  // NOLINT\n\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include &quot;gmock/internal/custom/gmock-matchers.h&quot;\n\n#endif  // GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Implements class templates NiceMock, NaggyMock, and StrictMock.\n//\n// Given a mock class MockFoo that is created using Google Mock,\n// NiceMock&lt;MockFoo&gt; is a subclass of MockFoo that allows\n// uninteresting calls (i.e. calls to mock methods that have no\n// EXPECT_CALL specs), NaggyMock&lt;MockFoo&gt; is a subclass of MockFoo\n// that prints a warning when an uninteresting call occurs, and\n// StrictMock&lt;MockFoo&gt; is a subclass of MockFoo that treats all\n// uninteresting calls as errors.\n//\n// Currently a mock is naggy by default, so MockFoo and\n// NaggyMock&lt;MockFoo&gt; behave like the same.  However, we will soon\n// switch the default behavior of mocks to be nice, as that in general\n// leads to more maintainable tests.  When that happens, MockFoo will\n// stop behaving like NaggyMock&lt;MockFoo&gt; and start behaving like\n// NiceMock&lt;MockFoo&gt;.\n//\n// NiceMock, NaggyMock, and StrictMock &quot;inherit&quot; the constructors of\n// their respective base class.  Therefore you can write\n// NiceMock&lt;MockFoo&gt;(5, &quot;a&quot;) to construct a nice mock where MockFoo\n// has a constructor that accepts (int, const char*), for example.\n//\n// A known limitation is that NiceMock&lt;MockFoo&gt;, NaggyMock&lt;MockFoo&gt;,\n// and StrictMock&lt;MockFoo&gt; only works for mock methods defined using\n// the MOCK_METHOD* family of macros DIRECTLY in the MockFoo class.\n// If a mock method is defined in a base class of MockFoo, the &quot;nice&quot;\n// or &quot;strict&quot; modifier may not affect it, depending on the compiler.\n// In particular, nesting NiceMock, NaggyMock, and StrictMock is NOT\n// supported.\n\n// IWYU pragma: private, include &quot;gmock/gmock.h&quot;\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_\n#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_\n\n#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gmock/gmock-spec-builders.h&quot;\n#include &quot;gmock/internal/gmock-port.h&quot;\n\nnamespace testing {\ntemplate &lt;class MockClass&gt;\nclass NiceMock;\ntemplate &lt;class MockClass&gt;\nclass NaggyMock;\ntemplate &lt;class MockClass&gt;\nclass StrictMock;\n\nnamespace internal {\ntemplate &lt;typename T&gt;\nstd::true_type StrictnessModifierProbe(const NiceMock&lt;T&gt;&amp;);\ntemplate &lt;typename T&gt;\nstd::true_type StrictnessModifierProbe(const NaggyMock&lt;T&gt;&amp;);\ntemplate &lt;typename T&gt;\nstd::true_type StrictnessModifierProbe(const StrictMock&lt;T&gt;&amp;);\nstd::false_type StrictnessModifierProbe(...);\n\ntemplate &lt;typename T&gt;\nconstexpr bool HasStrictnessModifier() {\n  return decltype(StrictnessModifierProbe(std::declval&lt;const T&amp;&gt;()))::value;\n}\n\n// Base classes that register and deregister with testing::Mock to alter the\n// default behavior around uninteresting calls. Inheriting from one of these\n// classes first and then MockClass ensures the MockClass constructor is run\n// after registration, and that the MockClass destructor runs before\n// deregistration. This guarantees that MockClass&#x27;s constructor and destructor\n// run with the same level of strictness as its instance methods.\n\n#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW &amp;&amp; \\\n    (defined(_MSC_VER) || defined(__clang__))\n// We need to mark these classes with this declspec to ensure that\n// the empty base class optimization is performed.\n#define GTEST_INTERNAL_EMPTY_BASE_CLASS __declspec(empty_bases)\n#else\n#define GTEST_INTERNAL_EMPTY_BASE_CLASS\n#endif\n\ntemplate &lt;typename Base&gt;\nclass NiceMockImpl {\n public:\n  NiceMockImpl() {\n    ::testing::Mock::AllowUninterestingCalls(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n\n  ~NiceMockImpl() {\n    ::testing::Mock::UnregisterCallReaction(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n};\n\ntemplate &lt;typename Base&gt;\nclass NaggyMockImpl {\n public:\n  NaggyMockImpl() {\n    ::testing::Mock::WarnUninterestingCalls(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n\n  ~NaggyMockImpl() {\n    ::testing::Mock::UnregisterCallReaction(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n};\n\ntemplate &lt;typename Base&gt;\nclass StrictMockImpl {\n public:\n  StrictMockImpl() {\n    ::testing::Mock::FailUninterestingCalls(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n\n  ~StrictMockImpl() {\n    ::testing::Mock::UnregisterCallReaction(reinterpret_cast&lt;uintptr_t&gt;(this));\n  }\n};\n\n}  // namespace internal\n\ntemplate &lt;class MockClass&gt;\nclass GTEST_INTERNAL_EMPTY_BASE_CLASS NiceMock\n    : private internal::NiceMockImpl&lt;MockClass&gt;,\n      public MockClass {\n public:\n  static_assert(!internal::HasStrictnessModifier&lt;MockClass&gt;(),\n                &quot;Can&#x27;t apply NiceMock to a class hierarchy that already has a &quot;\n                &quot;strictness modifier. See &quot;\n                &quot;https://google.github.io/googletest/&quot;\n                &quot;gmock_cook_book.html#NiceStrictNaggy&quot;);\n  NiceMock() : MockClass() {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  // Ideally, we would inherit base class&#x27;s constructors through a using\n  // declaration, which would preserve their visibility. However, many existing\n  // tests rely on the fact that current implementation reexports protected\n  // constructors as public. These tests would need to be cleaned up first.\n\n  // Single argument constructor is special-cased so that it can be\n  // made explicit.\n  template &lt;typename A&gt;\n  explicit NiceMock(A&amp;&amp; arg) : MockClass(std::forward&lt;A&gt;(arg)) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  template &lt;typename TArg1, typename TArg2, typename... An&gt;\n  NiceMock(TArg1&amp;&amp; arg1, TArg2&amp;&amp; arg2, An&amp;&amp;... args)\n      : MockClass(std::forward&lt;TArg1&gt;(arg1), std::forward&lt;TArg2&gt;(arg2),\n                  std::forward&lt;An&gt;(args)...) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n private:\n  NiceMock(const NiceMock&amp;) = delete;\n  NiceMock&amp; operator=(const NiceMock&amp;) = delete;\n};\n\ntemplate &lt;class MockClass&gt;\nclass GTEST_INTERNAL_EMPTY_BASE_CLASS NaggyMock\n    : private internal::NaggyMockImpl&lt;MockClass&gt;,\n      public MockClass {\n  static_assert(!internal::HasStrictnessModifier&lt;MockClass&gt;(),\n                &quot;Can&#x27;t apply NaggyMock to a class hierarchy that already has a &quot;\n                &quot;strictness modifier. See &quot;\n                &quot;https://google.github.io/googletest/&quot;\n                &quot;gmock_cook_book.html#NiceStrictNaggy&quot;);\n\n public:\n  NaggyMock() : MockClass() {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  // Ideally, we would inherit base class&#x27;s constructors through a using\n  // declaration, which would preserve their visibility. However, many existing\n  // tests rely on the fact that current implementation reexports protected\n  // constructors as public. These tests would need to be cleaned up first.\n\n  // Single argument constructor is special-cased so that it can be\n  // made explicit.\n  template &lt;typename A&gt;\n  explicit NaggyMock(A&amp;&amp; arg) : MockClass(std::forward&lt;A&gt;(arg)) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  template &lt;typename TArg1, typename TArg2, typename... An&gt;\n  NaggyMock(TArg1&amp;&amp; arg1, TArg2&amp;&amp; arg2, An&amp;&amp;... args)\n      : MockClass(std::forward&lt;TArg1&gt;(arg1), std::forward&lt;TArg2&gt;(arg2),\n                  std::forward&lt;An&gt;(args)...) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n private:\n  NaggyMock(const NaggyMock&amp;) = delete;\n  NaggyMock&amp; operator=(const NaggyMock&amp;) = delete;\n};\n\ntemplate &lt;class MockClass&gt;\nclass GTEST_INTERNAL_EMPTY_BASE_CLASS StrictMock\n    : private internal::StrictMockImpl&lt;MockClass&gt;,\n      public MockClass {\n public:\n  static_assert(\n      !internal::HasStrictnessModifier&lt;MockClass&gt;(),\n      &quot;Can&#x27;t apply StrictMock to a class hierarchy that already has a &quot;\n      &quot;strictness modifier. See &quot;\n      &quot;https://google.github.io/googletest/&quot;\n      &quot;gmock_cook_book.html#NiceStrictNaggy&quot;);\n  StrictMock() : MockClass() {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  // Ideally, we would inherit base class&#x27;s constructors through a using\n  // declaration, which would preserve their visibility. However, many existing\n  // tests rely on the fact that current implementation reexports protected\n  // constructors as public. These tests would need to be cleaned up first.\n\n  // Single argument constructor is special-cased so that it can be\n  // made explicit.\n  template &lt;typename A&gt;\n  explicit StrictMock(A&amp;&amp; arg) : MockClass(std::forward&lt;A&gt;(arg)) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n  template &lt;typename TArg1, typename TArg2, typename... An&gt;\n  StrictMock(TArg1&amp;&amp; arg1, TArg2&amp;&amp; arg2, An&amp;&amp;... args)\n      : MockClass(std::forward&lt;TArg1&gt;(arg1), std::forward&lt;TArg2&gt;(arg2),\n                  std::forward&lt;An&gt;(args)...) {\n    static_assert(sizeof(*this) == sizeof(MockClass),\n                  &quot;The impl subclass shouldn&#x27;t introduce any padding&quot;);\n  }\n\n private:\n  StrictMock(const StrictMock&amp;) = delete;\n  StrictMock&amp; operator=(const StrictMock&amp;) = delete;\n};\n\n#undef GTEST_INTERNAL_EMPTY_BASE_CLASS\n\n}  // namespace testing\n\n#endif  // GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_\n"}, "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc": {"id": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc", "filePath": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file defines some utilities useful for implementing Google\n// Mock.  They are subject to change without notice, so please DO NOT\n// USE THEM IN USER CODE.\n\n#include &quot;gmock/internal/gmock-internal-utils.h&quot;\n\n#include &lt;ctype.h&gt;\n\n#include &lt;array&gt;\n#include &lt;cctype&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &quot;gmock/gmock.h&quot;\n#include &quot;gmock/internal/gmock-port.h&quot;\n#include &quot;gtest/gtest.h&quot;\n\nnamespace testing {\nnamespace internal {\n\n// Joins a vector of strings as if they are fields of a tuple; returns\n// the joined string.\nGTEST_API_ std::string JoinAsKeyValueTuple(\n    const std::vector&lt;const char*&gt;&amp; names, const Strings&amp; values) {\n  GTEST_CHECK_(names.size() == values.size());\n  if (values.empty()) {\n    return &quot;&quot;;\n  }\n  const auto build_one = [&amp;](const size_t i) {\n    return std::string(names[i]) + &quot;: &quot; + values[i];\n  };\n  std::string result = &quot;(&quot; + build_one(0);\n  for (size_t i = 1; i &lt; values.size(); i++) {\n    result += &quot;, &quot;;\n    result += build_one(i);\n  }\n  result += &quot;)&quot;;\n  return result;\n}\n\n// Converts an identifier name to a space-separated list of lower-case\n// words.  Each maximum substring of the form [A-Za-z][a-z]*|\\d+ is\n// treated as one word.  For example, both &quot;FooBar123&quot; and\n// &quot;foo_bar_123&quot; are converted to &quot;foo bar 123&quot;.\nGTEST_API_ std::string ConvertIdentifierNameToWords(const char* id_name) {\n  std::string result;\n  char prev_char = &#x27;\\0&#x27;;\n  for (const char* p = id_name; *p != &#x27;\\0&#x27;; prev_char = *(p++)) {\n    // We don&#x27;t care about the current locale as the input is\n    // guaranteed to be a valid C++ identifier name.\n    const bool starts_new_word = IsUpper(*p) ||\n                                 (!IsAlpha(prev_char) &amp;&amp; IsLower(*p)) ||\n                                 (!IsDigit(prev_char) &amp;&amp; IsDigit(*p));\n\n    if (IsAlNum(*p)) {\n      if (starts_new_word &amp;&amp; result != &quot;&quot;) result += &#x27; &#x27;;\n      result += ToLower(*p);\n    }\n  }\n  return result;\n}\n\n// This class reports Google Mock failures as Google Test failures.  A\n// user can define another class in a similar fashion if they intend to\n// use Google Mock with a testing framework other than Google Test.\nclass GoogleTestFailureReporter : public FailureReporterInterface {\n public:\n  void ReportFailure(FailureType type, const char* file, int line,\n                     const std::string&amp; message) override {\n    AssertHelper(type == kFatal ? TestPartResult::kFatalFailure\n                                : TestPartResult::kNonFatalFailure,\n                 file, line, message.c_str()) = Message();\n    if (type == kFatal) {\n      posix::Abort();\n    }\n  }\n};\n\n// Returns the global failure reporter.  Will create a\n// GoogleTestFailureReporter and return it the first time called.\nGTEST_API_ FailureReporterInterface* GetFailureReporter() {\n  // Points to the global failure reporter used by Google Mock.  gcc\n  // guarantees that the following use of failure_reporter is\n  // thread-safe.  We may need to add additional synchronization to\n  // protect failure_reporter if we port Google Mock to other\n  // compilers.\n  static FailureReporterInterface* const failure_reporter =\n      new GoogleTestFailureReporter();\n  return failure_reporter;\n}\n\n// Protects global resources (stdout in particular) used by Log().\nstatic GTEST_DEFINE_STATIC_MUTEX_(g_log_mutex);\n\n// Returns true if and only if a log with the given severity is visible\n// according to the --gmock_verbose flag.\nGTEST_API_ bool LogIsVisible(LogSeverity severity) {\n  if (GMOCK_FLAG_GET(verbose) == kInfoVerbosity) {\n    // Always show the log if --gmock_verbose=info.\n    return true;\n  } else if (GMOCK_FLAG_GET(verbose) == kErrorVerbosity) {\n    // Always hide it if --gmock_verbose=error.\n    return false;\n  } else {\n    // If --gmock_verbose is neither &quot;info&quot; nor &quot;error&quot;, we treat it\n    // as &quot;warning&quot; (its default value).\n    return severity == kWarning;\n  }\n}\n\n// Prints the given message to stdout if and only if &#x27;severity&#x27; &gt;= the level\n// specified by the --gmock_verbose flag.  If stack_frames_to_skip &gt;=\n// 0, also prints the stack trace excluding the top\n// stack_frames_to_skip frames.  In opt mode, any positive\n// stack_frames_to_skip is treated as 0, since we don&#x27;t know which\n// function calls will be inlined by the compiler and need to be\n// conservative.\nGTEST_API_ void Log(LogSeverity severity, const std::string&amp; message,\n                    int stack_frames_to_skip) {\n  if (!LogIsVisible(severity)) return;\n\n  // Ensures that logs from different threads don&#x27;t interleave.\n  MutexLock l(&amp;g_log_mutex);\n\n  if (severity == kWarning) {\n    // Prints a GMOCK WARNING marker to make the warnings easily searchable.\n    std::cout &lt;&lt; &quot;\\nGMOCK WARNING:&quot;;\n  }\n  // Pre-pends a new-line to message if it doesn&#x27;t start with one.\n  if (message.empty() || message[0] != &#x27;\\n&#x27;) {\n    std::cout &lt;&lt; &quot;\\n&quot;;\n  }\n  std::cout &lt;&lt; message;\n  if (stack_frames_to_skip &gt;= 0) {\n#ifdef NDEBUG\n    // In opt mode, we have to be conservative and skip no stack frame.\n    const int actual_to_skip = 0;\n#else\n    // In dbg mode, we can do what the caller tell us to do (plus one\n    // for skipping this function&#x27;s stack frame).\n    const int actual_to_skip = stack_frames_to_skip + 1;\n#endif  // NDEBUG\n\n    // Appends a new-line to message if it doesn&#x27;t end with one.\n    if (!message.empty() &amp;&amp; *message.rbegin() != &#x27;\\n&#x27;) {\n      std::cout &lt;&lt; &quot;\\n&quot;;\n    }\n    std::cout &lt;&lt; &quot;Stack trace:\\n&quot;\n              &lt;&lt; ::testing::internal::GetCurrentOsStackTraceExceptTop(\n                     ::testing::UnitTest::GetInstance(), actual_to_skip);\n  }\n  std::cout &lt;&lt; ::std::flush;\n}\n\nGTEST_API_ WithoutMatchers GetWithoutMatchers() { return WithoutMatchers(); }\n\nGTEST_API_ void IllegalDoDefault(const char* file, int line) {\n  internal::Assert(\n      false, file, line,\n      &quot;You are using DoDefault() inside a composite action like &quot;\n      &quot;DoAll() or WithArgs().  This is not supported for technical &quot;\n      &quot;reasons.  Please instead spell out the default action, or &quot;\n      &quot;assign the default action to an Action variable and use &quot;\n      &quot;the variable in various places.&quot;);\n}\n\nconstexpr char UnBase64Impl(char c, const char* const base64, char carry) {\n  return *base64 == 0   ? static_cast&lt;char&gt;(65)\n         : *base64 == c ? carry\n                        : UnBase64Impl(c, base64 + 1, carry + 1);\n}\n\ntemplate &lt;size_t... I&gt;\nconstexpr std::array&lt;char, 256&gt; UnBase64Impl(IndexSequence&lt;I...&gt;,\n                                             const char* const base64) {\n  return {{UnBase64Impl(static_cast&lt;char&gt;(I), base64, 0)...}};\n}\n\nconstexpr std::array&lt;char, 256&gt; UnBase64(const char* const base64) {\n  return UnBase64Impl(MakeIndexSequence&lt;256&gt;{}, base64);\n}\n\nstatic constexpr char kBase64[] =\n    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;\nstatic constexpr std::array&lt;char, 256&gt; kUnBase64 = UnBase64(kBase64);\n\nbool Base64Unescape(const std::string&amp; encoded, std::string* decoded) {\n  decoded-&gt;clear();\n  size_t encoded_len = encoded.size();\n  decoded-&gt;reserve(3 * (encoded_len / 4) + (encoded_len % 4));\n  int bit_pos = 0;\n  char dst = 0;\n  for (int src : encoded) {\n    if (std::isspace(src) || src == &#x27;=&#x27;) {\n      continue;\n    }\n    char src_bin = kUnBase64[static_cast&lt;size_t&gt;(src)];\n    if (src_bin &gt;= 64) {\n      decoded-&gt;clear();\n      return false;\n    }\n    if (bit_pos == 0) {\n      dst |= static_cast&lt;char&gt;(src_bin &lt;&lt; 2);\n      bit_pos = 6;\n    } else {\n      dst |= static_cast&lt;char&gt;(src_bin &gt;&gt; (bit_pos - 2));\n      decoded-&gt;push_back(dst);\n      dst = static_cast&lt;char&gt;(src_bin &lt;&lt; (10 - bit_pos));\n      bit_pos = (bit_pos + 6) % 8;\n    }\n  }\n  return true;\n}\n\n}  // namespace internal\n}  // namespace testing\n"}}, "reports": [{"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h", "reportHash": "d8a63670b4de5d6c89d36bcf830c07e0", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h", "checker": {"name": "misc-throw-by-value-catch-by-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/throw-by-value-catch-by-reference.html"}, "analyzerName": "clang-tidy", "line": 1739, "column": 41, "message": "throw expression should throw anonymous temporary values instead", "events": [{"message": "throw expression should throw anonymous temporary values instead", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h", "line": 1739, "column": 41}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "HIGH", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "reportHash": "7d7555700f7b12751d906b129a7075f0", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "checker": {"name": "misc-unconventional-assign-operator", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"}, "analyzerName": "clang-tidy", "line": 3823, "column": 3, "message": "operator=() should return 'BoundSecondMatcher&'", "events": [{"message": "operator=() should return 'BoundSecondMatcher&'", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "line": 3823, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "reportHash": "b497e57ce53aad772d4977434f94b4d5", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "checker": {"name": "misc-throw-by-value-catch-by-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/throw-by-value-catch-by-reference.html"}, "analyzerName": "clang-tidy", "line": 5355, "column": 14, "message": "catch handler catches by value; should catch by reference instead", "events": [{"message": "catch handler catches by value; should catch by reference instead", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h", "line": 5355, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "HIGH", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "reportHash": "4c9f543843afbd3cf0644890cd4e5695", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 171, "column": 12, "message": "constructor accepting a forwarding reference can hide the move constructor", "events": [{"message": "constructor accepting a forwarding reference can hide the move constructor", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "line": 171, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "reportHash": "57f0024c7103f2fb04185fa9a4829df4", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 213, "column": 12, "message": "constructor accepting a forwarding reference can hide the move constructor", "events": [{"message": "constructor accepting a forwarding reference can hide the move constructor", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "line": 213, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "reportHash": "21c86d447fe23d39ee656f4770223c00", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 255, "column": 12, "message": "constructor accepting a forwarding reference can hide the move constructor", "events": [{"message": "constructor accepting a forwarding reference can hide the move constructor", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h", "line": 255, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null}, {"fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc", "reportHash": "084107c9028d0e1c44231c8141cb049a", "path": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 227, "column": 16, "message": "'signed char' to 'int' conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'int' conversion; consider casting to 'unsigned char' first.", "fileId": "/home/pello/PySysLinkBase/.codechecker/_deps/googletest-src/googlemock/src/gmock-internal-utils.cc", "line": 227, "column": 16}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
